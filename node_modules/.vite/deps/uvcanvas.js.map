{
  "version": 3,
  "sources": ["../../uvcanvas/dist/components/button/index.js", "../../uvcanvas/dist/components/input/index.js", "../../ogl/src/math/functions/Vec3Func.js", "../../ogl/src/math/Vec3.js", "../../ogl/src/core/Geometry.js", "../../ogl/src/core/Program.js", "../../ogl/src/core/Renderer.js", "../../ogl/src/math/functions/Vec4Func.js", "../../ogl/src/math/functions/QuatFunc.js", "../../ogl/src/math/Quat.js", "../../ogl/src/math/functions/Mat4Func.js", "../../ogl/src/math/Mat4.js", "../../ogl/src/math/functions/EulerFunc.js", "../../ogl/src/math/Euler.js", "../../ogl/src/core/Transform.js", "../../ogl/src/core/Camera.js", "../../ogl/src/math/functions/Mat3Func.js", "../../ogl/src/math/Mat3.js", "../../ogl/src/core/Mesh.js", "../../ogl/src/core/Texture.js", "../../ogl/src/math/functions/ColorFunc.js", "../../ogl/src/math/Color.js", "../../ogl/src/math/functions/Vec2Func.js", "../../ogl/src/math/Vec2.js", "../../ogl/src/extras/Triangle.js", "../../ogl/src/extras/Orbit.js", "../../ogl/src/extras/Raycast.js", "../../ogl/src/extras/Curve.js", "../../ogl/src/extras/path/CubicBezierSegment.js", "../../ogl/src/extras/path/QuadraticBezierSegment.js", "../../ogl/src/extras/path/LineSegment.js", "../../ogl/src/extras/path/Path.js", "../../ogl/src/extras/Tube.js", "../../ogl/src/extras/Animation.js", "../../ogl/src/extras/Skin.js", "../../ogl/src/extras/Polyline.js", "../../ogl/src/extras/GLTFAnimation.js", "../../ogl/src/extras/GLTFSkin.js", "../../ogl/src/extras/helpers/FaceNormalsHelper.js", "../../uvcanvas/dist/components/lumiflex/index.js", "../../uvcanvas/dist/components/zenitho/index.js", "../../uvcanvas/dist/components/novatrix/index.js", "../../uvcanvas/dist/components/velustro/index.js", "../../uvcanvas/dist/components/opulento/index.js", "../../uvcanvas/dist/components/tranquiluxe/index.js", "../../uvcanvas/dist/index.js"],
  "sourcesContent": ["\"use client\"\nimport React from 'react';\n\nvar styles = {\"button\":\"styles-module_button__-MIzJ\"};\n\nfunction Button(props) {\n    const { className, ...restProps } = props;\n    return React.createElement(\"button\", { className: `${className} ${styles.button}`, ...restProps });\n}\n\nexport { Button };\n", "\"use client\"\nimport React from 'react';\n\nvar styles = {\"input\":\"styles-module_input__0W6nK\"};\n\n// lib/components/Input/index.tsx\nfunction Input(props) {\n    const { className, ...restProps } = props;\n    return React.createElement(\"input\", { className: `${className} ${styles.button}`, ...restProps });\n}\n\nexport { Input };\n", "const EPSILON = 0.000001;\n\n/**\n * Calculates the length of a vec3\n *\n * @param {vec3} a vector to calculate length of\n * @returns {Number} length of a\n */\nexport function length(a) {\n    let x = a[0];\n    let y = a[1];\n    let z = a[2];\n    return Math.sqrt(x * x + y * y + z * z);\n}\n\n/**\n * Copy the values from one vec3 to another\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the source vector\n * @returns {vec3} out\n */\nexport function copy(out, a) {\n    out[0] = a[0];\n    out[1] = a[1];\n    out[2] = a[2];\n    return out;\n}\n\n/**\n * Set the components of a vec3 to the given values\n *\n * @param {vec3} out the receiving vector\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @returns {vec3} out\n */\nexport function set(out, x, y, z) {\n    out[0] = x;\n    out[1] = y;\n    out[2] = z;\n    return out;\n}\n\n/**\n * Adds two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\nexport function add(out, a, b) {\n    out[0] = a[0] + b[0];\n    out[1] = a[1] + b[1];\n    out[2] = a[2] + b[2];\n    return out;\n}\n\n/**\n * Subtracts vector b from vector a\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\nexport function subtract(out, a, b) {\n    out[0] = a[0] - b[0];\n    out[1] = a[1] - b[1];\n    out[2] = a[2] - b[2];\n    return out;\n}\n\n/**\n * Multiplies two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\nexport function multiply(out, a, b) {\n    out[0] = a[0] * b[0];\n    out[1] = a[1] * b[1];\n    out[2] = a[2] * b[2];\n    return out;\n}\n\n/**\n * Divides two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\nexport function divide(out, a, b) {\n    out[0] = a[0] / b[0];\n    out[1] = a[1] / b[1];\n    out[2] = a[2] / b[2];\n    return out;\n}\n\n/**\n * Scales a vec3 by a scalar number\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @returns {vec3} out\n */\nexport function scale(out, a, b) {\n    out[0] = a[0] * b;\n    out[1] = a[1] * b;\n    out[2] = a[2] * b;\n    return out;\n}\n\n/**\n * Calculates the euclidian distance between two vec3's\n *\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {Number} distance between a and b\n */\nexport function distance(a, b) {\n    let x = b[0] - a[0];\n    let y = b[1] - a[1];\n    let z = b[2] - a[2];\n    return Math.sqrt(x * x + y * y + z * z);\n}\n\n/**\n * Calculates the squared euclidian distance between two vec3's\n *\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {Number} squared distance between a and b\n */\nexport function squaredDistance(a, b) {\n    let x = b[0] - a[0];\n    let y = b[1] - a[1];\n    let z = b[2] - a[2];\n    return x * x + y * y + z * z;\n}\n\n/**\n * Calculates the squared length of a vec3\n *\n * @param {vec3} a vector to calculate squared length of\n * @returns {Number} squared length of a\n */\nexport function squaredLength(a) {\n    let x = a[0];\n    let y = a[1];\n    let z = a[2];\n    return x * x + y * y + z * z;\n}\n\n/**\n * Negates the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a vector to negate\n * @returns {vec3} out\n */\nexport function negate(out, a) {\n    out[0] = -a[0];\n    out[1] = -a[1];\n    out[2] = -a[2];\n    return out;\n}\n\n/**\n * Returns the inverse of the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a vector to invert\n * @returns {vec3} out\n */\nexport function inverse(out, a) {\n    out[0] = 1.0 / a[0];\n    out[1] = 1.0 / a[1];\n    out[2] = 1.0 / a[2];\n    return out;\n}\n\n/**\n * Normalize a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a vector to normalize\n * @returns {vec3} out\n */\nexport function normalize(out, a) {\n    let x = a[0];\n    let y = a[1];\n    let z = a[2];\n    let len = x * x + y * y + z * z;\n    if (len > 0) {\n        //TODO: evaluate use of glm_invsqrt here?\n        len = 1 / Math.sqrt(len);\n    }\n    out[0] = a[0] * len;\n    out[1] = a[1] * len;\n    out[2] = a[2] * len;\n    return out;\n}\n\n/**\n * Calculates the dot product of two vec3's\n *\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {Number} dot product of a and b\n */\nexport function dot(a, b) {\n    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\n}\n\n/**\n * Computes the cross product of two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @returns {vec3} out\n */\nexport function cross(out, a, b) {\n    let ax = a[0],\n        ay = a[1],\n        az = a[2];\n    let bx = b[0],\n        by = b[1],\n        bz = b[2];\n\n    out[0] = ay * bz - az * by;\n    out[1] = az * bx - ax * bz;\n    out[2] = ax * by - ay * bx;\n    return out;\n}\n\n/**\n * Performs a linear interpolation between two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @param {Number} t interpolation amount between the two inputs\n * @returns {vec3} out\n */\nexport function lerp(out, a, b, t) {\n    let ax = a[0];\n    let ay = a[1];\n    let az = a[2];\n    out[0] = ax + t * (b[0] - ax);\n    out[1] = ay + t * (b[1] - ay);\n    out[2] = az + t * (b[2] - az);\n    return out;\n}\n\n/**\n * Performs a frame rate independant, linear interpolation between two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the first operand\n * @param {vec3} b the second operand\n * @param {Number} decay decay constant for interpolation. useful range between 1 and 25, from slow to fast.\n * @param {Number} dt delta time\n * @returns {vec3} out\n */\nexport function smoothLerp(out, a, b, decay, dt) {\n    const exp = Math.exp(-decay * dt);\n    let ax = a[0];\n    let ay = a[1];\n    let az = a[2];\n\n    out[0] = b[0] + (ax - b[0]) * exp;\n    out[1] = b[1] + (ay - b[1]) * exp;\n    out[2] = b[2] + (az - b[2]) * exp;\n    return out;\n}\n\n/**\n * Transforms the vec3 with a mat4.\n * 4th vector component is implicitly '1'\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the vector to transform\n * @param {mat4} m matrix to transform with\n * @returns {vec3} out\n */\nexport function transformMat4(out, a, m) {\n    let x = a[0],\n        y = a[1],\n        z = a[2];\n    let w = m[3] * x + m[7] * y + m[11] * z + m[15];\n    w = w || 1.0;\n    out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;\n    out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;\n    out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;\n    return out;\n}\n\n/**\n * Same as above but doesn't apply translation.\n * Useful for rays.\n */\nexport function scaleRotateMat4(out, a, m) {\n    let x = a[0],\n        y = a[1],\n        z = a[2];\n    let w = m[3] * x + m[7] * y + m[11] * z + m[15];\n    w = w || 1.0;\n    out[0] = (m[0] * x + m[4] * y + m[8] * z) / w;\n    out[1] = (m[1] * x + m[5] * y + m[9] * z) / w;\n    out[2] = (m[2] * x + m[6] * y + m[10] * z) / w;\n    return out;\n}\n\n/**\n * Transforms the vec3 with a mat3.\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the vector to transform\n * @param {mat3} m the 3x3 matrix to transform with\n * @returns {vec3} out\n */\nexport function transformMat3(out, a, m) {\n    let x = a[0],\n        y = a[1],\n        z = a[2];\n    out[0] = x * m[0] + y * m[3] + z * m[6];\n    out[1] = x * m[1] + y * m[4] + z * m[7];\n    out[2] = x * m[2] + y * m[5] + z * m[8];\n    return out;\n}\n\n/**\n * Transforms the vec3 with a quat\n *\n * @param {vec3} out the receiving vector\n * @param {vec3} a the vector to transform\n * @param {quat} q quaternion to transform with\n * @returns {vec3} out\n */\nexport function transformQuat(out, a, q) {\n    // benchmarks: https://jsperf.com/quaternion-transform-vec3-implementations-fixed\n\n    let x = a[0],\n        y = a[1],\n        z = a[2];\n    let qx = q[0],\n        qy = q[1],\n        qz = q[2],\n        qw = q[3];\n\n    let uvx = qy * z - qz * y;\n    let uvy = qz * x - qx * z;\n    let uvz = qx * y - qy * x;\n\n    let uuvx = qy * uvz - qz * uvy;\n    let uuvy = qz * uvx - qx * uvz;\n    let uuvz = qx * uvy - qy * uvx;\n\n    let w2 = qw * 2;\n    uvx *= w2;\n    uvy *= w2;\n    uvz *= w2;\n\n    uuvx *= 2;\n    uuvy *= 2;\n    uuvz *= 2;\n\n    out[0] = x + uvx + uuvx;\n    out[1] = y + uvy + uuvy;\n    out[2] = z + uvz + uuvz;\n    return out;\n}\n\n/**\n * Get the angle between two 3D vectors\n * @param {vec3} a The first operand\n * @param {vec3} b The second operand\n * @returns {Number} The angle in radians\n */\nexport const angle = (function () {\n    const tempA = [0, 0, 0];\n    const tempB = [0, 0, 0];\n\n    return function (a, b) {\n        copy(tempA, a);\n        copy(tempB, b);\n\n        normalize(tempA, tempA);\n        normalize(tempB, tempB);\n\n        let cosine = dot(tempA, tempB);\n\n        if (cosine > 1.0) {\n            return 0;\n        } else if (cosine < -1.0) {\n            return Math.PI;\n        } else {\n            return Math.acos(cosine);\n        }\n    };\n})();\n\n/**\n * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)\n *\n * @param {vec3} a The first vector.\n * @param {vec3} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\nexport function exactEquals(a, b) {\n    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];\n}\n", "import * as Vec3Func from './functions/Vec3Func.js';\n\nexport class Vec3 extends Array {\n    constructor(x = 0, y = x, z = x) {\n        super(x, y, z);\n        return this;\n    }\n\n    get x() {\n        return this[0];\n    }\n\n    get y() {\n        return this[1];\n    }\n\n    get z() {\n        return this[2];\n    }\n\n    set x(v) {\n        this[0] = v;\n    }\n\n    set y(v) {\n        this[1] = v;\n    }\n\n    set z(v) {\n        this[2] = v;\n    }\n\n    set(x, y = x, z = x) {\n        if (x.length) return this.copy(x);\n        Vec3Func.set(this, x, y, z);\n        return this;\n    }\n\n    copy(v) {\n        Vec3Func.copy(this, v);\n        return this;\n    }\n\n    add(va, vb) {\n        if (vb) Vec3Func.add(this, va, vb);\n        else Vec3Func.add(this, this, va);\n        return this;\n    }\n\n    sub(va, vb) {\n        if (vb) Vec3Func.subtract(this, va, vb);\n        else Vec3Func.subtract(this, this, va);\n        return this;\n    }\n\n    multiply(v) {\n        if (v.length) Vec3Func.multiply(this, this, v);\n        else Vec3Func.scale(this, this, v);\n        return this;\n    }\n\n    divide(v) {\n        if (v.length) Vec3Func.divide(this, this, v);\n        else Vec3Func.scale(this, this, 1 / v);\n        return this;\n    }\n\n    inverse(v = this) {\n        Vec3Func.inverse(this, v);\n        return this;\n    }\n\n    // Can't use 'length' as Array.prototype uses it\n    len() {\n        return Vec3Func.length(this);\n    }\n\n    distance(v) {\n        if (v) return Vec3Func.distance(this, v);\n        else return Vec3Func.length(this);\n    }\n\n    squaredLen() {\n        return Vec3Func.squaredLength(this);\n    }\n\n    squaredDistance(v) {\n        if (v) return Vec3Func.squaredDistance(this, v);\n        else return Vec3Func.squaredLength(this);\n    }\n\n    negate(v = this) {\n        Vec3Func.negate(this, v);\n        return this;\n    }\n\n    cross(va, vb) {\n        if (vb) Vec3Func.cross(this, va, vb);\n        else Vec3Func.cross(this, this, va);\n        return this;\n    }\n\n    scale(v) {\n        Vec3Func.scale(this, this, v);\n        return this;\n    }\n\n    normalize() {\n        Vec3Func.normalize(this, this);\n        return this;\n    }\n\n    dot(v) {\n        return Vec3Func.dot(this, v);\n    }\n\n    equals(v) {\n        return Vec3Func.exactEquals(this, v);\n    }\n\n    applyMatrix3(mat3) {\n        Vec3Func.transformMat3(this, this, mat3);\n        return this;\n    }\n\n    applyMatrix4(mat4) {\n        Vec3Func.transformMat4(this, this, mat4);\n        return this;\n    }\n\n    scaleRotateMatrix4(mat4) {\n        Vec3Func.scaleRotateMat4(this, this, mat4);\n        return this;\n    }\n\n    applyQuaternion(q) {\n        Vec3Func.transformQuat(this, this, q);\n        return this;\n    }\n\n    angle(v) {\n        return Vec3Func.angle(this, v);\n    }\n\n    lerp(v, t) {\n        Vec3Func.lerp(this, this, v, t);\n        return this;\n    }\n\n    smoothLerp(v, decay, dt) {\n        Vec3Func.smoothLerp(this, this, v, decay, dt);\n        return this;\n    }\n\n    clone() {\n        return new Vec3(this[0], this[1], this[2]);\n    }\n\n    fromArray(a, o = 0) {\n        this[0] = a[o];\n        this[1] = a[o + 1];\n        this[2] = a[o + 2];\n        return this;\n    }\n\n    toArray(a = [], o = 0) {\n        a[o] = this[0];\n        a[o + 1] = this[1];\n        a[o + 2] = this[2];\n        return a;\n    }\n\n    transformDirection(mat4) {\n        const x = this[0];\n        const y = this[1];\n        const z = this[2];\n\n        this[0] = mat4[0] * x + mat4[4] * y + mat4[8] * z;\n        this[1] = mat4[1] * x + mat4[5] * y + mat4[9] * z;\n        this[2] = mat4[2] * x + mat4[6] * y + mat4[10] * z;\n\n        return this.normalize();\n    }\n}\n", "// attribute params\n// {\n//     data - typed array eg UInt16Array for indices, Float32Array\n//     size - int default 1\n//     instanced - default null. Pass divisor amount\n//     type - gl enum default gl.UNSIGNED_SHORT for 'index', gl.FLOAT for others\n//     normalized - boolean default false\n\n//     buffer - gl buffer, if buffer exists, don't need to provide data - although needs position data for bounds calculation\n//     stride - default 0 - for when passing in buffer\n//     offset - default 0 - for when passing in buffer\n//     count - default null - for when passing in buffer\n//     min - array - for when passing in buffer\n//     max - array - for when passing in buffer\n// }\n\n// TODO: fit in transform feedback\n\nimport { Vec3 } from '../math/Vec3.js';\n\nconst tempVec3 = /* @__PURE__ */ new Vec3();\n\nlet ID = 1;\nlet ATTR_ID = 1;\n\n// To stop inifinite warnings\nlet isBoundsWarned = false;\n\nexport class Geometry {\n    constructor(gl, attributes = {}) {\n        if (!gl.canvas) console.error('gl not passed as first argument to Geometry');\n        this.gl = gl;\n        this.attributes = attributes;\n        this.id = ID++;\n\n        // Store one VAO per program attribute locations order\n        this.VAOs = {};\n\n        this.drawRange = { start: 0, count: 0 };\n        this.instancedCount = 0;\n\n        // Unbind current VAO so that new buffers don't get added to active mesh\n        this.gl.renderer.bindVertexArray(null);\n        this.gl.renderer.currentGeometry = null;\n\n        // Alias for state store to avoid redundant calls for global state\n        this.glState = this.gl.renderer.state;\n\n        // create the buffers\n        for (let key in attributes) {\n            this.addAttribute(key, attributes[key]);\n        }\n    }\n\n    addAttribute(key, attr) {\n        this.attributes[key] = attr;\n\n        // Set options\n        attr.id = ATTR_ID++; // TODO: currently unused, remove?\n        attr.size = attr.size || 1;\n        attr.type =\n            attr.type ||\n            (attr.data.constructor === Float32Array\n                ? this.gl.FLOAT\n                : attr.data.constructor === Uint16Array\n                ? this.gl.UNSIGNED_SHORT\n                : this.gl.UNSIGNED_INT); // Uint32Array\n        attr.target = key === 'index' ? this.gl.ELEMENT_ARRAY_BUFFER : this.gl.ARRAY_BUFFER;\n        attr.normalized = attr.normalized || false;\n        attr.stride = attr.stride || 0;\n        attr.offset = attr.offset || 0;\n        attr.count = attr.count || (attr.stride ? attr.data.byteLength / attr.stride : attr.data.length / attr.size);\n        attr.divisor = attr.instanced || 0;\n        attr.needsUpdate = false;\n        attr.usage = attr.usage || this.gl.STATIC_DRAW;\n\n        if (!attr.buffer) {\n            // Push data to buffer\n            this.updateAttribute(attr);\n        }\n\n        // Update geometry counts. If indexed, ignore regular attributes\n        if (attr.divisor) {\n            this.isInstanced = true;\n            if (this.instancedCount && this.instancedCount !== attr.count * attr.divisor) {\n                console.warn('geometry has multiple instanced buffers of different length');\n                return (this.instancedCount = Math.min(this.instancedCount, attr.count * attr.divisor));\n            }\n            this.instancedCount = attr.count * attr.divisor;\n        } else if (key === 'index') {\n            this.drawRange.count = attr.count;\n        } else if (!this.attributes.index) {\n            this.drawRange.count = Math.max(this.drawRange.count, attr.count);\n        }\n    }\n\n    updateAttribute(attr) {\n        const isNewBuffer = !attr.buffer;\n        if (isNewBuffer) attr.buffer = this.gl.createBuffer();\n        if (this.glState.boundBuffer !== attr.buffer) {\n            this.gl.bindBuffer(attr.target, attr.buffer);\n            this.glState.boundBuffer = attr.buffer;\n        }\n        if (isNewBuffer) {\n            this.gl.bufferData(attr.target, attr.data, attr.usage);\n        } else {\n            this.gl.bufferSubData(attr.target, 0, attr.data);\n        }\n        attr.needsUpdate = false;\n    }\n\n    setIndex(value) {\n        this.addAttribute('index', value);\n    }\n\n    setDrawRange(start, count) {\n        this.drawRange.start = start;\n        this.drawRange.count = count;\n    }\n\n    setInstancedCount(value) {\n        this.instancedCount = value;\n    }\n\n    createVAO(program) {\n        this.VAOs[program.attributeOrder] = this.gl.renderer.createVertexArray();\n        this.gl.renderer.bindVertexArray(this.VAOs[program.attributeOrder]);\n        this.bindAttributes(program);\n    }\n\n    bindAttributes(program) {\n        // Link all attributes to program using gl.vertexAttribPointer\n        program.attributeLocations.forEach((location, { name, type }) => {\n            // If geometry missing a required shader attribute\n            if (!this.attributes[name]) {\n                console.warn(`active attribute ${name} not being supplied`);\n                return;\n            }\n\n            const attr = this.attributes[name];\n\n            this.gl.bindBuffer(attr.target, attr.buffer);\n            this.glState.boundBuffer = attr.buffer;\n\n            // For matrix attributes, buffer needs to be defined per column\n            let numLoc = 1;\n            if (type === 35674) numLoc = 2; // mat2\n            if (type === 35675) numLoc = 3; // mat3\n            if (type === 35676) numLoc = 4; // mat4\n\n            const size = attr.size / numLoc;\n            const stride = numLoc === 1 ? 0 : numLoc * numLoc * 4;\n            const offset = numLoc === 1 ? 0 : numLoc * 4;\n\n            for (let i = 0; i < numLoc; i++) {\n                this.gl.vertexAttribPointer(location + i, size, attr.type, attr.normalized, attr.stride + stride, attr.offset + i * offset);\n                this.gl.enableVertexAttribArray(location + i);\n\n                // For instanced attributes, divisor needs to be set.\n                // For firefox, need to set back to 0 if non-instanced drawn after instanced. Else won't render\n                this.gl.renderer.vertexAttribDivisor(location + i, attr.divisor);\n            }\n        });\n\n        // Bind indices if geometry indexed\n        if (this.attributes.index) this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.attributes.index.buffer);\n    }\n\n    draw({ program, mode = this.gl.TRIANGLES }) {\n        if (this.gl.renderer.currentGeometry !== `${this.id}_${program.attributeOrder}`) {\n            if (!this.VAOs[program.attributeOrder]) this.createVAO(program);\n            this.gl.renderer.bindVertexArray(this.VAOs[program.attributeOrder]);\n            this.gl.renderer.currentGeometry = `${this.id}_${program.attributeOrder}`;\n        }\n\n        // Check if any attributes need updating\n        program.attributeLocations.forEach((location, { name }) => {\n            const attr = this.attributes[name];\n            if (attr.needsUpdate) this.updateAttribute(attr);\n        });\n\n        // For drawElements, offset needs to be multiple of type size\n        let indexBytesPerElement = 2;\n        if (this.attributes.index?.type === this.gl.UNSIGNED_INT) indexBytesPerElement = 4;\n\n        if (this.isInstanced) {\n            if (this.attributes.index) {\n                this.gl.renderer.drawElementsInstanced(\n                    mode,\n                    this.drawRange.count,\n                    this.attributes.index.type,\n                    this.attributes.index.offset + this.drawRange.start * indexBytesPerElement,\n                    this.instancedCount\n                );\n            } else {\n                this.gl.renderer.drawArraysInstanced(mode, this.drawRange.start, this.drawRange.count, this.instancedCount);\n            }\n        } else {\n            if (this.attributes.index) {\n                this.gl.drawElements(\n                    mode,\n                    this.drawRange.count,\n                    this.attributes.index.type,\n                    this.attributes.index.offset + this.drawRange.start * indexBytesPerElement\n                );\n            } else {\n                this.gl.drawArrays(mode, this.drawRange.start, this.drawRange.count);\n            }\n        }\n    }\n\n    getPosition() {\n        // Use position buffer, or min/max if available\n        const attr = this.attributes.position;\n        // if (attr.min) return [...attr.min, ...attr.max];\n        if (attr.data) return attr;\n        if (isBoundsWarned) return;\n        console.warn('No position buffer data found to compute bounds');\n        return (isBoundsWarned = true);\n    }\n\n    computeBoundingBox(attr) {\n        if (!attr) attr = this.getPosition();\n        const array = attr.data;\n        // Data loaded shouldn't haave stride, only buffers\n        // const stride = attr.stride ? attr.stride / array.BYTES_PER_ELEMENT : attr.size;\n        const stride = attr.size;\n\n        if (!this.bounds) {\n            this.bounds = {\n                min: new Vec3(),\n                max: new Vec3(),\n                center: new Vec3(),\n                scale: new Vec3(),\n                radius: Infinity,\n            };\n        }\n\n        const min = this.bounds.min;\n        const max = this.bounds.max;\n        const center = this.bounds.center;\n        const scale = this.bounds.scale;\n\n        min.set(+Infinity);\n        max.set(-Infinity);\n\n        // TODO: check size of position (eg triangle with Vec2)\n        for (let i = 0, l = array.length; i < l; i += stride) {\n            const x = array[i];\n            const y = array[i + 1];\n            const z = array[i + 2];\n\n            min.x = Math.min(x, min.x);\n            min.y = Math.min(y, min.y);\n            min.z = Math.min(z, min.z);\n\n            max.x = Math.max(x, max.x);\n            max.y = Math.max(y, max.y);\n            max.z = Math.max(z, max.z);\n        }\n\n        scale.sub(max, min);\n        center.add(min, max).divide(2);\n    }\n\n    computeBoundingSphere(attr) {\n        if (!attr) attr = this.getPosition();\n        const array = attr.data;\n        // Data loaded shouldn't haave stride, only buffers\n        // const stride = attr.stride ? attr.stride / array.BYTES_PER_ELEMENT : attr.size;\n        const stride = attr.size;\n\n        if (!this.bounds) this.computeBoundingBox(attr);\n\n        let maxRadiusSq = 0;\n        for (let i = 0, l = array.length; i < l; i += stride) {\n            tempVec3.fromArray(array, i);\n            maxRadiusSq = Math.max(maxRadiusSq, this.bounds.center.squaredDistance(tempVec3));\n        }\n\n        this.bounds.radius = Math.sqrt(maxRadiusSq);\n    }\n\n    remove() {\n        for (let key in this.VAOs) {\n            this.gl.renderer.deleteVertexArray(this.VAOs[key]);\n            delete this.VAOs[key];\n        }\n        for (let key in this.attributes) {\n            this.gl.deleteBuffer(this.attributes[key].buffer);\n            delete this.attributes[key];\n        }\n    }\n}\n", "// TODO: upload empty texture if null ? maybe not\n// TODO: upload identity matrix if null ?\n// TODO: sampler Cube\n\nlet ID = 1;\n\n// cache of typed arrays used to flatten uniform arrays\nconst arrayCacheF32 = {};\n\nexport class Program {\n    constructor(\n        gl,\n        {\n            vertex,\n            fragment,\n            uniforms = {},\n\n            transparent = false,\n            cullFace = gl.BACK,\n            frontFace = gl.CCW,\n            depthTest = true,\n            depthWrite = true,\n            depthFunc = gl.LEQUAL,\n        } = {}\n    ) {\n        if (!gl.canvas) console.error('gl not passed as first argument to Program');\n        this.gl = gl;\n        this.uniforms = uniforms;\n        this.id = ID++;\n\n        if (!vertex) console.warn('vertex shader not supplied');\n        if (!fragment) console.warn('fragment shader not supplied');\n\n        // Store program state\n        this.transparent = transparent;\n        this.cullFace = cullFace;\n        this.frontFace = frontFace;\n        this.depthTest = depthTest;\n        this.depthWrite = depthWrite;\n        this.depthFunc = depthFunc;\n        this.blendFunc = {};\n        this.blendEquation = {};\n\n        // set default blendFunc if transparent flagged\n        if (this.transparent && !this.blendFunc.src) {\n            if (this.gl.renderer.premultipliedAlpha) this.setBlendFunc(this.gl.ONE, this.gl.ONE_MINUS_SRC_ALPHA);\n            else this.setBlendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA);\n        }\n\n        // Create empty shaders and attach to program\n        this.vertexShader = gl.createShader(gl.VERTEX_SHADER);\n        this.fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);\n        this.program = gl.createProgram();\n        gl.attachShader(this.program, this.vertexShader);\n        gl.attachShader(this.program, this.fragmentShader);\n\n        // Compile shaders with source\n        this.setShaders({ vertex, fragment });\n    }\n\n    setShaders({ vertex, fragment }) {\n        if (vertex) {\n            // compile vertex shader and log errors\n            this.gl.shaderSource(this.vertexShader, vertex);\n            this.gl.compileShader(this.vertexShader);\n            if (this.gl.getShaderInfoLog(this.vertexShader) !== '') {\n                console.warn(`${this.gl.getShaderInfoLog(this.vertexShader)}\\nVertex Shader\\n${addLineNumbers(vertex)}`);\n            }\n        }\n\n        if (fragment) {\n            // compile fragment shader and log errors\n            this.gl.shaderSource(this.fragmentShader, fragment);\n            this.gl.compileShader(this.fragmentShader);\n            if (this.gl.getShaderInfoLog(this.fragmentShader) !== '') {\n                console.warn(`${this.gl.getShaderInfoLog(this.fragmentShader)}\\nFragment Shader\\n${addLineNumbers(fragment)}`);\n            }\n        }\n\n        // compile program and log errors\n        this.gl.linkProgram(this.program);\n        if (!this.gl.getProgramParameter(this.program, this.gl.LINK_STATUS)) {\n            return console.warn(this.gl.getProgramInfoLog(this.program));\n        }\n\n        // Get active uniform locations\n        this.uniformLocations = new Map();\n        let numUniforms = this.gl.getProgramParameter(this.program, this.gl.ACTIVE_UNIFORMS);\n        for (let uIndex = 0; uIndex < numUniforms; uIndex++) {\n            let uniform = this.gl.getActiveUniform(this.program, uIndex);\n            this.uniformLocations.set(uniform, this.gl.getUniformLocation(this.program, uniform.name));\n\n            // split uniforms' names to separate array and struct declarations\n            const split = uniform.name.match(/(\\w+)/g);\n\n            uniform.uniformName = split[0];\n            uniform.nameComponents = split.slice(1);\n        }\n\n        // Get active attribute locations\n        this.attributeLocations = new Map();\n        const locations = [];\n        const numAttribs = this.gl.getProgramParameter(this.program, this.gl.ACTIVE_ATTRIBUTES);\n        for (let aIndex = 0; aIndex < numAttribs; aIndex++) {\n            const attribute = this.gl.getActiveAttrib(this.program, aIndex);\n            const location = this.gl.getAttribLocation(this.program, attribute.name);\n            // Ignore special built-in inputs. eg gl_VertexID, gl_InstanceID\n            if (location === -1) continue;\n            locations[location] = attribute.name;\n            this.attributeLocations.set(attribute, location);\n        }\n        this.attributeOrder = locations.join('');\n    }\n\n    setBlendFunc(src, dst, srcAlpha, dstAlpha) {\n        this.blendFunc.src = src;\n        this.blendFunc.dst = dst;\n        this.blendFunc.srcAlpha = srcAlpha;\n        this.blendFunc.dstAlpha = dstAlpha;\n        if (src) this.transparent = true;\n    }\n\n    setBlendEquation(modeRGB, modeAlpha) {\n        this.blendEquation.modeRGB = modeRGB;\n        this.blendEquation.modeAlpha = modeAlpha;\n    }\n\n    applyState() {\n        if (this.depthTest) this.gl.renderer.enable(this.gl.DEPTH_TEST);\n        else this.gl.renderer.disable(this.gl.DEPTH_TEST);\n\n        if (this.cullFace) this.gl.renderer.enable(this.gl.CULL_FACE);\n        else this.gl.renderer.disable(this.gl.CULL_FACE);\n\n        if (this.blendFunc.src) this.gl.renderer.enable(this.gl.BLEND);\n        else this.gl.renderer.disable(this.gl.BLEND);\n\n        if (this.cullFace) this.gl.renderer.setCullFace(this.cullFace);\n        this.gl.renderer.setFrontFace(this.frontFace);\n        this.gl.renderer.setDepthMask(this.depthWrite);\n        this.gl.renderer.setDepthFunc(this.depthFunc);\n        if (this.blendFunc.src) this.gl.renderer.setBlendFunc(this.blendFunc.src, this.blendFunc.dst, this.blendFunc.srcAlpha, this.blendFunc.dstAlpha);\n        this.gl.renderer.setBlendEquation(this.blendEquation.modeRGB, this.blendEquation.modeAlpha);\n    }\n\n    use({ flipFaces = false } = {}) {\n        let textureUnit = -1;\n        const programActive = this.gl.renderer.state.currentProgram === this.id;\n\n        // Avoid gl call if program already in use\n        if (!programActive) {\n            this.gl.useProgram(this.program);\n            this.gl.renderer.state.currentProgram = this.id;\n        }\n\n        // Set only the active uniforms found in the shader\n        this.uniformLocations.forEach((location, activeUniform) => {\n            let uniform = this.uniforms[activeUniform.uniformName];\n\n            for (const component of activeUniform.nameComponents) {\n                if (!uniform) break;\n\n                if (component in uniform) {\n                    uniform = uniform[component];\n                } else if (Array.isArray(uniform.value)) {\n                    break;\n                } else {\n                    uniform = undefined;\n                    break;\n                }\n            }\n\n            if (!uniform) {\n                return warn(`Active uniform ${activeUniform.name} has not been supplied`);\n            }\n\n            if (uniform && uniform.value === undefined) {\n                return warn(`${activeUniform.name} uniform is missing a value parameter`);\n            }\n\n            if (uniform.value.texture) {\n                textureUnit = textureUnit + 1;\n\n                // Check if texture needs to be updated\n                uniform.value.update(textureUnit);\n                return setUniform(this.gl, activeUniform.type, location, textureUnit);\n            }\n\n            // For texture arrays, set uniform as an array of texture units instead of just one\n            if (uniform.value.length && uniform.value[0].texture) {\n                const textureUnits = [];\n                uniform.value.forEach((value) => {\n                    textureUnit = textureUnit + 1;\n                    value.update(textureUnit);\n                    textureUnits.push(textureUnit);\n                });\n\n                return setUniform(this.gl, activeUniform.type, location, textureUnits);\n            }\n\n            setUniform(this.gl, activeUniform.type, location, uniform.value);\n        });\n\n        this.applyState();\n        if (flipFaces) this.gl.renderer.setFrontFace(this.frontFace === this.gl.CCW ? this.gl.CW : this.gl.CCW);\n    }\n\n    remove() {\n        this.gl.deleteProgram(this.program);\n    }\n}\n\nfunction setUniform(gl, type, location, value) {\n    value = value.length ? flatten(value) : value;\n    const setValue = gl.renderer.state.uniformLocations.get(location);\n\n    // Avoid redundant uniform commands\n    if (value.length) {\n        if (setValue === undefined || setValue.length !== value.length) {\n            // clone array to store as cache\n            gl.renderer.state.uniformLocations.set(location, value.slice(0));\n        } else {\n            if (arraysEqual(setValue, value)) return;\n\n            // Update cached array values\n            setValue.set ? setValue.set(value) : setArray(setValue, value);\n            gl.renderer.state.uniformLocations.set(location, setValue);\n        }\n    } else {\n        if (setValue === value) return;\n        gl.renderer.state.uniformLocations.set(location, value);\n    }\n\n    switch (type) {\n        case 5126:\n            return value.length ? gl.uniform1fv(location, value) : gl.uniform1f(location, value); // FLOAT\n        case 35664:\n            return gl.uniform2fv(location, value); // FLOAT_VEC2\n        case 35665:\n            return gl.uniform3fv(location, value); // FLOAT_VEC3\n        case 35666:\n            return gl.uniform4fv(location, value); // FLOAT_VEC4\n        case 35670: // BOOL\n        case 5124: // INT\n        case 35678: // SAMPLER_2D\n        case 36306: // U_SAMPLER_2D\n        case 35680: // SAMPLER_CUBE\n        case 36289: // SAMPLER_2D_ARRAY\n            return value.length ? gl.uniform1iv(location, value) : gl.uniform1i(location, value); // SAMPLER_CUBE\n        case 35671: // BOOL_VEC2\n        case 35667:\n            return gl.uniform2iv(location, value); // INT_VEC2\n        case 35672: // BOOL_VEC3\n        case 35668:\n            return gl.uniform3iv(location, value); // INT_VEC3\n        case 35673: // BOOL_VEC4\n        case 35669:\n            return gl.uniform4iv(location, value); // INT_VEC4\n        case 35674:\n            return gl.uniformMatrix2fv(location, false, value); // FLOAT_MAT2\n        case 35675:\n            return gl.uniformMatrix3fv(location, false, value); // FLOAT_MAT3\n        case 35676:\n            return gl.uniformMatrix4fv(location, false, value); // FLOAT_MAT4\n    }\n}\n\nfunction addLineNumbers(string) {\n    let lines = string.split('\\n');\n    for (let i = 0; i < lines.length; i++) {\n        lines[i] = i + 1 + ': ' + lines[i];\n    }\n    return lines.join('\\n');\n}\n\nfunction flatten(a) {\n    const arrayLen = a.length;\n    const valueLen = a[0].length;\n    if (valueLen === undefined) return a;\n    const length = arrayLen * valueLen;\n    let value = arrayCacheF32[length];\n    if (!value) arrayCacheF32[length] = value = new Float32Array(length);\n    for (let i = 0; i < arrayLen; i++) value.set(a[i], i * valueLen);\n    return value;\n}\n\nfunction arraysEqual(a, b) {\n    if (a.length !== b.length) return false;\n    for (let i = 0, l = a.length; i < l; i++) {\n        if (a[i] !== b[i]) return false;\n    }\n    return true;\n}\n\nfunction setArray(a, b) {\n    for (let i = 0, l = a.length; i < l; i++) {\n        a[i] = b[i];\n    }\n}\n\nlet warnCount = 0;\nfunction warn(message) {\n    if (warnCount > 100) return;\n    console.warn(message);\n    warnCount++;\n    if (warnCount > 100) console.warn('More than 100 program warnings - stopping logs.');\n}\n", "import { Vec3 } from '../math/Vec3.js';\n\n// TODO: Handle context loss https://www.khronos.org/webgl/wiki/HandlingContextLost\n\n// Not automatic - devs to use these methods manually\n// gl.colorMask( colorMask, colorMask, colorMask, colorMask );\n// gl.clearColor( r, g, b, a );\n// gl.stencilMask( stencilMask );\n// gl.stencilFunc( stencilFunc, stencilRef, stencilMask );\n// gl.stencilOp( stencilFail, stencilZFail, stencilZPass );\n// gl.clearStencil( stencil );\n\nconst tempVec3 = /* @__PURE__ */ new Vec3();\nlet ID = 1;\n\nexport class Renderer {\n    constructor({\n        canvas = document.createElement('canvas'),\n        width = 300,\n        height = 150,\n        dpr = 1,\n        alpha = false,\n        depth = true,\n        stencil = false,\n        antialias = false,\n        premultipliedAlpha = false,\n        preserveDrawingBuffer = false,\n        powerPreference = 'default',\n        autoClear = true,\n        webgl = 2,\n    } = {}) {\n        const attributes = { alpha, depth, stencil, antialias, premultipliedAlpha, preserveDrawingBuffer, powerPreference };\n        this.dpr = dpr;\n        this.alpha = alpha;\n        this.color = true;\n        this.depth = depth;\n        this.stencil = stencil;\n        this.premultipliedAlpha = premultipliedAlpha;\n        this.autoClear = autoClear;\n        this.id = ID++;\n\n        // Attempt WebGL2 unless forced to 1, if not supported fallback to WebGL1\n        if (webgl === 2) this.gl = canvas.getContext('webgl2', attributes);\n        this.isWebgl2 = !!this.gl;\n        if (!this.gl) this.gl = canvas.getContext('webgl', attributes);\n        if (!this.gl) console.error('unable to create webgl context');\n\n        // Attach renderer to gl so that all classes have access to internal state functions\n        this.gl.renderer = this;\n\n        // initialise size values\n        this.setSize(width, height);\n\n        // gl state stores to avoid redundant calls on methods used internally\n        this.state = {};\n        this.state.blendFunc = { src: this.gl.ONE, dst: this.gl.ZERO };\n        this.state.blendEquation = { modeRGB: this.gl.FUNC_ADD };\n        this.state.cullFace = false;\n        this.state.frontFace = this.gl.CCW;\n        this.state.depthMask = true;\n        this.state.depthFunc = this.gl.LEQUAL;\n        this.state.premultiplyAlpha = false;\n        this.state.flipY = false;\n        this.state.unpackAlignment = 4;\n        this.state.framebuffer = null;\n        this.state.viewport = { x: 0, y: 0, width: null, height: null };\n        this.state.textureUnits = [];\n        this.state.activeTextureUnit = 0;\n        this.state.boundBuffer = null;\n        this.state.uniformLocations = new Map();\n        this.state.currentProgram = null;\n\n        // store requested extensions\n        this.extensions = {};\n\n        // Initialise extra format types\n        if (this.isWebgl2) {\n            this.getExtension('EXT_color_buffer_float');\n            this.getExtension('OES_texture_float_linear');\n        } else {\n            this.getExtension('OES_texture_float');\n            this.getExtension('OES_texture_float_linear');\n            this.getExtension('OES_texture_half_float');\n            this.getExtension('OES_texture_half_float_linear');\n            this.getExtension('OES_element_index_uint');\n            this.getExtension('OES_standard_derivatives');\n            this.getExtension('EXT_sRGB');\n            this.getExtension('WEBGL_depth_texture');\n            this.getExtension('WEBGL_draw_buffers');\n        }\n        this.getExtension('WEBGL_compressed_texture_astc');\n        this.getExtension('EXT_texture_compression_bptc');\n        this.getExtension('WEBGL_compressed_texture_s3tc');\n        this.getExtension('WEBGL_compressed_texture_etc1');\n        this.getExtension('WEBGL_compressed_texture_pvrtc');\n        this.getExtension('WEBKIT_WEBGL_compressed_texture_pvrtc');\n\n        // Create method aliases using extension (WebGL1) or native if available (WebGL2)\n        this.vertexAttribDivisor = this.getExtension('ANGLE_instanced_arrays', 'vertexAttribDivisor', 'vertexAttribDivisorANGLE');\n        this.drawArraysInstanced = this.getExtension('ANGLE_instanced_arrays', 'drawArraysInstanced', 'drawArraysInstancedANGLE');\n        this.drawElementsInstanced = this.getExtension('ANGLE_instanced_arrays', 'drawElementsInstanced', 'drawElementsInstancedANGLE');\n        this.createVertexArray = this.getExtension('OES_vertex_array_object', 'createVertexArray', 'createVertexArrayOES');\n        this.bindVertexArray = this.getExtension('OES_vertex_array_object', 'bindVertexArray', 'bindVertexArrayOES');\n        this.deleteVertexArray = this.getExtension('OES_vertex_array_object', 'deleteVertexArray', 'deleteVertexArrayOES');\n        this.drawBuffers = this.getExtension('WEBGL_draw_buffers', 'drawBuffers', 'drawBuffersWEBGL');\n\n        // Store device parameters\n        this.parameters = {};\n        this.parameters.maxTextureUnits = this.gl.getParameter(this.gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS);\n        this.parameters.maxAnisotropy = this.getExtension('EXT_texture_filter_anisotropic')\n            ? this.gl.getParameter(this.getExtension('EXT_texture_filter_anisotropic').MAX_TEXTURE_MAX_ANISOTROPY_EXT)\n            : 0;\n    }\n\n    setSize(width, height) {\n        this.width = width;\n        this.height = height;\n\n        this.gl.canvas.width = width * this.dpr;\n        this.gl.canvas.height = height * this.dpr;\n\n        if (!this.gl.canvas.style) return;\n        Object.assign(this.gl.canvas.style, {\n            width: width + 'px',\n            height: height + 'px',\n        });\n    }\n\n    setViewport(width, height, x = 0, y = 0) {\n        if (this.state.viewport.width === width && this.state.viewport.height === height) return;\n        this.state.viewport.width = width;\n        this.state.viewport.height = height;\n        this.state.viewport.x = x;\n        this.state.viewport.y = y;\n        this.gl.viewport(x, y, width, height);\n    }\n\n    setScissor(width, height, x = 0, y = 0) {\n        this.gl.scissor(x, y, width, height);\n    }\n\n    enable(id) {\n        if (this.state[id] === true) return;\n        this.gl.enable(id);\n        this.state[id] = true;\n    }\n\n    disable(id) {\n        if (this.state[id] === false) return;\n        this.gl.disable(id);\n        this.state[id] = false;\n    }\n\n    setBlendFunc(src, dst, srcAlpha, dstAlpha) {\n        if (\n            this.state.blendFunc.src === src &&\n            this.state.blendFunc.dst === dst &&\n            this.state.blendFunc.srcAlpha === srcAlpha &&\n            this.state.blendFunc.dstAlpha === dstAlpha\n        )\n            return;\n        this.state.blendFunc.src = src;\n        this.state.blendFunc.dst = dst;\n        this.state.blendFunc.srcAlpha = srcAlpha;\n        this.state.blendFunc.dstAlpha = dstAlpha;\n        if (srcAlpha !== undefined) this.gl.blendFuncSeparate(src, dst, srcAlpha, dstAlpha);\n        else this.gl.blendFunc(src, dst);\n    }\n\n    setBlendEquation(modeRGB, modeAlpha) {\n        modeRGB = modeRGB || this.gl.FUNC_ADD;\n        if (this.state.blendEquation.modeRGB === modeRGB && this.state.blendEquation.modeAlpha === modeAlpha) return;\n        this.state.blendEquation.modeRGB = modeRGB;\n        this.state.blendEquation.modeAlpha = modeAlpha;\n        if (modeAlpha !== undefined) this.gl.blendEquationSeparate(modeRGB, modeAlpha);\n        else this.gl.blendEquation(modeRGB);\n    }\n\n    setCullFace(value) {\n        if (this.state.cullFace === value) return;\n        this.state.cullFace = value;\n        this.gl.cullFace(value);\n    }\n\n    setFrontFace(value) {\n        if (this.state.frontFace === value) return;\n        this.state.frontFace = value;\n        this.gl.frontFace(value);\n    }\n\n    setDepthMask(value) {\n        if (this.state.depthMask === value) return;\n        this.state.depthMask = value;\n        this.gl.depthMask(value);\n    }\n\n    setDepthFunc(value) {\n        if (this.state.depthFunc === value) return;\n        this.state.depthFunc = value;\n        this.gl.depthFunc(value);\n    }\n\n    activeTexture(value) {\n        if (this.state.activeTextureUnit === value) return;\n        this.state.activeTextureUnit = value;\n        this.gl.activeTexture(this.gl.TEXTURE0 + value);\n    }\n\n    bindFramebuffer({ target = this.gl.FRAMEBUFFER, buffer = null } = {}) {\n        if (this.state.framebuffer === buffer) return;\n        this.state.framebuffer = buffer;\n        this.gl.bindFramebuffer(target, buffer);\n    }\n\n    getExtension(extension, webgl2Func, extFunc) {\n        // if webgl2 function supported, return func bound to gl context\n        if (webgl2Func && this.gl[webgl2Func]) return this.gl[webgl2Func].bind(this.gl);\n\n        // fetch extension once only\n        if (!this.extensions[extension]) {\n            this.extensions[extension] = this.gl.getExtension(extension);\n        }\n\n        // return extension if no function requested\n        if (!webgl2Func) return this.extensions[extension];\n\n        // Return null if extension not supported\n        if (!this.extensions[extension]) return null;\n\n        // return extension function, bound to extension\n        return this.extensions[extension][extFunc].bind(this.extensions[extension]);\n    }\n\n    sortOpaque(a, b) {\n        if (a.renderOrder !== b.renderOrder) {\n            return a.renderOrder - b.renderOrder;\n        } else if (a.program.id !== b.program.id) {\n            return a.program.id - b.program.id;\n        } else if (a.zDepth !== b.zDepth) {\n            return a.zDepth - b.zDepth;\n        } else {\n            return b.id - a.id;\n        }\n    }\n\n    sortTransparent(a, b) {\n        if (a.renderOrder !== b.renderOrder) {\n            return a.renderOrder - b.renderOrder;\n        }\n        if (a.zDepth !== b.zDepth) {\n            return b.zDepth - a.zDepth;\n        } else {\n            return b.id - a.id;\n        }\n    }\n\n    sortUI(a, b) {\n        if (a.renderOrder !== b.renderOrder) {\n            return a.renderOrder - b.renderOrder;\n        } else if (a.program.id !== b.program.id) {\n            return a.program.id - b.program.id;\n        } else {\n            return b.id - a.id;\n        }\n    }\n\n    getRenderList({ scene, camera, frustumCull, sort }) {\n        let renderList = [];\n\n        if (camera && frustumCull) camera.updateFrustum();\n\n        // Get visible\n        scene.traverse((node) => {\n            if (!node.visible) return true;\n            if (!node.draw) return;\n\n            if (frustumCull && node.frustumCulled && camera) {\n                if (!camera.frustumIntersectsMesh(node)) return;\n            }\n\n            renderList.push(node);\n        });\n\n        if (sort) {\n            const opaque = [];\n            const transparent = []; // depthTest true\n            const ui = []; // depthTest false\n\n            renderList.forEach((node) => {\n                // Split into the 3 render groups\n                if (!node.program.transparent) {\n                    opaque.push(node);\n                } else if (node.program.depthTest) {\n                    transparent.push(node);\n                } else {\n                    ui.push(node);\n                }\n\n                node.zDepth = 0;\n\n                // Only calculate z-depth if renderOrder unset and depthTest is true\n                if (node.renderOrder !== 0 || !node.program.depthTest || !camera) return;\n\n                // update z-depth\n                node.worldMatrix.getTranslation(tempVec3);\n                tempVec3.applyMatrix4(camera.projectionViewMatrix);\n                node.zDepth = tempVec3.z;\n            });\n\n            opaque.sort(this.sortOpaque);\n            transparent.sort(this.sortTransparent);\n            ui.sort(this.sortUI);\n\n            renderList = opaque.concat(transparent, ui);\n        }\n\n        return renderList;\n    }\n\n    render({ scene, camera, target = null, update = true, sort = true, frustumCull = true, clear }) {\n        if (target === null) {\n            // make sure no render target bound so draws to canvas\n            this.bindFramebuffer();\n            this.setViewport(this.width * this.dpr, this.height * this.dpr);\n        } else {\n            // bind supplied render target and update viewport\n            this.bindFramebuffer(target);\n            this.setViewport(target.width, target.height);\n        }\n\n        if (clear || (this.autoClear && clear !== false)) {\n            // Ensure depth buffer writing is enabled so it can be cleared\n            if (this.depth && (!target || target.depth)) {\n                this.enable(this.gl.DEPTH_TEST);\n                this.setDepthMask(true);\n            }\n            this.gl.clear(\n                (this.color ? this.gl.COLOR_BUFFER_BIT : 0) |\n                    (this.depth ? this.gl.DEPTH_BUFFER_BIT : 0) |\n                    (this.stencil ? this.gl.STENCIL_BUFFER_BIT : 0)\n            );\n        }\n\n        // updates all scene graph matrices\n        if (update) scene.updateMatrixWorld();\n\n        // Update camera separately, in case not in scene graph\n        if (camera) camera.updateMatrixWorld();\n\n        // Get render list - entails culling and sorting\n        const renderList = this.getRenderList({ scene, camera, frustumCull, sort });\n\n        renderList.forEach((node) => {\n            node.draw({ camera });\n        });\n    }\n}\n", "const EPSILON = 0.000001;\n\n/**\n * Copy the values from one vec4 to another\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a the source vector\n * @returns {vec4} out\n */\nexport function copy(out, a) {\n    out[0] = a[0];\n    out[1] = a[1];\n    out[2] = a[2];\n    out[3] = a[3];\n    return out;\n}\n\n/**\n * Set the components of a vec4 to the given values\n *\n * @param {vec4} out the receiving vector\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @param {Number} w W component\n * @returns {vec4} out\n */\nexport function set(out, x, y, z, w) {\n    out[0] = x;\n    out[1] = y;\n    out[2] = z;\n    out[3] = w;\n    return out;\n}\n\n/**\n * Adds two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a the first operand\n * @param {vec4} b the second operand\n * @returns {vec4} out\n */\nexport function add(out, a, b) {\n    out[0] = a[0] + b[0];\n    out[1] = a[1] + b[1];\n    out[2] = a[2] + b[2];\n    out[3] = a[3] + b[3];\n    return out;\n}\n\n/**\n * Scales a vec4 by a scalar number\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @returns {vec4} out\n */\nexport function scale(out, a, b) {\n    out[0] = a[0] * b;\n    out[1] = a[1] * b;\n    out[2] = a[2] * b;\n    out[3] = a[3] * b;\n    return out;\n}\n\n/**\n * Calculates the length of a vec4\n *\n * @param {vec4} a vector to calculate length of\n * @returns {Number} length of a\n */\nexport function length(a) {\n    let x = a[0];\n    let y = a[1];\n    let z = a[2];\n    let w = a[3];\n    return Math.sqrt(x * x + y * y + z * z + w * w);\n}\n\n/**\n * Normalize a vec4\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a vector to normalize\n * @returns {vec4} out\n */\nexport function normalize(out, a) {\n    let x = a[0];\n    let y = a[1];\n    let z = a[2];\n    let w = a[3];\n    let len = x * x + y * y + z * z + w * w;\n    if (len > 0) {\n        len = 1 / Math.sqrt(len);\n    }\n    out[0] = x * len;\n    out[1] = y * len;\n    out[2] = z * len;\n    out[3] = w * len;\n    return out;\n}\n\n/**\n * Calculates the dot product of two vec4's\n *\n * @param {vec4} a the first operand\n * @param {vec4} b the second operand\n * @returns {Number} dot product of a and b\n */\nexport function dot(a, b) {\n    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];\n}\n\n/**\n * Performs a linear interpolation between two vec4's\n *\n * @param {vec4} out the receiving vector\n * @param {vec4} a the first operand\n * @param {vec4} b the second operand\n * @param {Number} t interpolation amount between the two inputs\n * @returns {vec4} out\n */\nexport function lerp(out, a, b, t) {\n    let ax = a[0];\n    let ay = a[1];\n    let az = a[2];\n    let aw = a[3];\n    out[0] = ax + t * (b[0] - ax);\n    out[1] = ay + t * (b[1] - ay);\n    out[2] = az + t * (b[2] - az);\n    out[3] = aw + t * (b[3] - aw);\n    return out;\n}\n", "import * as vec4 from './Vec4Func.js';\n\n/**\n * Set a quat to the identity quaternion\n *\n * @param {quat} out the receiving quaternion\n * @returns {quat} out\n */\nexport function identity(out) {\n    out[0] = 0;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 1;\n    return out;\n}\n\n/**\n * Sets a quat from the given angle and rotation axis,\n * then returns it.\n *\n * @param {quat} out the receiving quaternion\n * @param {vec3} axis the axis around which to rotate\n * @param {Number} rad the angle in radians\n * @returns {quat} out\n **/\nexport function setAxisAngle(out, axis, rad) {\n    rad = rad * 0.5;\n    let s = Math.sin(rad);\n    out[0] = s * axis[0];\n    out[1] = s * axis[1];\n    out[2] = s * axis[2];\n    out[3] = Math.cos(rad);\n    return out;\n}\n\n/**\n * Multiplies two quats\n *\n * @param {quat} out the receiving quaternion\n * @param {quat} a the first operand\n * @param {quat} b the second operand\n * @returns {quat} out\n */\nexport function multiply(out, a, b) {\n    let ax = a[0],\n        ay = a[1],\n        az = a[2],\n        aw = a[3];\n    let bx = b[0],\n        by = b[1],\n        bz = b[2],\n        bw = b[3];\n\n    out[0] = ax * bw + aw * bx + ay * bz - az * by;\n    out[1] = ay * bw + aw * by + az * bx - ax * bz;\n    out[2] = az * bw + aw * bz + ax * by - ay * bx;\n    out[3] = aw * bw - ax * bx - ay * by - az * bz;\n    return out;\n}\n\n/**\n * Rotates a quaternion by the given angle about the X axis\n *\n * @param {quat} out quat receiving operation result\n * @param {quat} a quat to rotate\n * @param {number} rad angle (in radians) to rotate\n * @returns {quat} out\n */\nexport function rotateX(out, a, rad) {\n    rad *= 0.5;\n\n    let ax = a[0],\n        ay = a[1],\n        az = a[2],\n        aw = a[3];\n    let bx = Math.sin(rad),\n        bw = Math.cos(rad);\n\n    out[0] = ax * bw + aw * bx;\n    out[1] = ay * bw + az * bx;\n    out[2] = az * bw - ay * bx;\n    out[3] = aw * bw - ax * bx;\n    return out;\n}\n\n/**\n * Rotates a quaternion by the given angle about the Y axis\n *\n * @param {quat} out quat receiving operation result\n * @param {quat} a quat to rotate\n * @param {number} rad angle (in radians) to rotate\n * @returns {quat} out\n */\nexport function rotateY(out, a, rad) {\n    rad *= 0.5;\n\n    let ax = a[0],\n        ay = a[1],\n        az = a[2],\n        aw = a[3];\n    let by = Math.sin(rad),\n        bw = Math.cos(rad);\n\n    out[0] = ax * bw - az * by;\n    out[1] = ay * bw + aw * by;\n    out[2] = az * bw + ax * by;\n    out[3] = aw * bw - ay * by;\n    return out;\n}\n\n/**\n * Rotates a quaternion by the given angle about the Z axis\n *\n * @param {quat} out quat receiving operation result\n * @param {quat} a quat to rotate\n * @param {number} rad angle (in radians) to rotate\n * @returns {quat} out\n */\nexport function rotateZ(out, a, rad) {\n    rad *= 0.5;\n\n    let ax = a[0],\n        ay = a[1],\n        az = a[2],\n        aw = a[3];\n    let bz = Math.sin(rad),\n        bw = Math.cos(rad);\n\n    out[0] = ax * bw + ay * bz;\n    out[1] = ay * bw - ax * bz;\n    out[2] = az * bw + aw * bz;\n    out[3] = aw * bw - az * bz;\n    return out;\n}\n\n/**\n * Performs a spherical linear interpolation between two quat\n *\n * @param {quat} out the receiving quaternion\n * @param {quat} a the first operand\n * @param {quat} b the second operand\n * @param {Number} t interpolation amount between the two inputs\n * @returns {quat} out\n */\nexport function slerp(out, a, b, t) {\n    // benchmarks:\n    //    http://jsperf.com/quaternion-slerp-implementations\n    let ax = a[0],\n        ay = a[1],\n        az = a[2],\n        aw = a[3];\n    let bx = b[0],\n        by = b[1],\n        bz = b[2],\n        bw = b[3];\n\n    let omega, cosom, sinom, scale0, scale1;\n\n    // calc cosine\n    cosom = ax * bx + ay * by + az * bz + aw * bw;\n    // adjust signs (if necessary)\n    if (cosom < 0.0) {\n        cosom = -cosom;\n        bx = -bx;\n        by = -by;\n        bz = -bz;\n        bw = -bw;\n    }\n    // calculate coefficients\n    if (1.0 - cosom > 0.000001) {\n        // standard case (slerp)\n        omega = Math.acos(cosom);\n        sinom = Math.sin(omega);\n        scale0 = Math.sin((1.0 - t) * omega) / sinom;\n        scale1 = Math.sin(t * omega) / sinom;\n    } else {\n        // \"from\" and \"to\" quaternions are very close\n        //  ... so we can do a linear interpolation\n        scale0 = 1.0 - t;\n        scale1 = t;\n    }\n    // calculate final values\n    out[0] = scale0 * ax + scale1 * bx;\n    out[1] = scale0 * ay + scale1 * by;\n    out[2] = scale0 * az + scale1 * bz;\n    out[3] = scale0 * aw + scale1 * bw;\n\n    return out;\n}\n\n/**\n * Calculates the inverse of a quat\n *\n * @param {quat} out the receiving quaternion\n * @param {quat} a quat to calculate inverse of\n * @returns {quat} out\n */\nexport function invert(out, a) {\n    let a0 = a[0],\n        a1 = a[1],\n        a2 = a[2],\n        a3 = a[3];\n    let dot = a0 * a0 + a1 * a1 + a2 * a2 + a3 * a3;\n    let invDot = dot ? 1.0 / dot : 0;\n\n    // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0\n\n    out[0] = -a0 * invDot;\n    out[1] = -a1 * invDot;\n    out[2] = -a2 * invDot;\n    out[3] = a3 * invDot;\n    return out;\n}\n\n/**\n * Calculates the conjugate of a quat\n * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.\n *\n * @param {quat} out the receiving quaternion\n * @param {quat} a quat to calculate conjugate of\n * @returns {quat} out\n */\nexport function conjugate(out, a) {\n    out[0] = -a[0];\n    out[1] = -a[1];\n    out[2] = -a[2];\n    out[3] = a[3];\n    return out;\n}\n\n/**\n * Creates a quaternion from the given 3x3 rotation matrix.\n *\n * NOTE: The resultant quaternion is not normalized, so you should be sure\n * to renormalize the quaternion yourself where necessary.\n *\n * @param {quat} out the receiving quaternion\n * @param {mat3} m rotation matrix\n * @returns {quat} out\n * @function\n */\nexport function fromMat3(out, m) {\n    // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes\n    // article \"Quaternion Calculus and Fast Animation\".\n    let fTrace = m[0] + m[4] + m[8];\n    let fRoot;\n\n    if (fTrace > 0.0) {\n        // |w| > 1/2, may as well choose w > 1/2\n        fRoot = Math.sqrt(fTrace + 1.0); // 2w\n        out[3] = 0.5 * fRoot;\n        fRoot = 0.5 / fRoot; // 1/(4w)\n        out[0] = (m[5] - m[7]) * fRoot;\n        out[1] = (m[6] - m[2]) * fRoot;\n        out[2] = (m[1] - m[3]) * fRoot;\n    } else {\n        // |w| <= 1/2\n        let i = 0;\n        if (m[4] > m[0]) i = 1;\n        if (m[8] > m[i * 3 + i]) i = 2;\n        let j = (i + 1) % 3;\n        let k = (i + 2) % 3;\n\n        fRoot = Math.sqrt(m[i * 3 + i] - m[j * 3 + j] - m[k * 3 + k] + 1.0);\n        out[i] = 0.5 * fRoot;\n        fRoot = 0.5 / fRoot;\n        out[3] = (m[j * 3 + k] - m[k * 3 + j]) * fRoot;\n        out[j] = (m[j * 3 + i] + m[i * 3 + j]) * fRoot;\n        out[k] = (m[k * 3 + i] + m[i * 3 + k]) * fRoot;\n    }\n\n    return out;\n}\n\n/**\n * Creates a quaternion from the given euler angle x, y, z.\n *\n * @param {quat} out the receiving quaternion\n * @param {vec3} euler Angles to rotate around each axis in degrees.\n * @param {String} order detailing order of operations. Default 'XYZ'.\n * @returns {quat} out\n * @function\n */\nexport function fromEuler(out, euler, order = 'YXZ') {\n    let sx = Math.sin(euler[0] * 0.5);\n    let cx = Math.cos(euler[0] * 0.5);\n    let sy = Math.sin(euler[1] * 0.5);\n    let cy = Math.cos(euler[1] * 0.5);\n    let sz = Math.sin(euler[2] * 0.5);\n    let cz = Math.cos(euler[2] * 0.5);\n\n    if (order === 'XYZ') {\n        out[0] = sx * cy * cz + cx * sy * sz;\n        out[1] = cx * sy * cz - sx * cy * sz;\n        out[2] = cx * cy * sz + sx * sy * cz;\n        out[3] = cx * cy * cz - sx * sy * sz;\n    } else if (order === 'YXZ') {\n        out[0] = sx * cy * cz + cx * sy * sz;\n        out[1] = cx * sy * cz - sx * cy * sz;\n        out[2] = cx * cy * sz - sx * sy * cz;\n        out[3] = cx * cy * cz + sx * sy * sz;\n    } else if (order === 'ZXY') {\n        out[0] = sx * cy * cz - cx * sy * sz;\n        out[1] = cx * sy * cz + sx * cy * sz;\n        out[2] = cx * cy * sz + sx * sy * cz;\n        out[3] = cx * cy * cz - sx * sy * sz;\n    } else if (order === 'ZYX') {\n        out[0] = sx * cy * cz - cx * sy * sz;\n        out[1] = cx * sy * cz + sx * cy * sz;\n        out[2] = cx * cy * sz - sx * sy * cz;\n        out[3] = cx * cy * cz + sx * sy * sz;\n    } else if (order === 'YZX') {\n        out[0] = sx * cy * cz + cx * sy * sz;\n        out[1] = cx * sy * cz + sx * cy * sz;\n        out[2] = cx * cy * sz - sx * sy * cz;\n        out[3] = cx * cy * cz - sx * sy * sz;\n    } else if (order === 'XZY') {\n        out[0] = sx * cy * cz - cx * sy * sz;\n        out[1] = cx * sy * cz - sx * cy * sz;\n        out[2] = cx * cy * sz + sx * sy * cz;\n        out[3] = cx * cy * cz + sx * sy * sz;\n    }\n\n    return out;\n}\n\n/**\n * Copy the values from one quat to another\n *\n * @param {quat} out the receiving quaternion\n * @param {quat} a the source quaternion\n * @returns {quat} out\n * @function\n */\nexport const copy = vec4.copy;\n\n/**\n * Set the components of a quat to the given values\n *\n * @param {quat} out the receiving quaternion\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @param {Number} w W component\n * @returns {quat} out\n * @function\n */\nexport const set = vec4.set;\n\n/**\n * Adds two quat's\n *\n * @param {quat} out the receiving quaternion\n * @param {quat} a the first operand\n * @param {quat} b the second operand\n * @returns {quat} out\n * @function\n */\nexport const add = vec4.add;\n\n/**\n * Scales a quat by a scalar number\n *\n * @param {quat} out the receiving vector\n * @param {quat} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @returns {quat} out\n * @function\n */\nexport const scale = vec4.scale;\n\n/**\n * Calculates the dot product of two quat's\n *\n * @param {quat} a the first operand\n * @param {quat} b the second operand\n * @returns {Number} dot product of a and b\n * @function\n */\nexport const dot = vec4.dot;\n\n/**\n * Performs a linear interpolation between two quat's\n *\n * @param {quat} out the receiving quaternion\n * @param {quat} a the first operand\n * @param {quat} b the second operand\n * @param {Number} t interpolation amount between the two inputs\n * @returns {quat} out\n * @function\n */\nexport const lerp = vec4.lerp;\n\n/**\n * Calculates the length of a quat\n *\n * @param {quat} a vector to calculate length of\n * @returns {Number} length of a\n */\nexport const length = vec4.length;\n\n/**\n * Normalize a quat\n *\n * @param {quat} out the receiving quaternion\n * @param {quat} a quaternion to normalize\n * @returns {quat} out\n * @function\n */\nexport const normalize = vec4.normalize;\n", "import * as QuatFunc from './functions/QuatFunc.js';\n\nexport class Quat extends Array {\n    constructor(x = 0, y = 0, z = 0, w = 1) {\n        super(x, y, z, w);\n        this.onChange = () => {};\n\n        // Keep reference to proxy target to avoid triggering onChange internally\n        this._target = this;\n\n        // Return a proxy to trigger onChange when array elements are edited directly\n        const triggerProps = ['0', '1', '2', '3'];\n        return new Proxy(this, {\n            set(target, property) {\n                const success = Reflect.set(...arguments);\n                if (success && triggerProps.includes(property)) target.onChange();\n                return success;\n            },\n        });\n    }\n\n    get x() {\n        return this[0];\n    }\n\n    get y() {\n        return this[1];\n    }\n\n    get z() {\n        return this[2];\n    }\n\n    get w() {\n        return this[3];\n    }\n\n    set x(v) {\n        this._target[0] = v;\n        this.onChange();\n    }\n\n    set y(v) {\n        this._target[1] = v;\n        this.onChange();\n    }\n\n    set z(v) {\n        this._target[2] = v;\n        this.onChange();\n    }\n\n    set w(v) {\n        this._target[3] = v;\n        this.onChange();\n    }\n\n    identity() {\n        QuatFunc.identity(this._target);\n        this.onChange();\n        return this;\n    }\n\n    set(x, y, z, w) {\n        if (x.length) return this.copy(x);\n        QuatFunc.set(this._target, x, y, z, w);\n        this.onChange();\n        return this;\n    }\n\n    rotateX(a) {\n        QuatFunc.rotateX(this._target, this._target, a);\n        this.onChange();\n        return this;\n    }\n\n    rotateY(a) {\n        QuatFunc.rotateY(this._target, this._target, a);\n        this.onChange();\n        return this;\n    }\n\n    rotateZ(a) {\n        QuatFunc.rotateZ(this._target, this._target, a);\n        this.onChange();\n        return this;\n    }\n\n    inverse(q = this._target) {\n        QuatFunc.invert(this._target, q);\n        this.onChange();\n        return this;\n    }\n\n    conjugate(q = this._target) {\n        QuatFunc.conjugate(this._target, q);\n        this.onChange();\n        return this;\n    }\n\n    copy(q) {\n        QuatFunc.copy(this._target, q);\n        this.onChange();\n        return this;\n    }\n\n    normalize(q = this._target) {\n        QuatFunc.normalize(this._target, q);\n        this.onChange();\n        return this;\n    }\n\n    multiply(qA, qB) {\n        if (qB) {\n            QuatFunc.multiply(this._target, qA, qB);\n        } else {\n            QuatFunc.multiply(this._target, this._target, qA);\n        }\n        this.onChange();\n        return this;\n    }\n\n    dot(v) {\n        return QuatFunc.dot(this._target, v);\n    }\n\n    fromMatrix3(matrix3) {\n        QuatFunc.fromMat3(this._target, matrix3);\n        this.onChange();\n        return this;\n    }\n\n    fromEuler(euler, isInternal) {\n        QuatFunc.fromEuler(this._target, euler, euler.order);\n        // Avoid infinite recursion\n        if (!isInternal) this.onChange();\n        return this;\n    }\n\n    fromAxisAngle(axis, a) {\n        QuatFunc.setAxisAngle(this._target, axis, a);\n        this.onChange();\n        return this;\n    }\n\n    slerp(q, t) {\n        QuatFunc.slerp(this._target, this._target, q, t);\n        this.onChange();\n        return this;\n    }\n\n    fromArray(a, o = 0) {\n        this._target[0] = a[o];\n        this._target[1] = a[o + 1];\n        this._target[2] = a[o + 2];\n        this._target[3] = a[o + 3];\n        this.onChange();\n        return this;\n    }\n\n    toArray(a = [], o = 0) {\n        a[o] = this[0];\n        a[o + 1] = this[1];\n        a[o + 2] = this[2];\n        a[o + 3] = this[3];\n        return a;\n    }\n}\n", "import * as vec3 from './Vec3Func.js';\n\nconst EPSILON = 0.000001;\n\n/**\n * Copy the values from one mat4 to another\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the source matrix\n * @returns {mat4} out\n */\nexport function copy(out, a) {\n    out[0] = a[0];\n    out[1] = a[1];\n    out[2] = a[2];\n    out[3] = a[3];\n    out[4] = a[4];\n    out[5] = a[5];\n    out[6] = a[6];\n    out[7] = a[7];\n    out[8] = a[8];\n    out[9] = a[9];\n    out[10] = a[10];\n    out[11] = a[11];\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n    return out;\n}\n\n/**\n * Set the components of a mat4 to the given values\n *\n * @param {mat4} out the receiving matrix\n * @returns {mat4} out\n */\nexport function set(out, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {\n    out[0] = m00;\n    out[1] = m01;\n    out[2] = m02;\n    out[3] = m03;\n    out[4] = m10;\n    out[5] = m11;\n    out[6] = m12;\n    out[7] = m13;\n    out[8] = m20;\n    out[9] = m21;\n    out[10] = m22;\n    out[11] = m23;\n    out[12] = m30;\n    out[13] = m31;\n    out[14] = m32;\n    out[15] = m33;\n    return out;\n}\n\n/**\n * Set a mat4 to the identity matrix\n *\n * @param {mat4} out the receiving matrix\n * @returns {mat4} out\n */\nexport function identity(out) {\n    out[0] = 1;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n    out[4] = 0;\n    out[5] = 1;\n    out[6] = 0;\n    out[7] = 0;\n    out[8] = 0;\n    out[9] = 0;\n    out[10] = 1;\n    out[11] = 0;\n    out[12] = 0;\n    out[13] = 0;\n    out[14] = 0;\n    out[15] = 1;\n    return out;\n}\n\n/**\n * Transpose the values of a mat4\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the source matrix\n * @returns {mat4} out\n */\nexport function transpose(out, a) {\n    // If we are transposing ourselves we can skip a few steps but have to cache some values\n    if (out === a) {\n        let a01 = a[1],\n            a02 = a[2],\n            a03 = a[3];\n        let a12 = a[6],\n            a13 = a[7];\n        let a23 = a[11];\n\n        out[1] = a[4];\n        out[2] = a[8];\n        out[3] = a[12];\n        out[4] = a01;\n        out[6] = a[9];\n        out[7] = a[13];\n        out[8] = a02;\n        out[9] = a12;\n        out[11] = a[14];\n        out[12] = a03;\n        out[13] = a13;\n        out[14] = a23;\n    } else {\n        out[0] = a[0];\n        out[1] = a[4];\n        out[2] = a[8];\n        out[3] = a[12];\n        out[4] = a[1];\n        out[5] = a[5];\n        out[6] = a[9];\n        out[7] = a[13];\n        out[8] = a[2];\n        out[9] = a[6];\n        out[10] = a[10];\n        out[11] = a[14];\n        out[12] = a[3];\n        out[13] = a[7];\n        out[14] = a[11];\n        out[15] = a[15];\n    }\n\n    return out;\n}\n\n/**\n * Inverts a mat4\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the source matrix\n * @returns {mat4} out\n */\nexport function invert(out, a) {\n    let a00 = a[0],\n        a01 = a[1],\n        a02 = a[2],\n        a03 = a[3];\n    let a10 = a[4],\n        a11 = a[5],\n        a12 = a[6],\n        a13 = a[7];\n    let a20 = a[8],\n        a21 = a[9],\n        a22 = a[10],\n        a23 = a[11];\n    let a30 = a[12],\n        a31 = a[13],\n        a32 = a[14],\n        a33 = a[15];\n\n    let b00 = a00 * a11 - a01 * a10;\n    let b01 = a00 * a12 - a02 * a10;\n    let b02 = a00 * a13 - a03 * a10;\n    let b03 = a01 * a12 - a02 * a11;\n    let b04 = a01 * a13 - a03 * a11;\n    let b05 = a02 * a13 - a03 * a12;\n    let b06 = a20 * a31 - a21 * a30;\n    let b07 = a20 * a32 - a22 * a30;\n    let b08 = a20 * a33 - a23 * a30;\n    let b09 = a21 * a32 - a22 * a31;\n    let b10 = a21 * a33 - a23 * a31;\n    let b11 = a22 * a33 - a23 * a32;\n\n    // Calculate the determinant\n    let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n    if (!det) {\n        return null;\n    }\n    det = 1.0 / det;\n\n    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;\n    out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;\n    out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;\n    out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;\n    out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;\n    out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;\n    out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;\n    out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;\n    out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;\n    out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;\n    out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;\n    out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;\n    out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;\n    out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;\n    out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;\n    out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;\n\n    return out;\n}\n\n/**\n * Calculates the determinant of a mat4\n *\n * @param {mat4} a the source matrix\n * @returns {Number} determinant of a\n */\nexport function determinant(a) {\n    let a00 = a[0],\n        a01 = a[1],\n        a02 = a[2],\n        a03 = a[3];\n    let a10 = a[4],\n        a11 = a[5],\n        a12 = a[6],\n        a13 = a[7];\n    let a20 = a[8],\n        a21 = a[9],\n        a22 = a[10],\n        a23 = a[11];\n    let a30 = a[12],\n        a31 = a[13],\n        a32 = a[14],\n        a33 = a[15];\n\n    let b00 = a00 * a11 - a01 * a10;\n    let b01 = a00 * a12 - a02 * a10;\n    let b02 = a00 * a13 - a03 * a10;\n    let b03 = a01 * a12 - a02 * a11;\n    let b04 = a01 * a13 - a03 * a11;\n    let b05 = a02 * a13 - a03 * a12;\n    let b06 = a20 * a31 - a21 * a30;\n    let b07 = a20 * a32 - a22 * a30;\n    let b08 = a20 * a33 - a23 * a30;\n    let b09 = a21 * a32 - a22 * a31;\n    let b10 = a21 * a33 - a23 * a31;\n    let b11 = a22 * a33 - a23 * a32;\n\n    // Calculate the determinant\n    return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n}\n\n/**\n * Multiplies two mat4s\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the first operand\n * @param {mat4} b the second operand\n * @returns {mat4} out\n */\nexport function multiply(out, a, b) {\n    let a00 = a[0],\n        a01 = a[1],\n        a02 = a[2],\n        a03 = a[3];\n    let a10 = a[4],\n        a11 = a[5],\n        a12 = a[6],\n        a13 = a[7];\n    let a20 = a[8],\n        a21 = a[9],\n        a22 = a[10],\n        a23 = a[11];\n    let a30 = a[12],\n        a31 = a[13],\n        a32 = a[14],\n        a33 = a[15];\n\n    // Cache only the current line of the second matrix\n    let b0 = b[0],\n        b1 = b[1],\n        b2 = b[2],\n        b3 = b[3];\n    out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n    out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n    out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n    out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n\n    b0 = b[4];\n    b1 = b[5];\n    b2 = b[6];\n    b3 = b[7];\n    out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n    out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n    out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n    out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n\n    b0 = b[8];\n    b1 = b[9];\n    b2 = b[10];\n    b3 = b[11];\n    out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n    out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n    out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n    out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n\n    b0 = b[12];\n    b1 = b[13];\n    b2 = b[14];\n    b3 = b[15];\n    out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;\n    out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;\n    out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;\n    out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;\n    return out;\n}\n\n/**\n * Translate a mat4 by the given vector\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the matrix to translate\n * @param {vec3} v vector to translate by\n * @returns {mat4} out\n */\nexport function translate(out, a, v) {\n    let x = v[0],\n        y = v[1],\n        z = v[2];\n    let a00, a01, a02, a03;\n    let a10, a11, a12, a13;\n    let a20, a21, a22, a23;\n\n    if (a === out) {\n        out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];\n        out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];\n        out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];\n        out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];\n    } else {\n        a00 = a[0];\n        a01 = a[1];\n        a02 = a[2];\n        a03 = a[3];\n        a10 = a[4];\n        a11 = a[5];\n        a12 = a[6];\n        a13 = a[7];\n        a20 = a[8];\n        a21 = a[9];\n        a22 = a[10];\n        a23 = a[11];\n\n        out[0] = a00;\n        out[1] = a01;\n        out[2] = a02;\n        out[3] = a03;\n        out[4] = a10;\n        out[5] = a11;\n        out[6] = a12;\n        out[7] = a13;\n        out[8] = a20;\n        out[9] = a21;\n        out[10] = a22;\n        out[11] = a23;\n\n        out[12] = a00 * x + a10 * y + a20 * z + a[12];\n        out[13] = a01 * x + a11 * y + a21 * z + a[13];\n        out[14] = a02 * x + a12 * y + a22 * z + a[14];\n        out[15] = a03 * x + a13 * y + a23 * z + a[15];\n    }\n\n    return out;\n}\n\n/**\n * Scales the mat4 by the dimensions in the given vec3 not using vectorization\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the matrix to scale\n * @param {vec3} v the vec3 to scale the matrix by\n * @returns {mat4} out\n **/\nexport function scale(out, a, v) {\n    let x = v[0],\n        y = v[1],\n        z = v[2];\n\n    out[0] = a[0] * x;\n    out[1] = a[1] * x;\n    out[2] = a[2] * x;\n    out[3] = a[3] * x;\n    out[4] = a[4] * y;\n    out[5] = a[5] * y;\n    out[6] = a[6] * y;\n    out[7] = a[7] * y;\n    out[8] = a[8] * z;\n    out[9] = a[9] * z;\n    out[10] = a[10] * z;\n    out[11] = a[11] * z;\n    out[12] = a[12];\n    out[13] = a[13];\n    out[14] = a[14];\n    out[15] = a[15];\n    return out;\n}\n\n/**\n * Rotates a mat4 by the given angle around the given axis\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @param {vec3} axis the axis to rotate around\n * @returns {mat4} out\n */\nexport function rotate(out, a, rad, axis) {\n    let x = axis[0],\n        y = axis[1],\n        z = axis[2];\n    let len = Math.hypot(x, y, z);\n    let s, c, t;\n    let a00, a01, a02, a03;\n    let a10, a11, a12, a13;\n    let a20, a21, a22, a23;\n    let b00, b01, b02;\n    let b10, b11, b12;\n    let b20, b21, b22;\n\n    if (Math.abs(len) < EPSILON) {\n        return null;\n    }\n\n    len = 1 / len;\n    x *= len;\n    y *= len;\n    z *= len;\n\n    s = Math.sin(rad);\n    c = Math.cos(rad);\n    t = 1 - c;\n\n    a00 = a[0];\n    a01 = a[1];\n    a02 = a[2];\n    a03 = a[3];\n    a10 = a[4];\n    a11 = a[5];\n    a12 = a[6];\n    a13 = a[7];\n    a20 = a[8];\n    a21 = a[9];\n    a22 = a[10];\n    a23 = a[11];\n\n    // Construct the elements of the rotation matrix\n    b00 = x * x * t + c;\n    b01 = y * x * t + z * s;\n    b02 = z * x * t - y * s;\n    b10 = x * y * t - z * s;\n    b11 = y * y * t + c;\n    b12 = z * y * t + x * s;\n    b20 = x * z * t + y * s;\n    b21 = y * z * t - x * s;\n    b22 = z * z * t + c;\n\n    // Perform rotation-specific matrix multiplication\n    out[0] = a00 * b00 + a10 * b01 + a20 * b02;\n    out[1] = a01 * b00 + a11 * b01 + a21 * b02;\n    out[2] = a02 * b00 + a12 * b01 + a22 * b02;\n    out[3] = a03 * b00 + a13 * b01 + a23 * b02;\n    out[4] = a00 * b10 + a10 * b11 + a20 * b12;\n    out[5] = a01 * b10 + a11 * b11 + a21 * b12;\n    out[6] = a02 * b10 + a12 * b11 + a22 * b12;\n    out[7] = a03 * b10 + a13 * b11 + a23 * b12;\n    out[8] = a00 * b20 + a10 * b21 + a20 * b22;\n    out[9] = a01 * b20 + a11 * b21 + a21 * b22;\n    out[10] = a02 * b20 + a12 * b21 + a22 * b22;\n    out[11] = a03 * b20 + a13 * b21 + a23 * b22;\n\n    if (a !== out) {\n        // If the source and destination differ, copy the unchanged last row\n        out[12] = a[12];\n        out[13] = a[13];\n        out[14] = a[14];\n        out[15] = a[15];\n    }\n    return out;\n}\n\n/**\n * Returns the translation vector component of a transformation\n *  matrix. If a matrix is built with fromRotationTranslation,\n *  the returned vector will be the same as the translation vector\n *  originally supplied.\n * @param  {vec3} out Vector to receive translation component\n * @param  {mat4} mat Matrix to be decomposed (input)\n * @return {vec3} out\n */\nexport function getTranslation(out, mat) {\n    out[0] = mat[12];\n    out[1] = mat[13];\n    out[2] = mat[14];\n\n    return out;\n}\n\n/**\n * Returns the scaling factor component of a transformation\n *  matrix. If a matrix is built with fromRotationTranslationScale\n *  with a normalized Quaternion paramter, the returned vector will be\n *  the same as the scaling vector\n *  originally supplied.\n * @param  {vec3} out Vector to receive scaling factor component\n * @param  {mat4} mat Matrix to be decomposed (input)\n * @return {vec3} out\n */\nexport function getScaling(out, mat) {\n    let m11 = mat[0];\n    let m12 = mat[1];\n    let m13 = mat[2];\n    let m21 = mat[4];\n    let m22 = mat[5];\n    let m23 = mat[6];\n    let m31 = mat[8];\n    let m32 = mat[9];\n    let m33 = mat[10];\n\n    out[0] = Math.hypot(m11, m12, m13);\n    out[1] = Math.hypot(m21, m22, m23);\n    out[2] = Math.hypot(m31, m32, m33);\n\n    return out;\n}\n\nexport function getMaxScaleOnAxis(mat) {\n    let m11 = mat[0];\n    let m12 = mat[1];\n    let m13 = mat[2];\n    let m21 = mat[4];\n    let m22 = mat[5];\n    let m23 = mat[6];\n    let m31 = mat[8];\n    let m32 = mat[9];\n    let m33 = mat[10];\n\n    const x = m11 * m11 + m12 * m12 + m13 * m13;\n    const y = m21 * m21 + m22 * m22 + m23 * m23;\n    const z = m31 * m31 + m32 * m32 + m33 * m33;\n\n    return Math.sqrt(Math.max(x, y, z));\n}\n\n/**\n * Returns a quaternion representing the rotational component\n *  of a transformation matrix. If a matrix is built with\n *  fromRotationTranslation, the returned quaternion will be the\n *  same as the quaternion originally supplied.\n * @param {quat} out Quaternion to receive the rotation component\n * @param {mat4} mat Matrix to be decomposed (input)\n * @return {quat} out\n */\nexport const getRotation = (function () {\n    const temp = [1, 1, 1];\n\n    return function (out, mat) {\n        let scaling = temp;\n        getScaling(scaling, mat);\n\n        let is1 = 1 / scaling[0];\n        let is2 = 1 / scaling[1];\n        let is3 = 1 / scaling[2];\n\n        let sm11 = mat[0] * is1;\n        let sm12 = mat[1] * is2;\n        let sm13 = mat[2] * is3;\n        let sm21 = mat[4] * is1;\n        let sm22 = mat[5] * is2;\n        let sm23 = mat[6] * is3;\n        let sm31 = mat[8] * is1;\n        let sm32 = mat[9] * is2;\n        let sm33 = mat[10] * is3;\n\n        let trace = sm11 + sm22 + sm33;\n        let S = 0;\n\n        if (trace > 0) {\n            S = Math.sqrt(trace + 1.0) * 2;\n            out[3] = 0.25 * S;\n            out[0] = (sm23 - sm32) / S;\n            out[1] = (sm31 - sm13) / S;\n            out[2] = (sm12 - sm21) / S;\n        } else if (sm11 > sm22 && sm11 > sm33) {\n            S = Math.sqrt(1.0 + sm11 - sm22 - sm33) * 2;\n            out[3] = (sm23 - sm32) / S;\n            out[0] = 0.25 * S;\n            out[1] = (sm12 + sm21) / S;\n            out[2] = (sm31 + sm13) / S;\n        } else if (sm22 > sm33) {\n            S = Math.sqrt(1.0 + sm22 - sm11 - sm33) * 2;\n            out[3] = (sm31 - sm13) / S;\n            out[0] = (sm12 + sm21) / S;\n            out[1] = 0.25 * S;\n            out[2] = (sm23 + sm32) / S;\n        } else {\n            S = Math.sqrt(1.0 + sm33 - sm11 - sm22) * 2;\n            out[3] = (sm12 - sm21) / S;\n            out[0] = (sm31 + sm13) / S;\n            out[1] = (sm23 + sm32) / S;\n            out[2] = 0.25 * S;\n        }\n\n        return out;\n    };\n})();\n\n/**\n * From glTF-Transform\n * https://github.com/donmccurdy/glTF-Transform/blob/main/packages/core/src/utils/math-utils.ts\n *\n * Decompose a mat4 to TRS properties.\n *\n * Equivalent to the Matrix4 decompose() method in three.js, and intentionally not using the\n * gl-matrix version. See: https://github.com/toji/gl-matrix/issues/408\n *\n * @param {mat4} srcMat Matrix element, to be decomposed to TRS properties.\n * @param {quat4} dstRotation Rotation element, to be overwritten.\n * @param {vec3} dstTranslation Translation element, to be overwritten.\n * @param {vec3} dstScale Scale element, to be overwritten\n */\nexport function decompose(srcMat, dstRotation, dstTranslation, dstScale) {\n    let sx = vec3.length([srcMat[0], srcMat[1], srcMat[2]]);\n    const sy = vec3.length([srcMat[4], srcMat[5], srcMat[6]]);\n    const sz = vec3.length([srcMat[8], srcMat[9], srcMat[10]]);\n\n    // if determine is negative, we need to invert one scale\n    const det = determinant(srcMat);\n    if (det < 0) sx = -sx;\n\n    dstTranslation[0] = srcMat[12];\n    dstTranslation[1] = srcMat[13];\n    dstTranslation[2] = srcMat[14];\n\n    // scale the rotation part\n    const _m1 = srcMat.slice();\n\n    const invSX = 1 / sx;\n    const invSY = 1 / sy;\n    const invSZ = 1 / sz;\n\n    _m1[0] *= invSX;\n    _m1[1] *= invSX;\n    _m1[2] *= invSX;\n\n    _m1[4] *= invSY;\n    _m1[5] *= invSY;\n    _m1[6] *= invSY;\n\n    _m1[8] *= invSZ;\n    _m1[9] *= invSZ;\n    _m1[10] *= invSZ;\n\n    getRotation(dstRotation, _m1);\n\n    dstScale[0] = sx;\n    dstScale[1] = sy;\n    dstScale[2] = sz;\n}\n\n/**\n * From glTF-Transform\n * https://github.com/donmccurdy/glTF-Transform/blob/main/packages/core/src/utils/math-utils.ts\n *\n * Compose TRS properties to a mat4.\n *\n * Equivalent to the Matrix4 compose() method in three.js, and intentionally not using the\n * gl-matrix version. See: https://github.com/toji/gl-matrix/issues/408\n *\n * @param {mat4} dstMat Matrix element, to be modified and returned.\n * @param {quat4} srcRotation Rotation element of matrix.\n * @param {vec3} srcTranslation Translation element of matrix.\n * @param {vec3} srcScale Scale element of matrix.\n * @returns {mat4} dstMat, overwritten to mat4 equivalent of given TRS properties.\n */\nexport function compose(dstMat, srcRotation, srcTranslation, srcScale) {\n    const te = dstMat;\n\n    const x = srcRotation[0],\n        y = srcRotation[1],\n        z = srcRotation[2],\n        w = srcRotation[3];\n    const x2 = x + x,\n        y2 = y + y,\n        z2 = z + z;\n    const xx = x * x2,\n        xy = x * y2,\n        xz = x * z2;\n    const yy = y * y2,\n        yz = y * z2,\n        zz = z * z2;\n    const wx = w * x2,\n        wy = w * y2,\n        wz = w * z2;\n\n    const sx = srcScale[0],\n        sy = srcScale[1],\n        sz = srcScale[2];\n\n    te[0] = (1 - (yy + zz)) * sx;\n    te[1] = (xy + wz) * sx;\n    te[2] = (xz - wy) * sx;\n    te[3] = 0;\n\n    te[4] = (xy - wz) * sy;\n    te[5] = (1 - (xx + zz)) * sy;\n    te[6] = (yz + wx) * sy;\n    te[7] = 0;\n\n    te[8] = (xz + wy) * sz;\n    te[9] = (yz - wx) * sz;\n    te[10] = (1 - (xx + yy)) * sz;\n    te[11] = 0;\n\n    te[12] = srcTranslation[0];\n    te[13] = srcTranslation[1];\n    te[14] = srcTranslation[2];\n    te[15] = 1;\n\n    return te;\n}\n\n/**\n * Creates a matrix from a quaternion rotation, vector translation and vector scale\n * This is equivalent to (but much faster than):\n *\n *     mat4.identity(dest);\n *     mat4.translate(dest, vec);\n *     let quatMat = mat4.create();\n *     quat4.toMat4(quat, quatMat);\n *     mat4.multiply(dest, quatMat);\n *     mat4.scale(dest, scale)\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {quat4} q Rotation quaternion\n * @param {vec3} v Translation vector\n * @param {vec3} s Scaling vector\n * @returns {mat4} out\n */\nexport function fromRotationTranslationScale(out, q, v, s) {\n    // Quaternion math\n    let x = q[0],\n        y = q[1],\n        z = q[2],\n        w = q[3];\n    let x2 = x + x;\n    let y2 = y + y;\n    let z2 = z + z;\n\n    let xx = x * x2;\n    let xy = x * y2;\n    let xz = x * z2;\n    let yy = y * y2;\n    let yz = y * z2;\n    let zz = z * z2;\n    let wx = w * x2;\n    let wy = w * y2;\n    let wz = w * z2;\n    let sx = s[0];\n    let sy = s[1];\n    let sz = s[2];\n\n    out[0] = (1 - (yy + zz)) * sx;\n    out[1] = (xy + wz) * sx;\n    out[2] = (xz - wy) * sx;\n    out[3] = 0;\n    out[4] = (xy - wz) * sy;\n    out[5] = (1 - (xx + zz)) * sy;\n    out[6] = (yz + wx) * sy;\n    out[7] = 0;\n    out[8] = (xz + wy) * sz;\n    out[9] = (yz - wx) * sz;\n    out[10] = (1 - (xx + yy)) * sz;\n    out[11] = 0;\n    out[12] = v[0];\n    out[13] = v[1];\n    out[14] = v[2];\n    out[15] = 1;\n\n    return out;\n}\n\n/**\n * Calculates a 4x4 matrix from the given quaternion\n *\n * @param {mat4} out mat4 receiving operation result\n * @param {quat} q Quaternion to create matrix from\n *\n * @returns {mat4} out\n */\nexport function fromQuat(out, q) {\n    let x = q[0],\n        y = q[1],\n        z = q[2],\n        w = q[3];\n    let x2 = x + x;\n    let y2 = y + y;\n    let z2 = z + z;\n\n    let xx = x * x2;\n    let yx = y * x2;\n    let yy = y * y2;\n    let zx = z * x2;\n    let zy = z * y2;\n    let zz = z * z2;\n    let wx = w * x2;\n    let wy = w * y2;\n    let wz = w * z2;\n\n    out[0] = 1 - yy - zz;\n    out[1] = yx + wz;\n    out[2] = zx - wy;\n    out[3] = 0;\n\n    out[4] = yx - wz;\n    out[5] = 1 - xx - zz;\n    out[6] = zy + wx;\n    out[7] = 0;\n\n    out[8] = zx + wy;\n    out[9] = zy - wx;\n    out[10] = 1 - xx - yy;\n    out[11] = 0;\n\n    out[12] = 0;\n    out[13] = 0;\n    out[14] = 0;\n    out[15] = 1;\n\n    return out;\n}\n\n/**\n * Generates a perspective projection matrix with the given bounds\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {number} fovy Vertical field of view in radians\n * @param {number} aspect Aspect ratio. typically viewport width/height\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum\n * @returns {mat4} out\n */\nexport function perspective(out, fovy, aspect, near, far) {\n    let f = 1.0 / Math.tan(fovy / 2);\n    let nf = 1 / (near - far);\n    out[0] = f / aspect;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n    out[4] = 0;\n    out[5] = f;\n    out[6] = 0;\n    out[7] = 0;\n    out[8] = 0;\n    out[9] = 0;\n    out[10] = (far + near) * nf;\n    out[11] = -1;\n    out[12] = 0;\n    out[13] = 0;\n    out[14] = 2 * far * near * nf;\n    out[15] = 0;\n    return out;\n}\n\n/**\n * Generates a orthogonal projection matrix with the given bounds\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {number} left Left bound of the frustum\n * @param {number} right Right bound of the frustum\n * @param {number} bottom Bottom bound of the frustum\n * @param {number} top Top bound of the frustum\n * @param {number} near Near bound of the frustum\n * @param {number} far Far bound of the frustum\n * @returns {mat4} out\n */\nexport function ortho(out, left, right, bottom, top, near, far) {\n    let lr = 1 / (left - right);\n    let bt = 1 / (bottom - top);\n    let nf = 1 / (near - far);\n    out[0] = -2 * lr;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n    out[4] = 0;\n    out[5] = -2 * bt;\n    out[6] = 0;\n    out[7] = 0;\n    out[8] = 0;\n    out[9] = 0;\n    out[10] = 2 * nf;\n    out[11] = 0;\n    out[12] = (left + right) * lr;\n    out[13] = (top + bottom) * bt;\n    out[14] = (far + near) * nf;\n    out[15] = 1;\n    return out;\n}\n\n/**\n * Generates a matrix that makes something look at something else.\n *\n * @param {mat4} out mat4 frustum matrix will be written into\n * @param {vec3} eye Position of the viewer\n * @param {vec3} target Point the viewer is looking at\n * @param {vec3} up vec3 pointing up\n * @returns {mat4} out\n */\nexport function targetTo(out, eye, target, up) {\n    let eyex = eye[0],\n        eyey = eye[1],\n        eyez = eye[2],\n        upx = up[0],\n        upy = up[1],\n        upz = up[2];\n\n    let z0 = eyex - target[0],\n        z1 = eyey - target[1],\n        z2 = eyez - target[2];\n\n    let len = z0 * z0 + z1 * z1 + z2 * z2;\n    if (len === 0) {\n        // eye and target are in the same position\n        z2 = 1;\n    } else {\n        len = 1 / Math.sqrt(len);\n        z0 *= len;\n        z1 *= len;\n        z2 *= len;\n    }\n\n    let x0 = upy * z2 - upz * z1,\n        x1 = upz * z0 - upx * z2,\n        x2 = upx * z1 - upy * z0;\n\n    len = x0 * x0 + x1 * x1 + x2 * x2;\n    if (len === 0) {\n        // up and z are parallel\n        if (upz) {\n            upx += 1e-6;\n        } else if (upy) {\n            upz += 1e-6;\n        } else {\n            upy += 1e-6;\n        }\n        (x0 = upy * z2 - upz * z1), (x1 = upz * z0 - upx * z2), (x2 = upx * z1 - upy * z0);\n\n        len = x0 * x0 + x1 * x1 + x2 * x2;\n    }\n\n    len = 1 / Math.sqrt(len);\n    x0 *= len;\n    x1 *= len;\n    x2 *= len;\n\n    out[0] = x0;\n    out[1] = x1;\n    out[2] = x2;\n    out[3] = 0;\n    out[4] = z1 * x2 - z2 * x1;\n    out[5] = z2 * x0 - z0 * x2;\n    out[6] = z0 * x1 - z1 * x0;\n    out[7] = 0;\n    out[8] = z0;\n    out[9] = z1;\n    out[10] = z2;\n    out[11] = 0;\n    out[12] = eyex;\n    out[13] = eyey;\n    out[14] = eyez;\n    out[15] = 1;\n    return out;\n}\n\n/**\n * Adds two mat4's\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the first operand\n * @param {mat4} b the second operand\n * @returns {mat4} out\n */\nexport function add(out, a, b) {\n    out[0] = a[0] + b[0];\n    out[1] = a[1] + b[1];\n    out[2] = a[2] + b[2];\n    out[3] = a[3] + b[3];\n    out[4] = a[4] + b[4];\n    out[5] = a[5] + b[5];\n    out[6] = a[6] + b[6];\n    out[7] = a[7] + b[7];\n    out[8] = a[8] + b[8];\n    out[9] = a[9] + b[9];\n    out[10] = a[10] + b[10];\n    out[11] = a[11] + b[11];\n    out[12] = a[12] + b[12];\n    out[13] = a[13] + b[13];\n    out[14] = a[14] + b[14];\n    out[15] = a[15] + b[15];\n    return out;\n}\n\n/**\n * Subtracts matrix b from matrix a\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the first operand\n * @param {mat4} b the second operand\n * @returns {mat4} out\n */\nexport function subtract(out, a, b) {\n    out[0] = a[0] - b[0];\n    out[1] = a[1] - b[1];\n    out[2] = a[2] - b[2];\n    out[3] = a[3] - b[3];\n    out[4] = a[4] - b[4];\n    out[5] = a[5] - b[5];\n    out[6] = a[6] - b[6];\n    out[7] = a[7] - b[7];\n    out[8] = a[8] - b[8];\n    out[9] = a[9] - b[9];\n    out[10] = a[10] - b[10];\n    out[11] = a[11] - b[11];\n    out[12] = a[12] - b[12];\n    out[13] = a[13] - b[13];\n    out[14] = a[14] - b[14];\n    out[15] = a[15] - b[15];\n    return out;\n}\n\n/**\n * Multiply each element of the matrix by a scalar.\n *\n * @param {mat4} out the receiving matrix\n * @param {mat4} a the matrix to scale\n * @param {Number} b amount to scale the matrix's elements by\n * @returns {mat4} out\n */\nexport function multiplyScalar(out, a, b) {\n    out[0] = a[0] * b;\n    out[1] = a[1] * b;\n    out[2] = a[2] * b;\n    out[3] = a[3] * b;\n    out[4] = a[4] * b;\n    out[5] = a[5] * b;\n    out[6] = a[6] * b;\n    out[7] = a[7] * b;\n    out[8] = a[8] * b;\n    out[9] = a[9] * b;\n    out[10] = a[10] * b;\n    out[11] = a[11] * b;\n    out[12] = a[12] * b;\n    out[13] = a[13] * b;\n    out[14] = a[14] * b;\n    out[15] = a[15] * b;\n    return out;\n}\n", "import * as Mat4Func from './functions/Mat4Func.js';\n\nexport class Mat4 extends Array {\n    constructor(\n        m00 = 1,\n        m01 = 0,\n        m02 = 0,\n        m03 = 0,\n        m10 = 0,\n        m11 = 1,\n        m12 = 0,\n        m13 = 0,\n        m20 = 0,\n        m21 = 0,\n        m22 = 1,\n        m23 = 0,\n        m30 = 0,\n        m31 = 0,\n        m32 = 0,\n        m33 = 1\n    ) {\n        super(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33);\n        return this;\n    }\n\n    get x() {\n        return this[12];\n    }\n\n    get y() {\n        return this[13];\n    }\n\n    get z() {\n        return this[14];\n    }\n\n    get w() {\n        return this[15];\n    }\n\n    set x(v) {\n        this[12] = v;\n    }\n\n    set y(v) {\n        this[13] = v;\n    }\n\n    set z(v) {\n        this[14] = v;\n    }\n\n    set w(v) {\n        this[15] = v;\n    }\n\n    set(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {\n        if (m00.length) return this.copy(m00);\n        Mat4Func.set(this, m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33);\n        return this;\n    }\n\n    translate(v, m = this) {\n        Mat4Func.translate(this, m, v);\n        return this;\n    }\n\n    rotate(v, axis, m = this) {\n        Mat4Func.rotate(this, m, v, axis);\n        return this;\n    }\n\n    scale(v, m = this) {\n        Mat4Func.scale(this, m, typeof v === 'number' ? [v, v, v] : v);\n        return this;\n    }\n\n    add(ma, mb) {\n        if (mb) Mat4Func.add(this, ma, mb);\n        else Mat4Func.add(this, this, ma);\n        return this;\n    }\n\n    sub(ma, mb) {\n        if (mb) Mat4Func.subtract(this, ma, mb);\n        else Mat4Func.subtract(this, this, ma);\n        return this;\n    }\n\n    multiply(ma, mb) {\n        if (!ma.length) {\n            Mat4Func.multiplyScalar(this, this, ma);\n        } else if (mb) {\n            Mat4Func.multiply(this, ma, mb);\n        } else {\n            Mat4Func.multiply(this, this, ma);\n        }\n        return this;\n    }\n\n    identity() {\n        Mat4Func.identity(this);\n        return this;\n    }\n\n    copy(m) {\n        Mat4Func.copy(this, m);\n        return this;\n    }\n\n    fromPerspective({ fov, aspect, near, far } = {}) {\n        Mat4Func.perspective(this, fov, aspect, near, far);\n        return this;\n    }\n\n    fromOrthogonal({ left, right, bottom, top, near, far }) {\n        Mat4Func.ortho(this, left, right, bottom, top, near, far);\n        return this;\n    }\n\n    fromQuaternion(q) {\n        Mat4Func.fromQuat(this, q);\n        return this;\n    }\n\n    setPosition(v) {\n        this.x = v[0];\n        this.y = v[1];\n        this.z = v[2];\n        return this;\n    }\n\n    inverse(m = this) {\n        Mat4Func.invert(this, m);\n        return this;\n    }\n\n    compose(q, pos, scale) {\n        Mat4Func.compose(this, q, pos, scale);\n        return this;\n    }\n\n    decompose(q, pos, scale) {\n        Mat4Func.decompose(this, q, pos, scale);\n        return this;\n    }\n\n    getRotation(q) {\n        Mat4Func.getRotation(q, this);\n        return this;\n    }\n\n    getTranslation(pos) {\n        Mat4Func.getTranslation(pos, this);\n        return this;\n    }\n\n    getScaling(scale) {\n        Mat4Func.getScaling(scale, this);\n        return this;\n    }\n\n    getMaxScaleOnAxis() {\n        return Mat4Func.getMaxScaleOnAxis(this);\n    }\n\n    lookAt(eye, target, up) {\n        Mat4Func.targetTo(this, eye, target, up);\n        return this;\n    }\n\n    determinant() {\n        return Mat4Func.determinant(this);\n    }\n\n    fromArray(a, o = 0) {\n        this[0] = a[o];\n        this[1] = a[o + 1];\n        this[2] = a[o + 2];\n        this[3] = a[o + 3];\n        this[4] = a[o + 4];\n        this[5] = a[o + 5];\n        this[6] = a[o + 6];\n        this[7] = a[o + 7];\n        this[8] = a[o + 8];\n        this[9] = a[o + 9];\n        this[10] = a[o + 10];\n        this[11] = a[o + 11];\n        this[12] = a[o + 12];\n        this[13] = a[o + 13];\n        this[14] = a[o + 14];\n        this[15] = a[o + 15];\n        return this;\n    }\n\n    toArray(a = [], o = 0) {\n        a[o] = this[0];\n        a[o + 1] = this[1];\n        a[o + 2] = this[2];\n        a[o + 3] = this[3];\n        a[o + 4] = this[4];\n        a[o + 5] = this[5];\n        a[o + 6] = this[6];\n        a[o + 7] = this[7];\n        a[o + 8] = this[8];\n        a[o + 9] = this[9];\n        a[o + 10] = this[10];\n        a[o + 11] = this[11];\n        a[o + 12] = this[12];\n        a[o + 13] = this[13];\n        a[o + 14] = this[14];\n        a[o + 15] = this[15];\n        return a;\n    }\n}\n", "// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)\nexport function fromRotationMatrix(out, m, order = 'YXZ') {\n    if (order === 'XYZ') {\n        out[1] = Math.asin(Math.min(Math.max(m[8], -1), 1));\n        if (Math.abs(m[8]) < 0.99999) {\n            out[0] = Math.atan2(-m[9], m[10]);\n            out[2] = Math.atan2(-m[4], m[0]);\n        } else {\n            out[0] = Math.atan2(m[6], m[5]);\n            out[2] = 0;\n        }\n    } else if (order === 'YXZ') {\n        out[0] = Math.asin(-Math.min(Math.max(m[9], -1), 1));\n        if (Math.abs(m[9]) < 0.99999) {\n            out[1] = Math.atan2(m[8], m[10]);\n            out[2] = Math.atan2(m[1], m[5]);\n        } else {\n            out[1] = Math.atan2(-m[2], m[0]);\n            out[2] = 0;\n        }\n    } else if (order === 'ZXY') {\n        out[0] = Math.asin(Math.min(Math.max(m[6], -1), 1));\n        if (Math.abs(m[6]) < 0.99999) {\n            out[1] = Math.atan2(-m[2], m[10]);\n            out[2] = Math.atan2(-m[4], m[5]);\n        } else {\n            out[1] = 0;\n            out[2] = Math.atan2(m[1], m[0]);\n        }\n    } else if (order === 'ZYX') {\n        out[1] = Math.asin(-Math.min(Math.max(m[2], -1), 1));\n        if (Math.abs(m[2]) < 0.99999) {\n            out[0] = Math.atan2(m[6], m[10]);\n            out[2] = Math.atan2(m[1], m[0]);\n        } else {\n            out[0] = 0;\n            out[2] = Math.atan2(-m[4], m[5]);\n        }\n    } else if (order === 'YZX') {\n        out[2] = Math.asin(Math.min(Math.max(m[1], -1), 1));\n        if (Math.abs(m[1]) < 0.99999) {\n            out[0] = Math.atan2(-m[9], m[5]);\n            out[1] = Math.atan2(-m[2], m[0]);\n        } else {\n            out[0] = 0;\n            out[1] = Math.atan2(m[8], m[10]);\n        }\n    } else if (order === 'XZY') {\n        out[2] = Math.asin(-Math.min(Math.max(m[4], -1), 1));\n        if (Math.abs(m[4]) < 0.99999) {\n            out[0] = Math.atan2(m[6], m[5]);\n            out[1] = Math.atan2(m[8], m[0]);\n        } else {\n            out[0] = Math.atan2(-m[9], m[10]);\n            out[1] = 0;\n        }\n    }\n\n    return out;\n}\n", "import * as EulerFunc from './functions/EulerFunc.js';\nimport { Mat4 } from './Mat4.js';\n\nconst tmpMat4 = /* @__PURE__ */ new Mat4();\n\nexport class Euler extends Array {\n    constructor(x = 0, y = x, z = x, order = 'YXZ') {\n        super(x, y, z);\n        this.order = order;\n        this.onChange = () => {};\n\n        // Keep reference to proxy target to avoid triggering onChange internally\n        this._target = this;\n\n        // Return a proxy to trigger onChange when array elements are edited directly\n        const triggerProps = ['0', '1', '2'];\n        return new Proxy(this, {\n            set(target, property) {\n                const success = Reflect.set(...arguments);\n                if (success && triggerProps.includes(property)) target.onChange();\n                return success;\n            },\n        });\n    }\n\n    get x() {\n        return this[0];\n    }\n\n    get y() {\n        return this[1];\n    }\n\n    get z() {\n        return this[2];\n    }\n\n    set x(v) {\n        this._target[0] = v;\n        this.onChange();\n    }\n\n    set y(v) {\n        this._target[1] = v;\n        this.onChange();\n    }\n\n    set z(v) {\n        this._target[2] = v;\n        this.onChange();\n    }\n\n    set(x, y = x, z = x) {\n        if (x.length) return this.copy(x);\n        this._target[0] = x;\n        this._target[1] = y;\n        this._target[2] = z;\n        this.onChange();\n        return this;\n    }\n\n    copy(v) {\n        this._target[0] = v[0];\n        this._target[1] = v[1];\n        this._target[2] = v[2];\n        this.onChange();\n        return this;\n    }\n\n    reorder(order) {\n        this._target.order = order;\n        this.onChange();\n        return this;\n    }\n\n    fromRotationMatrix(m, order = this.order) {\n        EulerFunc.fromRotationMatrix(this._target, m, order);\n        this.onChange();\n        return this;\n    }\n\n    fromQuaternion(q, order = this.order, isInternal) {\n        tmpMat4.fromQuaternion(q);\n        this._target.fromRotationMatrix(tmpMat4, order);\n        // Avoid infinite recursion\n        if (!isInternal) this.onChange();\n        return this;\n    }\n\n    fromArray(a, o = 0) {\n        this._target[0] = a[o];\n        this._target[1] = a[o + 1];\n        this._target[2] = a[o + 2];\n        return this;\n    }\n\n    toArray(a = [], o = 0) {\n        a[o] = this[0];\n        a[o + 1] = this[1];\n        a[o + 2] = this[2];\n        return a;\n    }\n}\n", "import { Vec3 } from '../math/Vec3.js';\nimport { Quat } from '../math/Quat.js';\nimport { Mat4 } from '../math/Mat4.js';\nimport { Euler } from '../math/Euler.js';\n\nexport class Transform {\n    constructor() {\n        this.parent = null;\n        this.children = [];\n        this.visible = true;\n\n        this.matrix = new Mat4();\n        this.worldMatrix = new Mat4();\n        this.matrixAutoUpdate = true;\n        this.worldMatrixNeedsUpdate = false;\n\n        this.position = new Vec3();\n        this.quaternion = new Quat();\n        this.scale = new Vec3(1);\n        this.rotation = new Euler();\n        this.up = new Vec3(0, 1, 0);\n\n        this.rotation._target.onChange = () => this.quaternion.fromEuler(this.rotation, true);\n        this.quaternion._target.onChange = () => this.rotation.fromQuaternion(this.quaternion, undefined, true);\n    }\n\n    setParent(parent, notifyParent = true) {\n        if (this.parent && parent !== this.parent) this.parent.removeChild(this, false);\n        this.parent = parent;\n        if (notifyParent && parent) parent.addChild(this, false);\n    }\n\n    addChild(child, notifyChild = true) {\n        if (!~this.children.indexOf(child)) this.children.push(child);\n        if (notifyChild) child.setParent(this, false);\n    }\n\n    removeChild(child, notifyChild = true) {\n        if (!!~this.children.indexOf(child)) this.children.splice(this.children.indexOf(child), 1);\n        if (notifyChild) child.setParent(null, false);\n    }\n\n    updateMatrixWorld(force) {\n        if (this.matrixAutoUpdate) this.updateMatrix();\n        if (this.worldMatrixNeedsUpdate || force) {\n            if (this.parent === null) this.worldMatrix.copy(this.matrix);\n            else this.worldMatrix.multiply(this.parent.worldMatrix, this.matrix);\n            this.worldMatrixNeedsUpdate = false;\n            force = true;\n        }\n\n        for (let i = 0, l = this.children.length; i < l; i++) {\n            this.children[i].updateMatrixWorld(force);\n        }\n    }\n\n    updateMatrix() {\n        this.matrix.compose(this.quaternion, this.position, this.scale);\n        this.worldMatrixNeedsUpdate = true;\n    }\n\n    traverse(callback) {\n        // Return true in callback to stop traversing children\n        if (callback(this)) return;\n        for (let i = 0, l = this.children.length; i < l; i++) {\n            this.children[i].traverse(callback);\n        }\n    }\n\n    decompose() {\n        this.matrix.decompose(this.quaternion._target, this.position, this.scale);\n        this.rotation.fromQuaternion(this.quaternion);\n    }\n\n    lookAt(target, invert = false) {\n        if (invert) this.matrix.lookAt(this.position, target, this.up);\n        else this.matrix.lookAt(target, this.position, this.up);\n        this.matrix.getRotation(this.quaternion._target);\n        this.rotation.fromQuaternion(this.quaternion);\n    }\n}\n", "import { Transform } from './Transform.js';\nimport { Mat4 } from '../math/Mat4.js';\nimport { Vec3 } from '../math/Vec3.js';\n\nconst tempMat4 = /* @__PURE__ */ new Mat4();\nconst tempVec3a = /* @__PURE__ */ new Vec3();\nconst tempVec3b = /* @__PURE__ */ new Vec3();\n\nexport class Camera extends Transform {\n    constructor(gl, { near = 0.1, far = 100, fov = 45, aspect = 1, left, right, bottom, top, zoom = 1 } = {}) {\n        super();\n\n        Object.assign(this, { near, far, fov, aspect, left, right, bottom, top, zoom });\n\n        this.projectionMatrix = new Mat4();\n        this.viewMatrix = new Mat4();\n        this.projectionViewMatrix = new Mat4();\n        this.worldPosition = new Vec3();\n\n        // Use orthographic if left/right set, else default to perspective camera\n        this.type = left || right ? 'orthographic' : 'perspective';\n\n        if (this.type === 'orthographic') this.orthographic();\n        else this.perspective();\n    }\n\n    perspective({ near = this.near, far = this.far, fov = this.fov, aspect = this.aspect } = {}) {\n        Object.assign(this, { near, far, fov, aspect });\n        this.projectionMatrix.fromPerspective({ fov: fov * (Math.PI / 180), aspect, near, far });\n        this.type = 'perspective';\n        return this;\n    }\n\n    orthographic({\n        near = this.near,\n        far = this.far,\n        left = this.left || -1,\n        right = this.right || 1,\n        bottom = this.bottom || -1,\n        top = this.top || 1,\n        zoom = this.zoom,\n    } = {}) {\n        Object.assign(this, { near, far, left, right, bottom, top, zoom });\n        left /= zoom;\n        right /= zoom;\n        bottom /= zoom;\n        top /= zoom;\n        this.projectionMatrix.fromOrthogonal({ left, right, bottom, top, near, far });\n        this.type = 'orthographic';\n        return this;\n    }\n\n    updateMatrixWorld() {\n        super.updateMatrixWorld();\n        this.viewMatrix.inverse(this.worldMatrix);\n        this.worldMatrix.getTranslation(this.worldPosition);\n\n        // used for sorting\n        this.projectionViewMatrix.multiply(this.projectionMatrix, this.viewMatrix);\n        return this;\n    }\n\n    updateProjectionMatrix() {\n        if (this.type === 'perspective') {\n            return this.perspective();\n        } else {\n            return this.orthographic();\n        }\n    }\n\n    lookAt(target) {\n        super.lookAt(target, true);\n        return this;\n    }\n\n    // Project 3D coordinate to 2D point\n    project(v) {\n        v.applyMatrix4(this.viewMatrix);\n        v.applyMatrix4(this.projectionMatrix);\n        return this;\n    }\n\n    // Unproject 2D point to 3D coordinate\n    unproject(v) {\n        v.applyMatrix4(tempMat4.inverse(this.projectionMatrix));\n        v.applyMatrix4(this.worldMatrix);\n        return this;\n    }\n\n    updateFrustum() {\n        if (!this.frustum) {\n            this.frustum = [new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3(), new Vec3()];\n        }\n\n        const m = this.projectionViewMatrix;\n        this.frustum[0].set(m[3] - m[0], m[7] - m[4], m[11] - m[8]).constant = m[15] - m[12]; // -x\n        this.frustum[1].set(m[3] + m[0], m[7] + m[4], m[11] + m[8]).constant = m[15] + m[12]; // +x\n        this.frustum[2].set(m[3] + m[1], m[7] + m[5], m[11] + m[9]).constant = m[15] + m[13]; // +y\n        this.frustum[3].set(m[3] - m[1], m[7] - m[5], m[11] - m[9]).constant = m[15] - m[13]; // -y\n        this.frustum[4].set(m[3] - m[2], m[7] - m[6], m[11] - m[10]).constant = m[15] - m[14]; // +z (far)\n        this.frustum[5].set(m[3] + m[2], m[7] + m[6], m[11] + m[10]).constant = m[15] + m[14]; // -z (near)\n\n        for (let i = 0; i < 6; i++) {\n            const invLen = 1.0 / this.frustum[i].distance();\n            this.frustum[i].multiply(invLen);\n            this.frustum[i].constant *= invLen;\n        }\n    }\n\n    frustumIntersectsMesh(node, worldMatrix = node.worldMatrix) {\n        // If no position attribute, treat as frustumCulled false\n        if (!node.geometry.attributes.position) return true;\n\n        if (!node.geometry.bounds || node.geometry.bounds.radius === Infinity) node.geometry.computeBoundingSphere();\n\n        if (!node.geometry.bounds) return true;\n\n        const center = tempVec3a;\n        center.copy(node.geometry.bounds.center);\n        center.applyMatrix4(worldMatrix);\n\n        const radius = node.geometry.bounds.radius * worldMatrix.getMaxScaleOnAxis();\n\n        return this.frustumIntersectsSphere(center, radius);\n    }\n\n    frustumIntersectsSphere(center, radius) {\n        const normal = tempVec3b;\n\n        for (let i = 0; i < 6; i++) {\n            const plane = this.frustum[i];\n            const distance = normal.copy(plane).dot(center) + plane.constant;\n            if (distance < -radius) return false;\n        }\n        return true;\n    }\n}\n", "const EPSILON = 0.000001;\n\n/**\n * Copies the upper-left 3x3 values into the given mat3.\n *\n * @param {mat3} out the receiving 3x3 matrix\n * @param {mat4} a   the source 4x4 matrix\n * @returns {mat3} out\n */\nexport function fromMat4(out, a) {\n    out[0] = a[0];\n    out[1] = a[1];\n    out[2] = a[2];\n    out[3] = a[4];\n    out[4] = a[5];\n    out[5] = a[6];\n    out[6] = a[8];\n    out[7] = a[9];\n    out[8] = a[10];\n    return out;\n}\n\n/**\n * Calculates a 3x3 matrix from the given quaternion\n *\n * @param {mat3} out mat3 receiving operation result\n * @param {quat} q Quaternion to create matrix from\n *\n * @returns {mat3} out\n */\nexport function fromQuat(out, q) {\n    let x = q[0],\n        y = q[1],\n        z = q[2],\n        w = q[3];\n    let x2 = x + x;\n    let y2 = y + y;\n    let z2 = z + z;\n\n    let xx = x * x2;\n    let yx = y * x2;\n    let yy = y * y2;\n    let zx = z * x2;\n    let zy = z * y2;\n    let zz = z * z2;\n    let wx = w * x2;\n    let wy = w * y2;\n    let wz = w * z2;\n\n    out[0] = 1 - yy - zz;\n    out[3] = yx - wz;\n    out[6] = zx + wy;\n\n    out[1] = yx + wz;\n    out[4] = 1 - xx - zz;\n    out[7] = zy - wx;\n\n    out[2] = zx - wy;\n    out[5] = zy + wx;\n    out[8] = 1 - xx - yy;\n\n    return out;\n}\n\n/**\n * Copy the values from one mat3 to another\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the source matrix\n * @returns {mat3} out\n */\nexport function copy(out, a) {\n    out[0] = a[0];\n    out[1] = a[1];\n    out[2] = a[2];\n    out[3] = a[3];\n    out[4] = a[4];\n    out[5] = a[5];\n    out[6] = a[6];\n    out[7] = a[7];\n    out[8] = a[8];\n    return out;\n}\n\n/**\n * Set the components of a mat3 to the given values\n *\n * @param {mat3} out the receiving matrix\n * @returns {mat3} out\n */\nexport function set(out, m00, m01, m02, m10, m11, m12, m20, m21, m22) {\n    out[0] = m00;\n    out[1] = m01;\n    out[2] = m02;\n    out[3] = m10;\n    out[4] = m11;\n    out[5] = m12;\n    out[6] = m20;\n    out[7] = m21;\n    out[8] = m22;\n    return out;\n}\n\n/**\n * Set a mat3 to the identity matrix\n *\n * @param {mat3} out the receiving matrix\n * @returns {mat3} out\n */\nexport function identity(out) {\n    out[0] = 1;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n    out[4] = 1;\n    out[5] = 0;\n    out[6] = 0;\n    out[7] = 0;\n    out[8] = 1;\n    return out;\n}\n\n/**\n * Transpose the values of a mat3\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the source matrix\n * @returns {mat3} out\n */\nexport function transpose(out, a) {\n    // If we are transposing ourselves we can skip a few steps but have to cache some values\n    if (out === a) {\n        let a01 = a[1],\n            a02 = a[2],\n            a12 = a[5];\n        out[1] = a[3];\n        out[2] = a[6];\n        out[3] = a01;\n        out[5] = a[7];\n        out[6] = a02;\n        out[7] = a12;\n    } else {\n        out[0] = a[0];\n        out[1] = a[3];\n        out[2] = a[6];\n        out[3] = a[1];\n        out[4] = a[4];\n        out[5] = a[7];\n        out[6] = a[2];\n        out[7] = a[5];\n        out[8] = a[8];\n    }\n\n    return out;\n}\n\n/**\n * Inverts a mat3\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the source matrix\n * @returns {mat3} out\n */\nexport function invert(out, a) {\n    let a00 = a[0],\n        a01 = a[1],\n        a02 = a[2];\n    let a10 = a[3],\n        a11 = a[4],\n        a12 = a[5];\n    let a20 = a[6],\n        a21 = a[7],\n        a22 = a[8];\n\n    let b01 = a22 * a11 - a12 * a21;\n    let b11 = -a22 * a10 + a12 * a20;\n    let b21 = a21 * a10 - a11 * a20;\n\n    // Calculate the determinant\n    let det = a00 * b01 + a01 * b11 + a02 * b21;\n\n    if (!det) {\n        return null;\n    }\n    det = 1.0 / det;\n\n    out[0] = b01 * det;\n    out[1] = (-a22 * a01 + a02 * a21) * det;\n    out[2] = (a12 * a01 - a02 * a11) * det;\n    out[3] = b11 * det;\n    out[4] = (a22 * a00 - a02 * a20) * det;\n    out[5] = (-a12 * a00 + a02 * a10) * det;\n    out[6] = b21 * det;\n    out[7] = (-a21 * a00 + a01 * a20) * det;\n    out[8] = (a11 * a00 - a01 * a10) * det;\n    return out;\n}\n\n/**\n * Calculates the determinant of a mat3\n *\n * @param {mat3} a the source matrix\n * @returns {Number} determinant of a\n */\nexport function determinant(a) {\n    let a00 = a[0],\n        a01 = a[1],\n        a02 = a[2];\n    let a10 = a[3],\n        a11 = a[4],\n        a12 = a[5];\n    let a20 = a[6],\n        a21 = a[7],\n        a22 = a[8];\n\n    return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);\n}\n\n/**\n * Multiplies two mat3's\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the first operand\n * @param {mat3} b the second operand\n * @returns {mat3} out\n */\nexport function multiply(out, a, b) {\n    let a00 = a[0],\n        a01 = a[1],\n        a02 = a[2];\n    let a10 = a[3],\n        a11 = a[4],\n        a12 = a[5];\n    let a20 = a[6],\n        a21 = a[7],\n        a22 = a[8];\n\n    let b00 = b[0],\n        b01 = b[1],\n        b02 = b[2];\n    let b10 = b[3],\n        b11 = b[4],\n        b12 = b[5];\n    let b20 = b[6],\n        b21 = b[7],\n        b22 = b[8];\n\n    out[0] = b00 * a00 + b01 * a10 + b02 * a20;\n    out[1] = b00 * a01 + b01 * a11 + b02 * a21;\n    out[2] = b00 * a02 + b01 * a12 + b02 * a22;\n\n    out[3] = b10 * a00 + b11 * a10 + b12 * a20;\n    out[4] = b10 * a01 + b11 * a11 + b12 * a21;\n    out[5] = b10 * a02 + b11 * a12 + b12 * a22;\n\n    out[6] = b20 * a00 + b21 * a10 + b22 * a20;\n    out[7] = b20 * a01 + b21 * a11 + b22 * a21;\n    out[8] = b20 * a02 + b21 * a12 + b22 * a22;\n    return out;\n}\n\n/**\n * Translate a mat3 by the given vector\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the matrix to translate\n * @param {vec2} v vector to translate by\n * @returns {mat3} out\n */\nexport function translate(out, a, v) {\n    let a00 = a[0],\n        a01 = a[1],\n        a02 = a[2],\n        a10 = a[3],\n        a11 = a[4],\n        a12 = a[5],\n        a20 = a[6],\n        a21 = a[7],\n        a22 = a[8],\n        x = v[0],\n        y = v[1];\n\n    out[0] = a00;\n    out[1] = a01;\n    out[2] = a02;\n\n    out[3] = a10;\n    out[4] = a11;\n    out[5] = a12;\n\n    out[6] = x * a00 + y * a10 + a20;\n    out[7] = x * a01 + y * a11 + a21;\n    out[8] = x * a02 + y * a12 + a22;\n    return out;\n}\n\n/**\n * Rotates a mat3 by the given angle\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the matrix to rotate\n * @param {Number} rad the angle to rotate the matrix by\n * @returns {mat3} out\n */\nexport function rotate(out, a, rad) {\n    let a00 = a[0],\n        a01 = a[1],\n        a02 = a[2],\n        a10 = a[3],\n        a11 = a[4],\n        a12 = a[5],\n        a20 = a[6],\n        a21 = a[7],\n        a22 = a[8],\n        s = Math.sin(rad),\n        c = Math.cos(rad);\n\n    out[0] = c * a00 + s * a10;\n    out[1] = c * a01 + s * a11;\n    out[2] = c * a02 + s * a12;\n\n    out[3] = c * a10 - s * a00;\n    out[4] = c * a11 - s * a01;\n    out[5] = c * a12 - s * a02;\n\n    out[6] = a20;\n    out[7] = a21;\n    out[8] = a22;\n    return out;\n}\n\n/**\n * Scales the mat3 by the dimensions in the given vec2\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the matrix to rotate\n * @param {vec2} v the vec2 to scale the matrix by\n * @returns {mat3} out\n **/\nexport function scale(out, a, v) {\n    let x = v[0],\n        y = v[1];\n\n    out[0] = x * a[0];\n    out[1] = x * a[1];\n    out[2] = x * a[2];\n\n    out[3] = y * a[3];\n    out[4] = y * a[4];\n    out[5] = y * a[5];\n\n    out[6] = a[6];\n    out[7] = a[7];\n    out[8] = a[8];\n    return out;\n}\n\n/**\n * Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix\n *\n * @param {mat3} out mat3 receiving operation result\n * @param {mat4} a Mat4 to derive the normal matrix from\n *\n * @returns {mat3} out\n */\nexport function normalFromMat4(out, a) {\n    let a00 = a[0],\n        a01 = a[1],\n        a02 = a[2],\n        a03 = a[3];\n    let a10 = a[4],\n        a11 = a[5],\n        a12 = a[6],\n        a13 = a[7];\n    let a20 = a[8],\n        a21 = a[9],\n        a22 = a[10],\n        a23 = a[11];\n    let a30 = a[12],\n        a31 = a[13],\n        a32 = a[14],\n        a33 = a[15];\n\n    let b00 = a00 * a11 - a01 * a10;\n    let b01 = a00 * a12 - a02 * a10;\n    let b02 = a00 * a13 - a03 * a10;\n    let b03 = a01 * a12 - a02 * a11;\n    let b04 = a01 * a13 - a03 * a11;\n    let b05 = a02 * a13 - a03 * a12;\n    let b06 = a20 * a31 - a21 * a30;\n    let b07 = a20 * a32 - a22 * a30;\n    let b08 = a20 * a33 - a23 * a30;\n    let b09 = a21 * a32 - a22 * a31;\n    let b10 = a21 * a33 - a23 * a31;\n    let b11 = a22 * a33 - a23 * a32;\n\n    // Calculate the determinant\n    let det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\n\n    if (!det) {\n        return null;\n    }\n    det = 1.0 / det;\n\n    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;\n    out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;\n    out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;\n\n    out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;\n    out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;\n    out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;\n\n    out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;\n    out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;\n    out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;\n\n    return out;\n}\n\n/**\n * Generates a 2D projection matrix with the given bounds\n *\n * @param {mat3} out mat3 frustum matrix will be written into\n * @param {number} width Width of your gl context\n * @param {number} height Height of gl context\n * @returns {mat3} out\n */\nexport function projection(out, width, height) {\n    out[0] = 2 / width;\n    out[1] = 0;\n    out[2] = 0;\n    out[3] = 0;\n    out[4] = -2 / height;\n    out[5] = 0;\n    out[6] = -1;\n    out[7] = 1;\n    out[8] = 1;\n    return out;\n}\n\n/**\n * Adds two mat3's\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the first operand\n * @param {mat3} b the second operand\n * @returns {mat3} out\n */\nexport function add(out, a, b) {\n    out[0] = a[0] + b[0];\n    out[1] = a[1] + b[1];\n    out[2] = a[2] + b[2];\n    out[3] = a[3] + b[3];\n    out[4] = a[4] + b[4];\n    out[5] = a[5] + b[5];\n    out[6] = a[6] + b[6];\n    out[7] = a[7] + b[7];\n    out[8] = a[8] + b[8];\n    return out;\n}\n\n/**\n * Subtracts matrix b from matrix a\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the first operand\n * @param {mat3} b the second operand\n * @returns {mat3} out\n */\nexport function subtract(out, a, b) {\n    out[0] = a[0] - b[0];\n    out[1] = a[1] - b[1];\n    out[2] = a[2] - b[2];\n    out[3] = a[3] - b[3];\n    out[4] = a[4] - b[4];\n    out[5] = a[5] - b[5];\n    out[6] = a[6] - b[6];\n    out[7] = a[7] - b[7];\n    out[8] = a[8] - b[8];\n    return out;\n}\n\n/**\n * Multiply each element of the matrix by a scalar.\n *\n * @param {mat3} out the receiving matrix\n * @param {mat3} a the matrix to scale\n * @param {Number} b amount to scale the matrix's elements by\n * @returns {mat3} out\n */\nexport function multiplyScalar(out, a, b) {\n    out[0] = a[0] * b;\n    out[1] = a[1] * b;\n    out[2] = a[2] * b;\n    out[3] = a[3] * b;\n    out[4] = a[4] * b;\n    out[5] = a[5] * b;\n    out[6] = a[6] * b;\n    out[7] = a[7] * b;\n    out[8] = a[8] * b;\n    return out;\n}\n", "import * as Mat3Func from './functions/Mat3Func.js';\n\nexport class Mat3 extends Array {\n    constructor(m00 = 1, m01 = 0, m02 = 0, m10 = 0, m11 = 1, m12 = 0, m20 = 0, m21 = 0, m22 = 1) {\n        super(m00, m01, m02, m10, m11, m12, m20, m21, m22);\n        return this;\n    }\n\n    set(m00, m01, m02, m10, m11, m12, m20, m21, m22) {\n        if (m00.length) return this.copy(m00);\n        Mat3Func.set(this, m00, m01, m02, m10, m11, m12, m20, m21, m22);\n        return this;\n    }\n\n    translate(v, m = this) {\n        Mat3Func.translate(this, m, v);\n        return this;\n    }\n\n    rotate(v, m = this) {\n        Mat3Func.rotate(this, m, v);\n        return this;\n    }\n\n    scale(v, m = this) {\n        Mat3Func.scale(this, m, v);\n        return this;\n    }\n\n    multiply(ma, mb) {\n        if (mb) {\n            Mat3Func.multiply(this, ma, mb);\n        } else {\n            Mat3Func.multiply(this, this, ma);\n        }\n        return this;\n    }\n\n    identity() {\n        Mat3Func.identity(this);\n        return this;\n    }\n\n    copy(m) {\n        Mat3Func.copy(this, m);\n        return this;\n    }\n\n    fromMatrix4(m) {\n        Mat3Func.fromMat4(this, m);\n        return this;\n    }\n\n    fromQuaternion(q) {\n        Mat3Func.fromQuat(this, q);\n        return this;\n    }\n\n    fromBasis(vec3a, vec3b, vec3c) {\n        this.set(vec3a[0], vec3a[1], vec3a[2], vec3b[0], vec3b[1], vec3b[2], vec3c[0], vec3c[1], vec3c[2]);\n        return this;\n    }\n\n    inverse(m = this) {\n        Mat3Func.invert(this, m);\n        return this;\n    }\n\n    getNormalMatrix(m) {\n        Mat3Func.normalFromMat4(this, m);\n        return this;\n    }\n}\n", "import { Transform } from './Transform.js';\nimport { Mat3 } from '../math/Mat3.js';\nimport { Mat4 } from '../math/Mat4.js';\n\nlet ID = 0;\n\nexport class Mesh extends Transform {\n    constructor(gl, { geometry, program, mode = gl.TRIANGLES, frustumCulled = true, renderOrder = 0 } = {}) {\n        super();\n        if (!gl.canvas) console.error('gl not passed as first argument to Mesh');\n        this.gl = gl;\n        this.id = ID++;\n        this.geometry = geometry;\n        this.program = program;\n        this.mode = mode;\n\n        // Used to skip frustum culling\n        this.frustumCulled = frustumCulled;\n\n        // Override sorting to force an order\n        this.renderOrder = renderOrder;\n        this.modelViewMatrix = new Mat4();\n        this.normalMatrix = new Mat3();\n        this.beforeRenderCallbacks = [];\n        this.afterRenderCallbacks = [];\n    }\n\n    onBeforeRender(f) {\n        this.beforeRenderCallbacks.push(f);\n        return this;\n    }\n\n    onAfterRender(f) {\n        this.afterRenderCallbacks.push(f);\n        return this;\n    }\n\n    draw({ camera } = {}) {\n        if (camera) {\n            // Add empty matrix uniforms to program if unset\n            if (!this.program.uniforms.modelMatrix) {\n                Object.assign(this.program.uniforms, {\n                    modelMatrix: { value: null },\n                    viewMatrix: { value: null },\n                    modelViewMatrix: { value: null },\n                    normalMatrix: { value: null },\n                    projectionMatrix: { value: null },\n                    cameraPosition: { value: null },\n                });\n            }\n\n            // Set the matrix uniforms\n            this.program.uniforms.projectionMatrix.value = camera.projectionMatrix;\n            this.program.uniforms.cameraPosition.value = camera.worldPosition;\n            this.program.uniforms.viewMatrix.value = camera.viewMatrix;\n            this.modelViewMatrix.multiply(camera.viewMatrix, this.worldMatrix);\n            this.normalMatrix.getNormalMatrix(this.modelViewMatrix);\n            this.program.uniforms.modelMatrix.value = this.worldMatrix;\n            this.program.uniforms.modelViewMatrix.value = this.modelViewMatrix;\n            this.program.uniforms.normalMatrix.value = this.normalMatrix;\n        }\n        this.beforeRenderCallbacks.forEach((f) => f && f({ mesh: this, camera }));\n\n        // determine if faces need to be flipped - when mesh scaled negatively\n        let flipFaces = this.program.cullFace && this.worldMatrix.determinant() < 0;\n        this.program.use({ flipFaces });\n        this.geometry.draw({ mode: this.mode, program: this.program });\n        this.afterRenderCallbacks.forEach((f) => f && f({ mesh: this, camera }));\n    }\n}\n", "// TODO: delete texture\n// TODO: use texSubImage2D for updates (video or when loaded)\n// TODO: need? encoding = linearEncoding\n// TODO: support non-compressed mipmaps uploads\n\nconst emptyPixel = new Uint8Array(4);\n\nfunction isPowerOf2(value) {\n    return (value & (value - 1)) === 0;\n}\n\nlet ID = 1;\n\nexport class Texture {\n    constructor(\n        gl,\n        {\n            image,\n            target = gl.TEXTURE_2D,\n            type = gl.UNSIGNED_BYTE,\n            format = gl.RGBA,\n            internalFormat = format,\n            wrapS = gl.CLAMP_TO_EDGE,\n            wrapT = gl.CLAMP_TO_EDGE,\n            wrapR = gl.CLAMP_TO_EDGE,\n            generateMipmaps = target === (gl.TEXTURE_2D || gl.TEXTURE_CUBE_MAP),\n            minFilter = generateMipmaps ? gl.NEAREST_MIPMAP_LINEAR : gl.LINEAR,\n            magFilter = gl.LINEAR,\n            premultiplyAlpha = false,\n            unpackAlignment = 4,\n            flipY = target == (gl.TEXTURE_2D || gl.TEXTURE_3D) ? true : false,\n            anisotropy = 0,\n            level = 0,\n            width, // used for RenderTargets or Data Textures\n            height = width,\n            length = 1,\n        } = {}\n    ) {\n        this.gl = gl;\n        this.id = ID++;\n\n        this.image = image;\n        this.target = target;\n        this.type = type;\n        this.format = format;\n        this.internalFormat = internalFormat;\n        this.minFilter = minFilter;\n        this.magFilter = magFilter;\n        this.wrapS = wrapS;\n        this.wrapT = wrapT;\n        this.wrapR = wrapR;\n        this.generateMipmaps = generateMipmaps;\n        this.premultiplyAlpha = premultiplyAlpha;\n        this.unpackAlignment = unpackAlignment;\n        this.flipY = flipY;\n        this.anisotropy = Math.min(anisotropy, this.gl.renderer.parameters.maxAnisotropy);\n        this.level = level;\n        this.width = width;\n        this.height = height;\n        this.length = length;\n        this.texture = this.gl.createTexture();\n\n        this.store = {\n            image: null,\n        };\n\n        // Alias for state store to avoid redundant calls for global state\n        this.glState = this.gl.renderer.state;\n\n        // State store to avoid redundant calls for per-texture state\n        this.state = {};\n        this.state.minFilter = this.gl.NEAREST_MIPMAP_LINEAR;\n        this.state.magFilter = this.gl.LINEAR;\n        this.state.wrapS = this.gl.REPEAT;\n        this.state.wrapT = this.gl.REPEAT;\n        this.state.anisotropy = 0;\n    }\n\n    bind() {\n        // Already bound to active texture unit\n        if (this.glState.textureUnits[this.glState.activeTextureUnit] === this.id) return;\n        this.gl.bindTexture(this.target, this.texture);\n        this.glState.textureUnits[this.glState.activeTextureUnit] = this.id;\n    }\n\n    update(textureUnit = 0) {\n        const needsUpdate = !(this.image === this.store.image && !this.needsUpdate);\n\n        // Make sure that texture is bound to its texture unit\n        if (needsUpdate || this.glState.textureUnits[textureUnit] !== this.id) {\n            // set active texture unit to perform texture functions\n            this.gl.renderer.activeTexture(textureUnit);\n            this.bind();\n        }\n\n        if (!needsUpdate) return;\n        this.needsUpdate = false;\n\n        if (this.flipY !== this.glState.flipY) {\n            this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, this.flipY);\n            this.glState.flipY = this.flipY;\n        }\n\n        if (this.premultiplyAlpha !== this.glState.premultiplyAlpha) {\n            this.gl.pixelStorei(this.gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, this.premultiplyAlpha);\n            this.glState.premultiplyAlpha = this.premultiplyAlpha;\n        }\n\n        if (this.unpackAlignment !== this.glState.unpackAlignment) {\n            this.gl.pixelStorei(this.gl.UNPACK_ALIGNMENT, this.unpackAlignment);\n            this.glState.unpackAlignment = this.unpackAlignment;\n        }\n\n        if (this.minFilter !== this.state.minFilter) {\n            this.gl.texParameteri(this.target, this.gl.TEXTURE_MIN_FILTER, this.minFilter);\n            this.state.minFilter = this.minFilter;\n        }\n\n        if (this.magFilter !== this.state.magFilter) {\n            this.gl.texParameteri(this.target, this.gl.TEXTURE_MAG_FILTER, this.magFilter);\n            this.state.magFilter = this.magFilter;\n        }\n\n        if (this.wrapS !== this.state.wrapS) {\n            this.gl.texParameteri(this.target, this.gl.TEXTURE_WRAP_S, this.wrapS);\n            this.state.wrapS = this.wrapS;\n        }\n\n        if (this.wrapT !== this.state.wrapT) {\n            this.gl.texParameteri(this.target, this.gl.TEXTURE_WRAP_T, this.wrapT);\n            this.state.wrapT = this.wrapT;\n        }\n\n        if (this.wrapR !== this.state.wrapR) {\n            this.gl.texParameteri(this.target, this.gl.TEXTURE_WRAP_R, this.wrapR);\n            this.state.wrapR = this.wrapR;\n        }\n\n        if (this.anisotropy && this.anisotropy !== this.state.anisotropy) {\n            this.gl.texParameterf(this.target, this.gl.renderer.getExtension('EXT_texture_filter_anisotropic').TEXTURE_MAX_ANISOTROPY_EXT, this.anisotropy);\n            this.state.anisotropy = this.anisotropy;\n        }\n\n        if (this.image) {\n            if (this.image.width) {\n                this.width = this.image.width;\n                this.height = this.image.height;\n            }\n\n            if (this.target === this.gl.TEXTURE_CUBE_MAP) {\n                // For cube maps\n                for (let i = 0; i < 6; i++) {\n                    this.gl.texImage2D(this.gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, this.level, this.internalFormat, this.format, this.type, this.image[i]);\n                }\n            } else if (ArrayBuffer.isView(this.image)) {\n                // Data texture\n                if (this.target === this.gl.TEXTURE_2D) {\n                    this.gl.texImage2D(this.target, this.level, this.internalFormat, this.width, this.height, 0, this.format, this.type, this.image);\n                } else if (this.target === this.gl.TEXTURE_2D_ARRAY || this.target === this.gl.TEXTURE_3D) {\n                    this.gl.texImage3D(this.target, this.level, this.internalFormat, this.width, this.height, this.length, 0, this.format, this.type, this.image);\n                }\n            } else if (this.image.isCompressedTexture) {\n                // Compressed texture\n                for (let level = 0; level < this.image.length; level++) {\n                    this.gl.compressedTexImage2D(this.target, level, this.internalFormat, this.image[level].width, this.image[level].height, 0, this.image[level].data);\n                }\n            } else {\n                // Regular texture\n                if (this.target === this.gl.TEXTURE_2D) {\n                    this.gl.texImage2D(this.target, this.level, this.internalFormat, this.format, this.type, this.image);\n                } else {\n                    this.gl.texImage3D(this.target, this.level, this.internalFormat, this.width, this.height, this.length, 0, this.format, this.type, this.image);\n                }\n            }\n\n            if (this.generateMipmaps) {\n                // For WebGL1, if not a power of 2, turn off mips, set wrapping to clamp to edge and minFilter to linear\n                if (!this.gl.renderer.isWebgl2 && (!isPowerOf2(this.image.width) || !isPowerOf2(this.image.height))) {\n                    this.generateMipmaps = false;\n                    this.wrapS = this.wrapT = this.gl.CLAMP_TO_EDGE;\n                    this.minFilter = this.gl.LINEAR;\n                } else {\n                    this.gl.generateMipmap(this.target);\n                }\n            }\n\n            // Callback for when data is pushed to GPU\n            this.onUpdate && this.onUpdate();\n        } else {\n            if (this.target === this.gl.TEXTURE_CUBE_MAP) {\n                // Upload empty pixel for each side while no image to avoid errors while image or video loading\n                for (let i = 0; i < 6; i++) {\n                    this.gl.texImage2D(this.gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, this.gl.RGBA, 1, 1, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, emptyPixel);\n                }\n            } else if (this.width) {\n                // image intentionally left null for RenderTarget\n                if (this.target === this.gl.TEXTURE_2D) {\n                    this.gl.texImage2D(this.target, this.level, this.internalFormat, this.width, this.height, 0, this.format, this.type, null);\n                } else {\n                    this.gl.texImage3D(this.target, this.level, this.internalFormat, this.width, this.height, this.length, 0, this.format, this.type, null);\n                }\n            } else {\n                // Upload empty pixel if no image to avoid errors while image or video loading\n                this.gl.texImage2D(this.target, 0, this.gl.RGBA, 1, 1, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, emptyPixel);\n            }\n        }\n        this.store.image = this.image;\n    }\n}", "const NAMES = {\n    black: '#000000',\n    white: '#ffffff',\n    red: '#ff0000',\n    green: '#00ff00',\n    blue: '#0000ff',\n    fuchsia: '#ff00ff',\n    cyan: '#00ffff',\n    yellow: '#ffff00',\n    orange: '#ff8000',\n};\n\nexport function hexToRGB(hex) {\n    if (hex.length === 4) hex = hex[0] + hex[1] + hex[1] + hex[2] + hex[2] + hex[3] + hex[3];\n    const rgb = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n    if (!rgb) console.warn(`Unable to convert hex string ${hex} to rgb values`);\n    return [parseInt(rgb[1], 16) / 255, parseInt(rgb[2], 16) / 255, parseInt(rgb[3], 16) / 255];\n}\n\nexport function numberToRGB(num) {\n    num = parseInt(num);\n    return [((num >> 16) & 255) / 255, ((num >> 8) & 255) / 255, (num & 255) / 255];\n}\n\nexport function parseColor(color) {\n    // Empty\n    if (color === undefined) return [0, 0, 0];\n\n    // Decimal\n    if (arguments.length === 3) return arguments;\n\n    // Number\n    if (!isNaN(color)) return numberToRGB(color);\n\n    // Hex\n    if (color[0] === '#') return hexToRGB(color);\n\n    // Names\n    if (NAMES[color.toLowerCase()]) return hexToRGB(NAMES[color.toLowerCase()]);\n\n    console.warn('Color format not recognised');\n    return [0, 0, 0];\n}\n", "import * as ColorFunc from './functions/ColorFunc.js';\n\n// Color stored as an array of RGB decimal values (between 0 > 1)\n// Constructor and set method accept following formats:\n// new Color() - Empty (defaults to black)\n// new Color([0.2, 0.4, 1.0]) - Decimal Array (or another Color instance)\n// new Color(0.7, 0.0, 0.1) - Decimal RGB values\n// new Color('#ff0000') - Hex string\n// new Color('#ccc') - Short-hand Hex string\n// new Color(0x4f27e8) - Number\n// new Color('red') - Color name string (short list in ColorFunc.js)\n\nexport class Color extends Array {\n    constructor(color) {\n        if (Array.isArray(color)) return super(...color);\n        return super(...ColorFunc.parseColor(...arguments));\n    }\n\n    get r() {\n        return this[0];\n    }\n\n    get g() {\n        return this[1];\n    }\n\n    get b() {\n        return this[2];\n    }\n\n    set r(v) {\n        this[0] = v;\n    }\n\n    set g(v) {\n        this[1] = v;\n    }\n\n    set b(v) {\n        this[2] = v;\n    }\n\n    set(color) {\n        if (Array.isArray(color)) return this.copy(color);\n        return this.copy(ColorFunc.parseColor(...arguments));\n    }\n\n    copy(v) {\n        this[0] = v[0];\n        this[1] = v[1];\n        this[2] = v[2];\n        return this;\n    }\n}\n", "const EPSILON = 0.000001;\n\n/**\n * Copy the values from one vec2 to another\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the source vector\n * @returns {vec2} out\n */\nexport function copy(out, a) {\n    out[0] = a[0];\n    out[1] = a[1];\n    return out;\n}\n\n/**\n * Set the components of a vec2 to the given values\n *\n * @param {vec2} out the receiving vector\n * @param {Number} x X component\n * @param {Number} y Y component\n * @returns {vec2} out\n */\nexport function set(out, x, y) {\n    out[0] = x;\n    out[1] = y;\n    return out;\n}\n\n/**\n * Adds two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {vec2} out\n */\nexport function add(out, a, b) {\n    out[0] = a[0] + b[0];\n    out[1] = a[1] + b[1];\n    return out;\n}\n\n/**\n * Subtracts vector b from vector a\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {vec2} out\n */\nexport function subtract(out, a, b) {\n    out[0] = a[0] - b[0];\n    out[1] = a[1] - b[1];\n    return out;\n}\n\n/**\n * Multiplies two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {vec2} out\n */\nexport function multiply(out, a, b) {\n    out[0] = a[0] * b[0];\n    out[1] = a[1] * b[1];\n    return out;\n}\n\n/**\n * Divides two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {vec2} out\n */\nexport function divide(out, a, b) {\n    out[0] = a[0] / b[0];\n    out[1] = a[1] / b[1];\n    return out;\n}\n\n/**\n * Scales a vec2 by a scalar number\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @returns {vec2} out\n */\nexport function scale(out, a, b) {\n    out[0] = a[0] * b;\n    out[1] = a[1] * b;\n    return out;\n}\n\n/**\n * Calculates the euclidian distance between two vec2's\n *\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {Number} distance between a and b\n */\nexport function distance(a, b) {\n    var x = b[0] - a[0],\n        y = b[1] - a[1];\n    return Math.sqrt(x * x + y * y);\n}\n\n/**\n * Calculates the squared euclidian distance between two vec2's\n *\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {Number} squared distance between a and b\n */\nexport function squaredDistance(a, b) {\n    var x = b[0] - a[0],\n        y = b[1] - a[1];\n    return x * x + y * y;\n}\n\n/**\n * Calculates the length of a vec2\n *\n * @param {vec2} a vector to calculate length of\n * @returns {Number} length of a\n */\nexport function length(a) {\n    var x = a[0],\n        y = a[1];\n    return Math.sqrt(x * x + y * y);\n}\n\n/**\n * Calculates the squared length of a vec2\n *\n * @param {vec2} a vector to calculate squared length of\n * @returns {Number} squared length of a\n */\nexport function squaredLength(a) {\n    var x = a[0],\n        y = a[1];\n    return x * x + y * y;\n}\n\n/**\n * Negates the components of a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a vector to negate\n * @returns {vec2} out\n */\nexport function negate(out, a) {\n    out[0] = -a[0];\n    out[1] = -a[1];\n    return out;\n}\n\n/**\n * Returns the inverse of the components of a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a vector to invert\n * @returns {vec2} out\n */\nexport function inverse(out, a) {\n    out[0] = 1.0 / a[0];\n    out[1] = 1.0 / a[1];\n    return out;\n}\n\n/**\n * Normalize a vec2\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a vector to normalize\n * @returns {vec2} out\n */\nexport function normalize(out, a) {\n    var x = a[0],\n        y = a[1];\n    var len = x * x + y * y;\n    if (len > 0) {\n        //TODO: evaluate use of glm_invsqrt here?\n        len = 1 / Math.sqrt(len);\n    }\n    out[0] = a[0] * len;\n    out[1] = a[1] * len;\n    return out;\n}\n\n/**\n * Calculates the dot product of two vec2's\n *\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {Number} dot product of a and b\n */\nexport function dot(a, b) {\n    return a[0] * b[0] + a[1] * b[1];\n}\n\n/**\n * Computes the cross product of two vec2's\n * Note that the cross product returns a scalar\n *\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @returns {Number} cross product of a and b\n */\nexport function cross(a, b) {\n    return a[0] * b[1] - a[1] * b[0];\n}\n\n/**\n * Performs a linear interpolation between two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @param {Number} t interpolation amount between the two inputs\n * @returns {vec2} out\n */\nexport function lerp(out, a, b, t) {\n    var ax = a[0],\n        ay = a[1];\n    out[0] = ax + t * (b[0] - ax);\n    out[1] = ay + t * (b[1] - ay);\n    return out;\n}\n\n/**\n * Performs a frame rate independant, linear interpolation between two vec2's\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the first operand\n * @param {vec2} b the second operand\n * @param {Number} decay decay constant for interpolation. useful range between 1 and 25, from slow to fast.\n * @param {Number} dt delta time\n * @returns {vec2} out\n */\nexport function smoothLerp(out, a, b, decay, dt) {\n    const exp = Math.exp(-decay * dt);\n    let ax = a[0];\n    let ay = a[1];\n\n    out[0] = b[0] + (ax - b[0]) * exp;\n    out[1] = b[1] + (ay - b[1]) * exp;\n    return out;\n}\n\n/**\n * Transforms the vec2 with a mat2\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the vector to transform\n * @param {mat2} m matrix to transform with\n * @returns {vec2} out\n */\nexport function transformMat2(out, a, m) {\n    var x = a[0],\n        y = a[1];\n    out[0] = m[0] * x + m[2] * y;\n    out[1] = m[1] * x + m[3] * y;\n    return out;\n}\n\n/**\n * Transforms the vec2 with a mat2d\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the vector to transform\n * @param {mat2d} m matrix to transform with\n * @returns {vec2} out\n */\nexport function transformMat2d(out, a, m) {\n    var x = a[0],\n        y = a[1];\n    out[0] = m[0] * x + m[2] * y + m[4];\n    out[1] = m[1] * x + m[3] * y + m[5];\n    return out;\n}\n\n/**\n * Transforms the vec2 with a mat3\n * 3rd vector component is implicitly '1'\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the vector to transform\n * @param {mat3} m matrix to transform with\n * @returns {vec2} out\n */\nexport function transformMat3(out, a, m) {\n    var x = a[0],\n        y = a[1];\n    out[0] = m[0] * x + m[3] * y + m[6];\n    out[1] = m[1] * x + m[4] * y + m[7];\n    return out;\n}\n\n/**\n * Transforms the vec2 with a mat4\n * 3rd vector component is implicitly '0'\n * 4th vector component is implicitly '1'\n *\n * @param {vec2} out the receiving vector\n * @param {vec2} a the vector to transform\n * @param {mat4} m matrix to transform with\n * @returns {vec2} out\n */\nexport function transformMat4(out, a, m) {\n    let x = a[0];\n    let y = a[1];\n    out[0] = m[0] * x + m[4] * y + m[12];\n    out[1] = m[1] * x + m[5] * y + m[13];\n    return out;\n}\n\n/**\n * Returns whether or not the vectors exactly have the same elements in the same position (when compared with ===)\n *\n * @param {vec2} a The first vector.\n * @param {vec2} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\nexport function exactEquals(a, b) {\n    return a[0] === b[0] && a[1] === b[1];\n}\n", "import * as Vec2Func from './functions/Vec2Func.js';\n\nexport class Vec2 extends Array {\n    constructor(x = 0, y = x) {\n        super(x, y);\n        return this;\n    }\n\n    get x() {\n        return this[0];\n    }\n\n    get y() {\n        return this[1];\n    }\n\n    set x(v) {\n        this[0] = v;\n    }\n\n    set y(v) {\n        this[1] = v;\n    }\n\n    set(x, y = x) {\n        if (x.length) return this.copy(x);\n        Vec2Func.set(this, x, y);\n        return this;\n    }\n\n    copy(v) {\n        Vec2Func.copy(this, v);\n        return this;\n    }\n\n    add(va, vb) {\n        if (vb) Vec2Func.add(this, va, vb);\n        else Vec2Func.add(this, this, va);\n        return this;\n    }\n\n    sub(va, vb) {\n        if (vb) Vec2Func.subtract(this, va, vb);\n        else Vec2Func.subtract(this, this, va);\n        return this;\n    }\n\n    multiply(v) {\n        if (v.length) Vec2Func.multiply(this, this, v);\n        else Vec2Func.scale(this, this, v);\n        return this;\n    }\n\n    divide(v) {\n        if (v.length) Vec2Func.divide(this, this, v);\n        else Vec2Func.scale(this, this, 1 / v);\n        return this;\n    }\n\n    inverse(v = this) {\n        Vec2Func.inverse(this, v);\n        return this;\n    }\n\n    // Can't use 'length' as Array.prototype uses it\n    len() {\n        return Vec2Func.length(this);\n    }\n\n    distance(v) {\n        if (v) return Vec2Func.distance(this, v);\n        else return Vec2Func.length(this);\n    }\n\n    squaredLen() {\n        return this.squaredDistance();\n    }\n\n    squaredDistance(v) {\n        if (v) return Vec2Func.squaredDistance(this, v);\n        else return Vec2Func.squaredLength(this);\n    }\n\n    negate(v = this) {\n        Vec2Func.negate(this, v);\n        return this;\n    }\n\n    cross(va, vb) {\n        if (vb) return Vec2Func.cross(va, vb);\n        return Vec2Func.cross(this, va);\n    }\n\n    scale(v) {\n        Vec2Func.scale(this, this, v);\n        return this;\n    }\n\n    normalize() {\n        Vec2Func.normalize(this, this);\n        return this;\n    }\n\n    dot(v) {\n        return Vec2Func.dot(this, v);\n    }\n\n    equals(v) {\n        return Vec2Func.exactEquals(this, v);\n    }\n\n    applyMatrix3(mat3) {\n        Vec2Func.transformMat3(this, this, mat3);\n        return this;\n    }\n\n    applyMatrix4(mat4) {\n        Vec2Func.transformMat4(this, this, mat4);\n        return this;\n    }\n\n    lerp(v, a) {\n        Vec2Func.lerp(this, this, v, a);\n        return this;\n    }\n\n    smoothLerp(v, decay, dt) {\n        Vec2Func.smoothLerp(this, this, v, decay, dt);\n        return this;\n    }\n\n    clone() {\n        return new Vec2(this[0], this[1]);\n    }\n\n    fromArray(a, o = 0) {\n        this[0] = a[o];\n        this[1] = a[o + 1];\n        return this;\n    }\n\n    toArray(a = [], o = 0) {\n        a[o] = this[0];\n        a[o + 1] = this[1];\n        return a;\n    }\n}\n", "import { Geometry } from '../core/Geometry.js';\n\nexport class Triangle extends Geometry {\n    constructor(gl, { attributes = {} } = {}) {\n        Object.assign(attributes, {\n            position: { size: 2, data: new Float32Array([-1, -1, 3, -1, -1, 3]) },\n            uv: { size: 2, data: new Float32Array([0, 0, 2, 0, 0, 2]) },\n        });\n\n        super(gl, attributes);\n    }\n}\n", "// Based from ThreeJS' OrbitControls class, rewritten using es6 with some additions and subtractions.\n// TODO: abstract event handlers so can be fed from other sources\n// TODO: make scroll zoom more accurate than just >/< zero\n// TODO: be able to pass in new camera position\n\nimport { Vec3 } from '../math/Vec3.js';\nimport { Vec2 } from '../math/Vec2.js';\n\nconst STATE = { NONE: -1, ROTATE: 0, DOLLY: 1, PAN: 2, DOLLY_PAN: 3 };\nconst tempVec3 = /* @__PURE__ */ new Vec3();\nconst tempVec2a = /* @__PURE__ */ new Vec2();\nconst tempVec2b = /* @__PURE__ */ new Vec2();\n\nexport function Orbit(\n    object,\n    {\n        element = document,\n        enabled = true,\n        target = new Vec3(),\n        ease = 0.25,\n        inertia = 0.85,\n        enableRotate = true,\n        rotateSpeed = 0.1,\n        autoRotate = false,\n        autoRotateSpeed = 1.0,\n        enableZoom = true,\n        zoomSpeed = 1,\n        zoomStyle = 'dolly',\n        enablePan = true,\n        panSpeed = 0.1,\n        minPolarAngle = 0,\n        maxPolarAngle = Math.PI,\n        minAzimuthAngle = -Infinity,\n        maxAzimuthAngle = Infinity,\n        minDistance = 0,\n        maxDistance = Infinity,\n    } = {}\n) {\n    this.enabled = enabled;\n    this.target = target;\n    this.zoomStyle = zoomStyle;\n\n    // Catch attempts to disable - set to 1 so has no effect\n    ease = ease || 1;\n    inertia = inertia || 0;\n\n    this.minDistance = minDistance;\n    this.maxDistance = maxDistance;\n\n    // current position in sphericalTarget coordinates\n    const sphericalDelta = { radius: 1, phi: 0, theta: 0 };\n    const sphericalTarget = { radius: 1, phi: 0, theta: 0 };\n    const spherical = { radius: 1, phi: 0, theta: 0 };\n    const panDelta = new Vec3();\n\n    // Grab initial position values\n    const offset = new Vec3();\n    offset.copy(object.position).sub(this.target);\n    spherical.radius = sphericalTarget.radius = offset.distance();\n    spherical.theta = sphericalTarget.theta = Math.atan2(offset.x, offset.z);\n    spherical.phi = sphericalTarget.phi = Math.acos(Math.min(Math.max(offset.y / sphericalTarget.radius, -1), 1));\n\n    this.offset = offset;\n\n    this.update = () => {\n        if (autoRotate) {\n            handleAutoRotate();\n        }\n\n        // apply delta\n        sphericalTarget.radius *= sphericalDelta.radius;\n        sphericalTarget.theta += sphericalDelta.theta;\n        sphericalTarget.phi += sphericalDelta.phi;\n\n        // apply boundaries\n        sphericalTarget.theta = Math.max(minAzimuthAngle, Math.min(maxAzimuthAngle, sphericalTarget.theta));\n        sphericalTarget.phi = Math.max(minPolarAngle, Math.min(maxPolarAngle, sphericalTarget.phi));\n        sphericalTarget.radius = Math.max(this.minDistance, Math.min(this.maxDistance, sphericalTarget.radius));\n\n        // ease values\n        spherical.phi += (sphericalTarget.phi - spherical.phi) * ease;\n        spherical.theta += (sphericalTarget.theta - spherical.theta) * ease;\n        spherical.radius += (sphericalTarget.radius - spherical.radius) * ease;\n\n        // apply pan to target. As offset is relative to target, it also shifts\n        this.target.add(panDelta);\n\n        // apply rotation to offset\n        let sinPhiRadius = spherical.radius * Math.sin(Math.max(0.000001, spherical.phi));\n        offset.x = sinPhiRadius * Math.sin(spherical.theta);\n        offset.y = spherical.radius * Math.cos(spherical.phi);\n        offset.z = sinPhiRadius * Math.cos(spherical.theta);\n\n        // Apply updated values to object\n        object.position.copy(this.target).add(offset);\n        object.lookAt(this.target);\n\n        // Apply inertia to values\n        sphericalDelta.theta *= inertia;\n        sphericalDelta.phi *= inertia;\n        panDelta.multiply(inertia);\n\n        // Reset scale every frame to avoid applying scale multiple times\n        sphericalDelta.radius = 1;\n    };\n\n    // Updates internals with new position\n    this.forcePosition = () => {\n        offset.copy(object.position).sub(this.target);\n        spherical.radius = sphericalTarget.radius = offset.distance();\n        spherical.theta = sphericalTarget.theta = Math.atan2(offset.x, offset.z);\n        spherical.phi = sphericalTarget.phi = Math.acos(Math.min(Math.max(offset.y / sphericalTarget.radius, -1), 1));\n        object.lookAt(this.target);\n    };\n\n    // Everything below here just updates panDelta and sphericalDelta\n    // Using those two objects' values, the orbit is calculated\n\n    const rotateStart = new Vec2();\n    const panStart = new Vec2();\n    const dollyStart = new Vec2();\n\n    let state = STATE.NONE;\n    this.mouseButtons = { ORBIT: 0, ZOOM: 1, PAN: 2 };\n\n    function getZoomScale() {\n        return Math.pow(0.95, zoomSpeed);\n    }\n\n    function panLeft(distance, m) {\n        tempVec3.set(m[0], m[1], m[2]);\n        tempVec3.multiply(-distance);\n        panDelta.add(tempVec3);\n    }\n\n    function panUp(distance, m) {\n        tempVec3.set(m[4], m[5], m[6]);\n        tempVec3.multiply(distance);\n        panDelta.add(tempVec3);\n    }\n\n    const pan = (deltaX, deltaY) => {\n        let el = element === document ? document.body : element;\n        tempVec3.copy(object.position).sub(this.target);\n        let targetDistance = tempVec3.distance();\n        targetDistance *= Math.tan((((object.fov || 45) / 2) * Math.PI) / 180.0);\n        panLeft((2 * deltaX * targetDistance) / el.clientHeight, object.matrix);\n        panUp((2 * deltaY * targetDistance) / el.clientHeight, object.matrix);\n    };\n\n    const dolly = (dollyScale) => {\n        if (this.zoomStyle === 'dolly') sphericalDelta.radius /= dollyScale;\n        else {\n            object.fov /= dollyScale;\n            if (object.type === 'orthographic') object.orthographic();\n            else object.perspective();\n        }\n    };\n\n    function handleAutoRotate() {\n        const angle = ((2 * Math.PI) / 60 / 60) * autoRotateSpeed;\n        sphericalDelta.theta -= angle;\n    }\n\n    function handleMoveRotate(x, y) {\n        tempVec2a.set(x, y);\n        tempVec2b.sub(tempVec2a, rotateStart).multiply(rotateSpeed);\n        let el = element === document ? document.body : element;\n        sphericalDelta.theta -= (2 * Math.PI * tempVec2b.x) / el.clientHeight;\n        sphericalDelta.phi -= (2 * Math.PI * tempVec2b.y) / el.clientHeight;\n        rotateStart.copy(tempVec2a);\n    }\n\n    function handleMouseMoveDolly(e) {\n        tempVec2a.set(e.clientX, e.clientY);\n        tempVec2b.sub(tempVec2a, dollyStart);\n        if (tempVec2b.y > 0) {\n            dolly(getZoomScale());\n        } else if (tempVec2b.y < 0) {\n            dolly(1 / getZoomScale());\n        }\n        dollyStart.copy(tempVec2a);\n    }\n\n    function handleMovePan(x, y) {\n        tempVec2a.set(x, y);\n        tempVec2b.sub(tempVec2a, panStart).multiply(panSpeed);\n        pan(tempVec2b.x, tempVec2b.y);\n        panStart.copy(tempVec2a);\n    }\n\n    function handleTouchStartDollyPan(e) {\n        if (enableZoom) {\n            let dx = e.touches[0].pageX - e.touches[1].pageX;\n            let dy = e.touches[0].pageY - e.touches[1].pageY;\n            let distance = Math.sqrt(dx * dx + dy * dy);\n            dollyStart.set(0, distance);\n        }\n\n        if (enablePan) {\n            let x = 0.5 * (e.touches[0].pageX + e.touches[1].pageX);\n            let y = 0.5 * (e.touches[0].pageY + e.touches[1].pageY);\n            panStart.set(x, y);\n        }\n    }\n\n    function handleTouchMoveDollyPan(e) {\n        if (enableZoom) {\n            let dx = e.touches[0].pageX - e.touches[1].pageX;\n            let dy = e.touches[0].pageY - e.touches[1].pageY;\n            let distance = Math.sqrt(dx * dx + dy * dy);\n            tempVec2a.set(0, distance);\n            tempVec2b.set(0, Math.pow(tempVec2a.y / dollyStart.y, zoomSpeed));\n            dolly(tempVec2b.y);\n            dollyStart.copy(tempVec2a);\n        }\n\n        if (enablePan) {\n            let x = 0.5 * (e.touches[0].pageX + e.touches[1].pageX);\n            let y = 0.5 * (e.touches[0].pageY + e.touches[1].pageY);\n            handleMovePan(x, y);\n        }\n    }\n\n    const onMouseDown = (e) => {\n        if (!this.enabled) return;\n\n        switch (e.button) {\n            case this.mouseButtons.ORBIT:\n                if (enableRotate === false) return;\n                rotateStart.set(e.clientX, e.clientY);\n                state = STATE.ROTATE;\n                break;\n            case this.mouseButtons.ZOOM:\n                if (enableZoom === false) return;\n                dollyStart.set(e.clientX, e.clientY);\n                state = STATE.DOLLY;\n                break;\n            case this.mouseButtons.PAN:\n                if (enablePan === false) return;\n                panStart.set(e.clientX, e.clientY);\n                state = STATE.PAN;\n                break;\n        }\n\n        if (state !== STATE.NONE) {\n            window.addEventListener('mousemove', onMouseMove, false);\n            window.addEventListener('mouseup', onMouseUp, false);\n        }\n    };\n\n    const onMouseMove = (e) => {\n        if (!this.enabled) return;\n\n        switch (state) {\n            case STATE.ROTATE:\n                if (enableRotate === false) return;\n                handleMoveRotate(e.clientX, e.clientY);\n                break;\n            case STATE.DOLLY:\n                if (enableZoom === false) return;\n                handleMouseMoveDolly(e);\n                break;\n            case STATE.PAN:\n                if (enablePan === false) return;\n                handleMovePan(e.clientX, e.clientY);\n                break;\n        }\n    };\n\n    const onMouseUp = () => {\n        window.removeEventListener('mousemove', onMouseMove, false);\n        window.removeEventListener('mouseup', onMouseUp, false);\n        state = STATE.NONE;\n    };\n\n    const onMouseWheel = (e) => {\n        if (!this.enabled || !enableZoom || (state !== STATE.NONE && state !== STATE.ROTATE)) return;\n        e.stopPropagation();\n        e.preventDefault();\n\n        if (e.deltaY < 0) {\n            dolly(1 / getZoomScale());\n        } else if (e.deltaY > 0) {\n            dolly(getZoomScale());\n        }\n    };\n\n    const onTouchStart = (e) => {\n        if (!this.enabled) return;\n        e.preventDefault();\n\n        switch (e.touches.length) {\n            case 1:\n                if (enableRotate === false) return;\n                rotateStart.set(e.touches[0].pageX, e.touches[0].pageY);\n                state = STATE.ROTATE;\n                break;\n            case 2:\n                if (enableZoom === false && enablePan === false) return;\n                handleTouchStartDollyPan(e);\n                state = STATE.DOLLY_PAN;\n                break;\n            default:\n                state = STATE.NONE;\n        }\n    };\n\n    const onTouchMove = (e) => {\n        if (!this.enabled) return;\n        e.preventDefault();\n        e.stopPropagation();\n\n        switch (e.touches.length) {\n            case 1:\n                if (enableRotate === false) return;\n                handleMoveRotate(e.touches[0].pageX, e.touches[0].pageY);\n                break;\n            case 2:\n                if (enableZoom === false && enablePan === false) return;\n                handleTouchMoveDollyPan(e);\n                break;\n            default:\n                state = STATE.NONE;\n        }\n    };\n\n    const onTouchEnd = () => {\n        if (!this.enabled) return;\n        state = STATE.NONE;\n    };\n\n    const onContextMenu = (e) => {\n        if (!this.enabled) return;\n        e.preventDefault();\n    };\n\n    function addHandlers() {\n        element.addEventListener('contextmenu', onContextMenu, false);\n        element.addEventListener('mousedown', onMouseDown, false);\n        element.addEventListener('wheel', onMouseWheel, { passive: false });\n        element.addEventListener('touchstart', onTouchStart, { passive: false });\n        element.addEventListener('touchend', onTouchEnd, false);\n        element.addEventListener('touchmove', onTouchMove, { passive: false });\n    }\n\n    this.remove = function () {\n        element.removeEventListener('contextmenu', onContextMenu);\n        element.removeEventListener('mousedown', onMouseDown);\n        element.removeEventListener('wheel', onMouseWheel);\n        element.removeEventListener('touchstart', onTouchStart);\n        element.removeEventListener('touchend', onTouchEnd);\n        element.removeEventListener('touchmove', onTouchMove);\n        window.removeEventListener('mousemove', onMouseMove);\n        window.removeEventListener('mouseup', onMouseUp);\n    };\n\n    addHandlers();\n}\n", "// TODO: barycentric code shouldn't be here, but where?\n// TODO: SphereCast?\n\nimport { Vec2 } from '../math/Vec2.js';\nimport { Vec3 } from '../math/Vec3.js';\nimport { Mat4 } from '../math/Mat4.js';\n\nconst tempVec2a = /* @__PURE__ */ new Vec2();\nconst tempVec2b = /* @__PURE__ */ new Vec2();\nconst tempVec2c = /* @__PURE__ */ new Vec2();\n\nconst tempVec3a = /* @__PURE__ */ new Vec3();\nconst tempVec3b = /* @__PURE__ */ new Vec3();\nconst tempVec3c = /* @__PURE__ */ new Vec3();\nconst tempVec3d = /* @__PURE__ */ new Vec3();\nconst tempVec3e = /* @__PURE__ */ new Vec3();\nconst tempVec3f = /* @__PURE__ */ new Vec3();\nconst tempVec3g = /* @__PURE__ */ new Vec3();\nconst tempVec3h = /* @__PURE__ */ new Vec3();\nconst tempVec3i = /* @__PURE__ */ new Vec3();\nconst tempVec3j = /* @__PURE__ */ new Vec3();\nconst tempVec3k = /* @__PURE__ */ new Vec3();\n\nconst tempMat4 = /* @__PURE__ */ new Mat4();\n\nexport class Raycast {\n    constructor() {\n        this.origin = new Vec3();\n        this.direction = new Vec3();\n    }\n\n    // Set ray from mouse unprojection\n    castMouse(camera, mouse = [0, 0]) {\n        if (camera.type === 'orthographic') {\n            // Set origin\n            // Since camera is orthographic, origin is not the camera position\n            const { left, right, bottom, top, zoom } = camera;\n            const x = left / zoom + ((right - left) / zoom) * (mouse[0] * 0.5 + 0.5);\n            const y = bottom / zoom + ((top - bottom) / zoom) * (mouse[1] * 0.5 + 0.5);\n            this.origin.set(x, y, 0);\n            this.origin.applyMatrix4(camera.worldMatrix);\n\n            // Set direction\n            // https://community.khronos.org/t/get-direction-from-transformation-matrix-or-quat/65502/2\n            this.direction.x = -camera.worldMatrix[8];\n            this.direction.y = -camera.worldMatrix[9];\n            this.direction.z = -camera.worldMatrix[10];\n        } else {\n            // Set origin\n            camera.worldMatrix.getTranslation(this.origin);\n\n            // Set direction\n            this.direction.set(mouse[0], mouse[1], 0.5);\n            camera.unproject(this.direction);\n            this.direction.sub(this.origin).normalize();\n        }\n    }\n\n    intersectBounds(meshes, { maxDistance, output = [] } = {}) {\n        if (!Array.isArray(meshes)) meshes = [meshes];\n\n        const invWorldMat4 = tempMat4;\n        const origin = tempVec3a;\n        const direction = tempVec3b;\n\n        const hits = output;\n        hits.length = 0;\n\n        meshes.forEach((mesh) => {\n            // Create bounds\n            if (!mesh.geometry.bounds || mesh.geometry.bounds.radius === Infinity) mesh.geometry.computeBoundingSphere();\n            const bounds = mesh.geometry.bounds;\n            invWorldMat4.inverse(mesh.worldMatrix);\n\n            // Get max distance locally\n            let localMaxDistance;\n            if (maxDistance) {\n                direction.copy(this.direction).scaleRotateMatrix4(invWorldMat4);\n                localMaxDistance = maxDistance * direction.len();\n            }\n\n            // Take world space ray and make it object space to align with bounding box\n            origin.copy(this.origin).applyMatrix4(invWorldMat4);\n            direction.copy(this.direction).transformDirection(invWorldMat4);\n\n            // Break out early if bounds too far away from origin\n            if (maxDistance) {\n                if (origin.distance(bounds.center) - bounds.radius > localMaxDistance) return;\n            }\n\n            let localDistance = 0;\n\n            // Check origin isn't inside bounds before testing intersection\n            if (mesh.geometry.raycast === 'sphere') {\n                if (origin.distance(bounds.center) > bounds.radius) {\n                    localDistance = this.intersectSphere(bounds, origin, direction);\n                    if (!localDistance) return;\n                }\n            } else {\n                if (\n                    origin.x < bounds.min.x ||\n                    origin.x > bounds.max.x ||\n                    origin.y < bounds.min.y ||\n                    origin.y > bounds.max.y ||\n                    origin.z < bounds.min.z ||\n                    origin.z > bounds.max.z\n                ) {\n                    localDistance = this.intersectBox(bounds, origin, direction);\n                    if (!localDistance) return;\n                }\n            }\n\n            if (maxDistance && localDistance > localMaxDistance) return;\n\n            // Create object on mesh to avoid generating lots of objects\n            if (!mesh.hit) mesh.hit = { localPoint: new Vec3(), point: new Vec3() };\n\n            mesh.hit.localPoint.copy(direction).multiply(localDistance).add(origin);\n            mesh.hit.point.copy(mesh.hit.localPoint).applyMatrix4(mesh.worldMatrix);\n            mesh.hit.distance = mesh.hit.point.distance(this.origin);\n\n            hits.push(mesh);\n        });\n\n        hits.sort((a, b) => a.hit.distance - b.hit.distance);\n        return hits;\n    }\n\n    intersectMeshes(meshes, { cullFace = true, maxDistance, includeUV = true, includeNormal = true, output = [] } = {}) {\n        // Test bounds first before testing geometry\n        const hits = this.intersectBounds(meshes, { maxDistance, output });\n        if (!hits.length) return hits;\n\n        const invWorldMat4 = tempMat4;\n        const origin = tempVec3a;\n        const direction = tempVec3b;\n        const a = tempVec3c;\n        const b = tempVec3d;\n        const c = tempVec3e;\n        const closestFaceNormal = tempVec3f;\n        const faceNormal = tempVec3g;\n        const barycoord = tempVec3h;\n        const uvA = tempVec2a;\n        const uvB = tempVec2b;\n        const uvC = tempVec2c;\n\n        for (let i = hits.length - 1; i >= 0; i--) {\n            const mesh = hits[i];\n            invWorldMat4.inverse(mesh.worldMatrix);\n\n            // Get max distance locally\n            let localMaxDistance;\n            if (maxDistance) {\n                direction.copy(this.direction).scaleRotateMatrix4(invWorldMat4);\n                localMaxDistance = maxDistance * direction.len();\n            }\n\n            // Take world space ray and make it object space to align with bounding box\n            origin.copy(this.origin).applyMatrix4(invWorldMat4);\n            direction.copy(this.direction).transformDirection(invWorldMat4);\n\n            let localDistance = 0;\n            let closestA, closestB, closestC;\n\n            const geometry = mesh.geometry;\n            const attributes = geometry.attributes;\n            const index = attributes.index;\n            const position = attributes.position;\n\n            const start = Math.max(0, geometry.drawRange.start);\n            const end = Math.min(index ? index.count : position.count, geometry.drawRange.start + geometry.drawRange.count);\n            // Data loaded shouldn't haave stride, only buffers\n            // const stride = position.stride ? position.stride / position.data.BYTES_PER_ELEMENT : position.size;\n            const stride = position.size;\n\n            for (let j = start; j < end; j += 3) {\n                // Position attribute indices for each triangle\n                const ai = index ? index.data[j] : j;\n                const bi = index ? index.data[j + 1] : j + 1;\n                const ci = index ? index.data[j + 2] : j + 2;\n\n                a.fromArray(position.data, ai * stride);\n                b.fromArray(position.data, bi * stride);\n                c.fromArray(position.data, ci * stride);\n\n                const distance = this.intersectTriangle(a, b, c, cullFace, origin, direction, faceNormal);\n                if (!distance) continue;\n\n                // Too far away\n                if (maxDistance && distance > localMaxDistance) continue;\n\n                if (!localDistance || distance < localDistance) {\n                    localDistance = distance;\n                    closestA = ai;\n                    closestB = bi;\n                    closestC = ci;\n                    closestFaceNormal.copy(faceNormal);\n                }\n            }\n\n            if (!localDistance) hits.splice(i, 1);\n\n            // Update hit values from bounds-test\n            mesh.hit.localPoint.copy(direction).multiply(localDistance).add(origin);\n            mesh.hit.point.copy(mesh.hit.localPoint).applyMatrix4(mesh.worldMatrix);\n            mesh.hit.distance = mesh.hit.point.distance(this.origin);\n\n            // Add unique hit objects on mesh to avoid generating lots of objects\n            if (!mesh.hit.faceNormal) {\n                mesh.hit.localFaceNormal = new Vec3();\n                mesh.hit.faceNormal = new Vec3();\n                mesh.hit.uv = new Vec2();\n                mesh.hit.localNormal = new Vec3();\n                mesh.hit.normal = new Vec3();\n            }\n\n            // Add face normal data which is already computed\n            mesh.hit.localFaceNormal.copy(closestFaceNormal);\n            mesh.hit.faceNormal.copy(mesh.hit.localFaceNormal).transformDirection(mesh.worldMatrix);\n\n            // Optional data, opt out to optimise a bit if necessary\n            if (includeUV || includeNormal) {\n                // Calculate barycoords to find uv values at hit point\n                a.fromArray(position.data, closestA * 3);\n                b.fromArray(position.data, closestB * 3);\n                c.fromArray(position.data, closestC * 3);\n                this.getBarycoord(mesh.hit.localPoint, a, b, c, barycoord);\n            }\n\n            if (includeUV && attributes.uv) {\n                uvA.fromArray(attributes.uv.data, closestA * 2);\n                uvB.fromArray(attributes.uv.data, closestB * 2);\n                uvC.fromArray(attributes.uv.data, closestC * 2);\n                mesh.hit.uv.set(\n                    uvA.x * barycoord.x + uvB.x * barycoord.y + uvC.x * barycoord.z,\n                    uvA.y * barycoord.x + uvB.y * barycoord.y + uvC.y * barycoord.z\n                );\n            }\n\n            if (includeNormal && attributes.normal) {\n                a.fromArray(attributes.normal.data, closestA * 3);\n                b.fromArray(attributes.normal.data, closestB * 3);\n                c.fromArray(attributes.normal.data, closestC * 3);\n                mesh.hit.localNormal.set(\n                    a.x * barycoord.x + b.x * barycoord.y + c.x * barycoord.z,\n                    a.y * barycoord.x + b.y * barycoord.y + c.y * barycoord.z,\n                    a.z * barycoord.x + b.z * barycoord.y + c.z * barycoord.z\n                );\n\n                mesh.hit.normal.copy(mesh.hit.localNormal).transformDirection(mesh.worldMatrix);\n            }\n        }\n\n        hits.sort((a, b) => a.hit.distance - b.hit.distance);\n        return hits;\n    }\n\n    intersectPlane(plane, origin = this.origin, direction = this.direction) {\n        const xminp = tempVec3a;\n        xminp.sub(plane.origin, origin);\n\n        const a = xminp.dot(plane.normal);\n        const b = direction.dot(plane.normal);\n        // Assuming we don't want to count a ray parallel to the plane as intersecting\n        if (b == 0) return 0;\n        const delta = a / b;\n        if (delta <= 0) return 0;\n        return origin.add(direction.scale(delta));\n    }\n\n    intersectSphere(sphere, origin = this.origin, direction = this.direction) {\n        const ray = tempVec3c;\n        ray.sub(sphere.center, origin);\n        const tca = ray.dot(direction);\n        const d2 = ray.dot(ray) - tca * tca;\n        const radius2 = sphere.radius * sphere.radius;\n        if (d2 > radius2) return 0;\n        const thc = Math.sqrt(radius2 - d2);\n        const t0 = tca - thc;\n        const t1 = tca + thc;\n        if (t0 < 0 && t1 < 0) return 0;\n        if (t0 < 0) return t1;\n        return t0;\n    }\n\n    // Ray AABB - Ray Axis aligned bounding box testing\n    intersectBox(box, origin = this.origin, direction = this.direction) {\n        let tmin, tmax, tYmin, tYmax, tZmin, tZmax;\n        const invdirx = 1 / direction.x;\n        const invdiry = 1 / direction.y;\n        const invdirz = 1 / direction.z;\n        const min = box.min;\n        const max = box.max;\n        tmin = ((invdirx >= 0 ? min.x : max.x) - origin.x) * invdirx;\n        tmax = ((invdirx >= 0 ? max.x : min.x) - origin.x) * invdirx;\n        tYmin = ((invdiry >= 0 ? min.y : max.y) - origin.y) * invdiry;\n        tYmax = ((invdiry >= 0 ? max.y : min.y) - origin.y) * invdiry;\n        if (tmin > tYmax || tYmin > tmax) return 0;\n        if (tYmin > tmin) tmin = tYmin;\n        if (tYmax < tmax) tmax = tYmax;\n        tZmin = ((invdirz >= 0 ? min.z : max.z) - origin.z) * invdirz;\n        tZmax = ((invdirz >= 0 ? max.z : min.z) - origin.z) * invdirz;\n        if (tmin > tZmax || tZmin > tmax) return 0;\n        if (tZmin > tmin) tmin = tZmin;\n        if (tZmax < tmax) tmax = tZmax;\n        if (tmax < 0) return 0;\n        return tmin >= 0 ? tmin : tmax;\n    }\n\n    intersectTriangle(a, b, c, backfaceCulling = true, origin = this.origin, direction = this.direction, normal = tempVec3g) {\n        // from https://github.com/mrdoob/three.js/blob/master/src/math/Ray.js\n        // which is from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h\n        const edge1 = tempVec3h;\n        const edge2 = tempVec3i;\n        const diff = tempVec3j;\n        edge1.sub(b, a);\n        edge2.sub(c, a);\n        normal.cross(edge1, edge2);\n        let DdN = direction.dot(normal);\n        if (!DdN) return 0;\n        let sign;\n        if (DdN > 0) {\n            if (backfaceCulling) return 0;\n            sign = 1;\n        } else {\n            sign = -1;\n            DdN = -DdN;\n        }\n        diff.sub(origin, a);\n        let DdQxE2 = sign * direction.dot(edge2.cross(diff, edge2));\n        if (DdQxE2 < 0) return 0;\n        let DdE1xQ = sign * direction.dot(edge1.cross(diff));\n        if (DdE1xQ < 0) return 0;\n        if (DdQxE2 + DdE1xQ > DdN) return 0;\n        let QdN = -sign * diff.dot(normal);\n        if (QdN < 0) return 0;\n        return QdN / DdN;\n    }\n\n    getBarycoord(point, a, b, c, target = tempVec3h) {\n        // From https://github.com/mrdoob/three.js/blob/master/src/math/Triangle.js\n        // static/instance method to calculate barycentric coordinates\n        // based on: http://www.blackpawn.com/texts/pointinpoly/default.html\n        const v0 = tempVec3i;\n        const v1 = tempVec3j;\n        const v2 = tempVec3k;\n        v0.sub(c, a);\n        v1.sub(b, a);\n        v2.sub(point, a);\n        const dot00 = v0.dot(v0);\n        const dot01 = v0.dot(v1);\n        const dot02 = v0.dot(v2);\n        const dot11 = v1.dot(v1);\n        const dot12 = v1.dot(v2);\n        const denom = dot00 * dot11 - dot01 * dot01;\n        if (denom === 0) return target.set(-2, -1, -1);\n        const invDenom = 1 / denom;\n        const u = (dot11 * dot02 - dot01 * dot12) * invDenom;\n        const v = (dot00 * dot12 - dot01 * dot02) * invDenom;\n        return target.set(1 - u - v, v, u);\n    }\n}\n", "import { Vec3 } from '../math/Vec3.js';\n\nconst CATMULLROM = 'catmullrom';\nconst CUBICBEZIER = 'cubicbezier';\nconst QUADRATICBEZIER = 'quadraticbezier';\n\n// temp\nconst _a0 = /* @__PURE__ */ new Vec3(),\n    _a1 = /* @__PURE__ */ new Vec3(),\n    _a2 = /* @__PURE__ */ new Vec3(),\n    _a3 = /* @__PURE__ */ new Vec3();\n\n/**\n * Get the control points of cubic bezier curve.\n * @param {*} i\n * @param {*} a\n * @param {*} b\n */\nfunction getCtrlPoint(points, i, a = 0.168, b = 0.168) {\n    if (i < 1) {\n        _a0.sub(points[1], points[0]).scale(a).add(points[0]);\n    } else {\n        _a0.sub(points[i + 1], points[i - 1])\n            .scale(a)\n            .add(points[i]);\n    }\n    if (i > points.length - 3) {\n        const last = points.length - 1;\n        _a1.sub(points[last - 1], points[last])\n            .scale(b)\n            .add(points[last]);\n    } else {\n        _a1.sub(points[i], points[i + 2])\n            .scale(b)\n            .add(points[i + 1]);\n    }\n    return [_a0.clone(), _a1.clone()];\n}\n\nfunction getQuadraticBezierPoint(t, p0, c0, p1) {\n    const k = 1 - t;\n    _a0.copy(p0).scale(k ** 2);\n    _a1.copy(c0).scale(2 * k * t);\n    _a2.copy(p1).scale(t ** 2);\n    const ret = new Vec3();\n    ret.add(_a0, _a1).add(_a2);\n    return ret;\n}\n\nfunction getCubicBezierPoint(t, p0, c0, c1, p1) {\n    const k = 1 - t;\n    _a0.copy(p0).scale(k ** 3);\n    _a1.copy(c0).scale(3 * k ** 2 * t);\n    _a2.copy(c1).scale(3 * k * t ** 2);\n    _a3.copy(p1).scale(t ** 3);\n    const ret = new Vec3();\n    ret.add(_a0, _a1).add(_a2).add(_a3);\n    return ret;\n}\n\nexport class Curve {\n    constructor({ points = [new Vec3(0, 0, 0), new Vec3(0, 1, 0), new Vec3(1, 1, 0), new Vec3(1, 0, 0)], divisions = 12, type = CATMULLROM } = {}) {\n        this.points = points;\n        this.divisions = divisions;\n        this.type = type;\n    }\n\n    _getQuadraticBezierPoints(divisions = this.divisions) {\n        const points = [];\n        const count = this.points.length;\n\n        if (count < 3) {\n            console.warn('Not enough points provided.');\n            return [];\n        }\n\n        const p0 = this.points[0];\n        let c0 = this.points[1],\n            p1 = this.points[2];\n\n        for (let i = 0; i <= divisions; i++) {\n            const p = getQuadraticBezierPoint(i / divisions, p0, c0, p1);\n            points.push(p);\n        }\n\n        let offset = 3;\n        while (count - offset > 0) {\n            p0.copy(p1);\n            c0 = p1.scale(2).sub(c0);\n            p1 = this.points[offset];\n            for (let i = 1; i <= divisions; i++) {\n                const p = getQuadraticBezierPoint(i / divisions, p0, c0, p1);\n                points.push(p);\n            }\n            offset++;\n        }\n\n        return points;\n    }\n\n    _getCubicBezierPoints(divisions = this.divisions) {\n        const points = [];\n        const count = this.points.length;\n\n        if (count < 4) {\n            console.warn('Not enough points provided.');\n            return [];\n        }\n\n        let p0 = this.points[0],\n            c0 = this.points[1],\n            c1 = this.points[2],\n            p1 = this.points[3];\n\n        for (let i = 0; i <= divisions; i++) {\n            const p = getCubicBezierPoint(i / divisions, p0, c0, c1, p1);\n            points.push(p);\n        }\n\n        let offset = 4;\n        while (count - offset > 1) {\n            p0.copy(p1);\n            c0 = p1.scale(2).sub(c1);\n            c1 = this.points[offset];\n            p1 = this.points[offset + 1];\n            for (let i = 1; i <= divisions; i++) {\n                const p = getCubicBezierPoint(i / divisions, p0, c0, c1, p1);\n                points.push(p);\n            }\n            offset += 2;\n        }\n\n        return points;\n    }\n\n    _getCatmullRomPoints(divisions = this.divisions, a = 0.168, b = 0.168) {\n        const points = [];\n        const count = this.points.length;\n\n        if (count <= 2) {\n            return this.points;\n        }\n\n        let p0;\n        this.points.forEach((p, i) => {\n            if (i === 0) {\n                p0 = p;\n            } else {\n                const [c0, c1] = getCtrlPoint(this.points, i - 1, a, b);\n                const c = new Curve({\n                    points: [p0, c0, c1, p],\n                    type: CUBICBEZIER,\n                });\n                points.pop();\n                points.push(...c.getPoints(divisions));\n                p0 = p;\n            }\n        });\n\n        return points;\n    }\n\n    getPoints(divisions = this.divisions, a = 0.168, b = 0.168) {\n        const type = this.type;\n\n        if (type === QUADRATICBEZIER) {\n            return this._getQuadraticBezierPoints(divisions);\n        }\n\n        if (type === CUBICBEZIER) {\n            return this._getCubicBezierPoints(divisions);\n        }\n\n        if (type === CATMULLROM) {\n            return this._getCatmullRomPoints(divisions, a, b);\n        }\n\n        return this.points;\n    }\n}\n\nCurve.CATMULLROM = CATMULLROM;\nCurve.CUBICBEZIER = CUBICBEZIER;\nCurve.QUADRATICBEZIER = QUADRATICBEZIER;\n", "import BaseSegment from './BaseSegment.js';\nimport { Vec3 } from '../../math/Vec3.js';\nimport { T_VALUES, C_VALUES } from './utils.js';\n\nconst tempVec3 = /* @__PURE__ */ new Vec3();\n\nfunction cubicBezier(t, p0, p1, p2, p3) {\n    const k = 1 - t;\n    // prettier-ignore\n    return (\n        (k * k * k * p0) +\n        (3 * k * k * t * p1) +\n        (3 * k * t * t * p2) +\n        (t * t * t * p3)\n    );\n}\n\nfunction cubicBezierDeriv(t, p0, p1, p2, p3) {\n    const k = 1 - t;\n    // prettier-ignore\n    return (\n        (3 * k * k * (p1 - p0)) +\n        (6 * k * t * (p2 - p1)) +\n        (3 * t * t * (p3 - p2))\n    );\n}\n\nexport default class CubicBezierSegment extends BaseSegment {\n    constructor(p0, p1, p2, p3, tiltStart = 0, tiltEnd = 0) {\n        super();\n        this.p0 = p0;\n        this.p1 = p1;\n        this.p2 = p2;\n        this.p3 = p3;\n\n        this.tiltStart = tiltStart;\n        this.tiltEnd = tiltEnd;\n\n        this._len = -1;\n    }\n\n    /**\n     * Updates the segment length. You must call this method every time you change the curve's control points.\n     */\n    updateLength() {\n        // from https://github.com/Pomax/bezierjs/blob/d19695f3cc3ce383cf38ce4643f467deca7edb92/src/utils.js#L265\n        const z = 0.5;\n        const len = T_VALUES.length;\n\n        let sum = 0;\n        for (let i = 0, t; i < len; i++) {\n            t = z * T_VALUES[i] + z;\n            sum += C_VALUES[i] * this.getDerivativeAt(t, tempVec3).len();\n        }\n\n        this._len = z * sum;\n    }\n\n    /**\n     * Get point at relative position in curve according to segment length.\n     * @param {number} t Distance at time t in range [0 .. 1]\n     * @param {Vec3} out Optional Vec3 to output\n     * @returns {Vec3} Point at relative position\n     */\n    getPointAt(t, out = new Vec3()) {\n        out.x = cubicBezier(t, this.p0.x, this.p1.x, this.p2.x, this.p3.x);\n        out.y = cubicBezier(t, this.p0.y, this.p1.y, this.p2.y, this.p3.y);\n        out.z = cubicBezier(t, this.p0.z, this.p1.z, this.p2.z, this.p3.z);\n        return out;\n    }\n\n    getDerivativeAt(t, out = new Vec3()) {\n        out.x = cubicBezierDeriv(t, this.p0.x, this.p1.x, this.p2.x, this.p3.x);\n        out.y = cubicBezierDeriv(t, this.p0.y, this.p1.y, this.p2.y, this.p3.y);\n        out.z = cubicBezierDeriv(t, this.p0.z, this.p1.z, this.p2.z, this.p3.z);\n        return out;\n    }\n\n    /**\n     * Returns a unit vector tangent at t\n     * @param {number} t Distance at time t in range [0 .. 1]\n     * @param {Vec3} out Optional Vec3 to output\n     * @returns {Vec3} A unit vector\n     */\n    getTangentAt(t, out = new Vec3()) {\n        return this.getDerivativeAt(t, out).normalize();\n    }\n\n    lastPoint() {\n        return this.p3;\n    }\n}\n", "import BaseSegment from './BaseSegment.js';\nimport { Vec3 } from '../../math/Vec3.js';\nimport { T_VALUES, C_VALUES } from './utils.js';\n\nconst tempVec3 = /* @__PURE__ */ new Vec3();\n\nfunction quadraticBezier(t, p0, p1, p2) {\n    const k = 1 - t;\n    return k * k * p0 + 2 * k * t * p1 + t * t * p2;\n}\n\nfunction quadraticBezierDeriv(t, p0, p1, p2) {\n    const k = 1 - t;\n    return 2 * k * (p1 - p0) + 2 * t * (p2 - p1);\n}\n\nexport default class QuadraticBezierSegment extends BaseSegment {\n    constructor(p0, p1, p2, tiltStart = 0, tiltEnd = 0) {\n        super();\n        this.p0 = p0;\n        this.p1 = p1;\n        this.p2 = p2;\n\n        this.tiltStart = tiltStart;\n        this.tiltEnd = tiltEnd;\n\n        this._len = -1;\n    }\n\n    /**\n     * Updates the segment length. You must call this method every time you change the curve's control points.\n     */\n    updateLength() {\n        // from https://github.com/Pomax/bezierjs/blob/d19695f3cc3ce383cf38ce4643f467deca7edb92/src/utils.js#L265\n        const z = 0.5;\n        const len = T_VALUES.length;\n\n        let sum = 0;\n        for (let i = 0, t; i < len; i++) {\n            t = z * T_VALUES[i] + z;\n            sum += C_VALUES[i] * this.getDerivativeAt(t, tempVec3).len();\n        }\n\n        this._len = z * sum;\n    }\n\n    /**\n     * Get point at relative position in curve according to segment length.\n     * @param {number} t Distance at time t in range [0 .. 1]\n     * @param {Vec3} out Optional Vec3 to output\n     * @returns {Vec3} Point at relative position\n     */\n    getPointAt(t, out = new Vec3()) {\n        out.x = quadraticBezier(t, this.p0.x, this.p1.x, this.p2.x);\n        out.y = quadraticBezier(t, this.p0.y, this.p1.y, this.p2.y);\n        out.z = quadraticBezier(t, this.p0.z, this.p1.z, this.p2.z);\n        return out;\n    }\n\n    getDerivativeAt(t, out = new Vec3()) {\n        out.x = quadraticBezierDeriv(t, this.p0.x, this.p1.x, this.p2.x);\n        out.y = quadraticBezierDeriv(t, this.p0.y, this.p1.y, this.p2.y);\n        out.z = quadraticBezierDeriv(t, this.p0.z, this.p1.z, this.p2.z);\n        return out;\n    }\n\n    /**\n     * Returns a unit vector tangent at t\n     * @param {number} t Distance at time t in range [0 .. 1]\n     * @param {Vec3} out Optional Vec3 to output\n     * @returns {Vec3} A unit vector\n     */\n    getTangentAt(t, out = new Vec3()) {\n        return this.getDerivativeAt(t, out).normalize();\n    }\n\n    lastPoint() {\n        return this.p2;\n    }\n}\n", "import BaseSegment from './BaseSegment.js';\nimport { Vec3 } from '../../math/Vec3.js';\nimport { lerp as lerp3 } from '../../math/functions/Vec3Func.js';\n\nconst tempVec3 = /* @__PURE__ */ new Vec3();\n\nexport default class LineSegment extends BaseSegment {\n    constructor(p0, p1, tiltStart = 0, tiltEnd = 0) {\n        super();\n        this.p0 = p0;\n        this.p1 = p1;\n\n        this.tiltStart = tiltStart;\n        this.tiltEnd = tiltEnd;\n\n        this._len = -1;\n    }\n\n    /**\n     * Updates the segment length. You must call this method every time you change the curve's control points.\n     */\n    updateLength() {\n        this._len = tempVec3.sub(this.p1, this.p0).len();\n    }\n\n    /**\n     * Get point at relative position in curve according to segment length.\n     * @param {number} t Distance at time t in range [0 .. 1]\n     * @param {Vec3} out Optional Vec3 to output\n     * @returns {Vec3} Point at relative position\n     */\n    getPointAt(t, out = new Vec3()) {\n        lerp3(out, this.p0, this.p1, t);\n        return out;\n    }\n\n    /**\n     * Returns a unit vector tangent at t\n     * @param {number} t Distance at time t in range [0 .. 1]\n     * @param {Vec3} out Optional Vec3 to output\n     * @returns {Vec3} A unit vector\n     */\n    getTangentAt(t, out = new Vec3()) {\n        return out.sub(this.p1, this.p0).normalize();\n    }\n\n    lastPoint() {\n        return this.p1;\n    }\n}\n", "import { Vec3 } from '../../math/Vec3.js';\nimport { Mat4 } from '../../math/Mat4.js';\nimport CubicBezierSegment from './CubicBezierSegment.js';\nimport QuadraticBezierSegment from './QuadraticBezierSegment.js';\nimport LineSegment from './LineSegment.js';\nimport { clamp, toDegrees, toRadian, mat4fromRotationSinCos, rotateNormalBinormal } from './utils.js';\n\nconst tempVec3 = /* @__PURE__ */ new Vec3();\nconst tempMat4 = /* @__PURE__ */ new Mat4();\n\nfunction throwIfNullProperty(property, message) {\n    if (this[property] == null) throw new Error(message);\n}\n\nexport class Path {\n    constructor() {\n        this._segments = [];\n        this._lengthOffsets = null;\n        this._totalLength = -1;\n        this._lastPoint = null;\n        this._lastTilt = 0;\n\n        this._assertLastPoint = throwIfNullProperty.bind(this, '_lastPoint', 'Can`t get previous point of curve. Did you forget moveTo command?');\n\n        this.tiltFunction = null;\n    }\n\n    moveTo(p, tilt = 0) {\n        this._totalLength = -1;\n        this._lastPoint = p;\n        this._lastTilt = tilt;\n    }\n\n    bezierCurveTo(cp1, cp2, p, tilt = 0) {\n        this._assertLastPoint();\n        const seg = new CubicBezierSegment(this._lastPoint, cp1, cp2, p, this._lastTilt, tilt);\n        this.addSegment(seg);\n        return this;\n    }\n\n    quadraticCurveTo(cp, p, tilt = 0) {\n        this._assertLastPoint();\n        const seg = new QuadraticBezierSegment(this._lastPoint, cp, p, this._lastTilt, tilt);\n        this.addSegment(seg);\n        return this;\n    }\n\n    lineTo(p, tilt = 0) {\n        this._assertLastPoint();\n        const seg = new LineSegment(this._lastPoint, p, this._lastTilt, tilt);\n        this.addSegment(seg);\n        return this;\n    }\n\n    addSegment(segment) {\n        this._totalLength = -1;\n        this._lastPoint = segment.lastPoint();\n        this._lastTilt = segment.tiltEnd;\n        this._segments.push(segment);\n        return this;\n    }\n\n    getSegments() {\n        return this._segments;\n    }\n\n    updateLength() {\n        const n = this._segments.length;\n        this._lengthOffsets = new Array(n);\n\n        let offset = 0;\n        for (let i = 0; i < n; i++) {\n            this._lengthOffsets[i] = offset;\n            offset += this._segments[i].getLength();\n        }\n\n        this._totalLength = offset;\n    }\n\n    getLength() {\n        if (this._totalLength < 0) {\n            this.updateLength();\n        }\n\n        return this._totalLength;\n    }\n\n    /**\n     * Finding a path segment at a given absolute length distance\n     * @param {number} len absolute length distance\n     * @returns {[number, number]} [_segment index_, _relative segment distance_]\n     */\n    findSegmentIndexAtLength(len) {\n        const totalLength = this.getLength();\n\n        if (len <= 0) {\n            return [0, 0];\n        }\n\n        if (len >= totalLength) {\n            return [this._segments.length - 1, 1];\n        }\n\n        let start = 0;\n        let end = this._lengthOffsets.length - 1;\n        let index = -1;\n        let mid;\n\n        while (start <= end) {\n            mid = Math.ceil((start + end) / 2);\n\n            if (mid === 0 || mid === this._lengthOffsets.length - 1 || (len >= this._lengthOffsets[mid] && len < this._lengthOffsets[mid + 1])) {\n                index = mid;\n                break;\n            } else if (len < this._lengthOffsets[mid]) {\n                end = mid - 1;\n            } else {\n                start = mid + 1;\n            }\n        }\n\n        const seg = this._segments[index];\n        const segLen = seg.getLength();\n        const t = (len - this._lengthOffsets[index]) / segLen;\n\n        return [index, t];\n    }\n\n    getPointAtLength(len, out = new Vec3()) {\n        const [i, t] = this.findSegmentIndexAtLength(len);\n        return this._segments[i].getPointAt(t, out);\n    }\n\n    getPointAt(t, out = new Vec3()) {\n        const totalLength = this.getLength();\n        return this.getPointAtLength(t * totalLength, out);\n    }\n\n    getTangentAtLength(len, out = new Vec3()) {\n        const [i, t] = this.findSegmentIndexAtLength(len);\n        return this._segments[i].getTangentAt(t, out);\n    }\n\n    getTangentAt(t, out = new Vec3()) {\n        const totalLength = this.getLength();\n        return this.getTangentAtLength(t * totalLength, out);\n    }\n\n    getTiltAtLength(len) {\n        const [i, t] = this.findSegmentIndexAtLength(len);\n        return this._segments[i].getTiltAt(t);\n    }\n\n    getTiltAt(t) {\n        const totalLength = this.getLength();\n        return this.getTiltAtLength(t * totalLength);\n    }\n\n    /**\n     * Get sequence of points using `getPointAt(t)`\n     * @param {number} divisions number of subdivisions\n     * @returns {Vec3[]} array of points\n     */\n    getPoints(divisions = 64) {\n        const points = new Array(divisions + 1);\n        for (let i = 0; i <= divisions; i++) {\n            points[i] = this.getPointAt(i / divisions);\n        }\n        return points;\n    }\n\n    /**\n     * Generates the Frenet Frames.\n     * See http://www.cs.indiana.edu/pub/techreports/TR425.pdf\n     * @param {number} divisions number of subdivisions\n     * @returns {{tangents: Vec3[], normals: Vec3[], binormals: Vec3[]}} Object with tangents, normals and binormals arrays\n     */\n    computeFrenetFrames(divisions = 64, closed = false) {\n        const tangents = new Array(divisions + 1);\n        const tilts = new Array(divisions + 1);\n\n        const tiltFunction = this.tiltFunction ?? ((a) => a);\n\n        // compute the tangent vectors and tilt for each segment on the curve\n        const totalLength = this.getLength();\n        for (let i = 0; i <= divisions; i++) {\n            const [si, st] = this.findSegmentIndexAtLength((totalLength * i) / divisions);\n            const segment = this._segments[si];\n            tangents[i] = segment.getTangentAt(st);\n            tilts[i] = tiltFunction(segment.getTiltAt(st), i / divisions, this);\n        }\n\n        const tx = Math.abs(tangents[0].x);\n        const ty = Math.abs(tangents[0].y);\n        const tz = Math.abs(tangents[0].z);\n\n        const normal = new Vec3();\n        if (tx < ty && tx < tz) {\n            normal.set(1, 0, 0);\n        } else if (ty < tx && ty < tz) {\n            normal.set(0, 1, 0);\n        } else {\n            normal.set(0, 0, 1);\n        }\n\n        // select an initial normal vector perpendicular to the first tangent vector,\n        // and in the direction of the minimum tangent xyz component\n        const normals = new Array(divisions + 1);\n        const binormals = new Array(divisions + 1);\n        normals[0] = new Vec3();\n        binormals[0] = new Vec3();\n\n        tempVec3.cross(tangents[0], normal).normalize();\n        normals[0].cross(tangents[0], tempVec3);\n        binormals[0].cross(tangents[0], normals[0]);\n\n        // compute the slowly-varying normal vector for each segment on the curve\n        for (let i = 1; i < tangents.length; i++) {\n            normals[i] = normals[i - 1].clone();\n            binormals[i] = new Vec3();\n\n            tempVec3.cross(tangents[i - 1], tangents[i]);\n            const crossLen = tempVec3.len();\n\n            if (crossLen > Number.EPSILON) {\n                tempVec3.scale(1 / crossLen); // nomalize\n                const cosTheta = clamp(tangents[i - 1].dot(tangents[i]), -1, 1); // clamp for floating pt errors\n                const sinTheta = clamp(crossLen, -1, 1);\n\n                mat4fromRotationSinCos(tempMat4, tempVec3, sinTheta, cosTheta);\n                normals[i].applyMatrix4(tempMat4);\n            }\n\n            binormals[i].cross(tangents[i], normals[i]);\n        }\n\n        // add tilt twisting\n        for (let i = 0; i < tilts.length; i++) {\n            rotateNormalBinormal(toRadian(tilts[i]), normals[i], binormals[i]);\n        }\n\n        // if the curve is closed, postprocess the vectors so the first and last normal vectors are the same\n        if (closed === true) {\n            const normalLast = normals[normals.length - 1];\n            let step = Math.acos(clamp(normals[0].dot(normalLast), -1, 1)) / (normals.length - 1);\n\n            if (tangents[0].dot(tempVec3.cross(normals[0], normalLast)) > 0) {\n                step = -step;\n            }\n\n            for (let i = 1; i < normals.length - 1; i++) {\n                const angle = step * i;\n                rotateNormalBinormal(angle, normals[i], binormals[i]);\n                tilts[i] += toDegrees(angle);\n            }\n\n            normals[normals.length - 1] = normals[0].clone();\n            binormals[binormals.length - 1] = binormals[0].clone();\n        }\n\n        return { tangents, normals, binormals, tilts };\n    }\n}\n", "import { Geometry } from '../core/Geometry.js';\nimport { Vec3 } from '../math/Vec3.js';\nimport { Vec2 } from '../math/Vec2.js';\n\n// helper variables\nconst vertex = /* @__PURE__ */ new Vec3();\nconst normal = /* @__PURE__ */ new Vec3();\nconst uv = /* @__PURE__ */ new Vec2();\nconst point = /* @__PURE__ */ new Vec3();\n\nexport class Tube extends Geometry {\n    constructor(gl, { path, radius = 1, tubularSegments = 64, radialSegments = 8, closed = false, attributes = {} } = {}) {\n        super(gl, attributes);\n\n        this.path = path;\n        this.radius = radius;\n        this.tubularSegments = tubularSegments;\n        this.radialSegments = radialSegments;\n        this.closed = closed;\n\n        this.frenetFrames = path.computeFrenetFrames(tubularSegments, closed);\n\n        const numVertices = (tubularSegments + 1) * (radialSegments + 1);\n        const numIndices = tubularSegments * radialSegments * 6;\n        this.positions = new Float32Array(numVertices * 3);\n        this.normals = new Float32Array(numVertices * 3);\n        this.uvs = new Float32Array(numVertices * 2);\n        this.indices = numVertices > 65536 ? new Uint32Array(numIndices) : new Uint16Array(numIndices);\n\n        // create buffer data\n        this._generateAttributes();\n        this._generateIndices();\n\n        this.addAttribute('position', { size: 3, data: this.positions });\n        this.addAttribute('normal', { size: 3, data: this.normals });\n        this.addAttribute('uv', { size: 2, data: this.uvs });\n        this.setIndex({ data: this.indices });\n    }\n\n    _generateAttributes() {\n        for (let i = 0; i <= this.tubularSegments; i++) {\n            let ci = i;\n            if (i === this.tubularSegments) {\n                // if the geometry is not closed, generate the last row of vertices and normals\n                // at the regular position on the given path\n                // if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)\n                ci = this.closed ? 0 : this.tubularSegments;\n            }\n\n            this.path.getPointAt(ci / this.tubularSegments, point);\n            // retrieve corresponding normal and binormal\n            const N = this.frenetFrames.normals[ci];\n            const B = this.frenetFrames.binormals[ci];\n\n            // generate normals and vertices for the current segment\n            for (let j = 0; j <= this.radialSegments; j++) {\n                const v = (j / this.radialSegments) * Math.PI * 2;\n                const sin = Math.sin(v);\n                const cos = -Math.cos(v);\n\n                const idx = i * (this.radialSegments + 1) + j;\n\n                // normal\n                normal.x = cos * N.x + sin * B.x;\n                normal.y = cos * N.y + sin * B.y;\n                normal.z = cos * N.z + sin * B.z;\n                // normal.normalize(); // ???\n                this.normals.set(normal, idx * 3);\n\n                // vertex\n                vertex.x = point.x + this.radius * normal.x;\n                vertex.y = point.y + this.radius * normal.y;\n                vertex.z = point.z + this.radius * normal.z;\n                this.positions.set(vertex, idx * 3);\n\n                // uv\n                uv.x = i / this.tubularSegments;\n                uv.y = j / this.radialSegments;\n                this.uvs.set(uv, idx * 2);\n            }\n        }\n    }\n\n    _generateIndices() {\n        for (let j = 1; j <= this.tubularSegments; j++) {\n            for (let i = 1; i <= this.radialSegments; i++) {\n                const a = (this.radialSegments + 1) * (j - 1) + (i - 1);\n                const b = (this.radialSegments + 1) * j + (i - 1);\n                const c = (this.radialSegments + 1) * j + i;\n                const d = (this.radialSegments + 1) * (j - 1) + i;\n\n                const idx = (j - 1) * this.radialSegments + (i - 1);\n                this.indices.set([a, b, d, b, c, d], idx * 6);\n            }\n        }\n    }\n}\n", "import { Vec3 } from '../math/Vec3.js';\nimport { Quat } from '../math/Quat.js';\n\nconst prevPos = /* @__PURE__ */ new Vec3();\nconst prevRot = /* @__PURE__ */ new Quat();\nconst prevScl = /* @__PURE__ */ new Vec3();\n\nconst nextPos = /* @__PURE__ */ new Vec3();\nconst nextRot = /* @__PURE__ */ new Quat();\nconst nextScl = /* @__PURE__ */ new Vec3();\n\nexport class Animation {\n    constructor({ objects, data }) {\n        this.objects = objects;\n        this.data = data;\n        this.elapsed = 0;\n        this.weight = 1;\n        this.duration = data.frames.length - 1;\n    }\n\n    update(totalWeight = 1, isSet) {\n        const weight = isSet ? 1 : this.weight / totalWeight;\n        const elapsed = this.elapsed % this.duration;\n\n        const floorFrame = Math.floor(elapsed);\n        const blend = elapsed - floorFrame;\n        const prevKey = this.data.frames[floorFrame];\n        const nextKey = this.data.frames[(floorFrame + 1) % this.duration];\n\n        this.objects.forEach((object, i) => {\n            prevPos.fromArray(prevKey.position, i * 3);\n            prevRot.fromArray(prevKey.quaternion, i * 4);\n            prevScl.fromArray(prevKey.scale, i * 3);\n\n            nextPos.fromArray(nextKey.position, i * 3);\n            nextRot.fromArray(nextKey.quaternion, i * 4);\n            nextScl.fromArray(nextKey.scale, i * 3);\n\n            prevPos.lerp(nextPos, blend);\n            prevRot.slerp(nextRot, blend);\n            prevScl.lerp(nextScl, blend);\n\n            object.position.lerp(prevPos, weight);\n            object.quaternion.slerp(prevRot, weight);\n            object.scale.lerp(prevScl, weight);\n        });\n    }\n}\n", "import { Mesh } from '../core/Mesh.js';\nimport { Transform } from '../core/Transform.js';\nimport { Mat4 } from '../math/Mat4.js';\nimport { Texture } from '../core/Texture.js';\nimport { Animation } from './Animation.js';\n\nconst tempMat4 = /* @__PURE__ */ new Mat4();\n\nexport class Skin extends Mesh {\n    constructor(gl, { rig, geometry, program, mode = gl.TRIANGLES } = {}) {\n        super(gl, { geometry, program, mode });\n\n        this.createBones(rig);\n        this.createBoneTexture();\n        this.animations = [];\n\n        Object.assign(this.program.uniforms, {\n            boneTexture: { value: this.boneTexture },\n            boneTextureSize: { value: this.boneTextureSize },\n        });\n    }\n\n    createBones(rig) {\n        // Create root so that can simply update world matrix of whole skeleton\n        this.root = new Transform();\n\n        // Create bones\n        this.bones = [];\n        if (!rig.bones || !rig.bones.length) return;\n        for (let i = 0; i < rig.bones.length; i++) {\n            const bone = new Transform();\n\n            // Set initial values (bind pose)\n            bone.position.fromArray(rig.bindPose.position, i * 3);\n            bone.quaternion.fromArray(rig.bindPose.quaternion, i * 4);\n            bone.scale.fromArray(rig.bindPose.scale, i * 3);\n\n            this.bones.push(bone);\n        }\n\n        // Once created, set the hierarchy\n        rig.bones.forEach((data, i) => {\n            this.bones[i].name = data.name;\n            if (data.parent === -1) return this.bones[i].setParent(this.root);\n            this.bones[i].setParent(this.bones[data.parent]);\n        });\n\n        // Then update to calculate world matrices\n        this.root.updateMatrixWorld(true);\n\n        // Store inverse of bind pose to calculate differences\n        this.bones.forEach((bone) => {\n            bone.bindInverse = new Mat4(...bone.worldMatrix).inverse();\n        });\n    }\n\n    createBoneTexture() {\n        if (!this.bones.length) return;\n        const size = Math.max(4, Math.pow(2, Math.ceil(Math.log(Math.sqrt(this.bones.length * 4)) / Math.LN2)));\n        this.boneMatrices = new Float32Array(size * size * 4);\n        this.boneTextureSize = size;\n        this.boneTexture = new Texture(this.gl, {\n            image: this.boneMatrices,\n            generateMipmaps: false,\n            type: this.gl.FLOAT,\n            internalFormat: this.gl.renderer.isWebgl2 ? this.gl.RGBA32F : this.gl.RGBA,\n            minFilter: this.gl.NEAREST,\n            magFilter: this.gl.NEAREST,\n            flipY: false,\n            width: size,\n        });\n    }\n\n    addAnimation(data) {\n        const animation = new Animation({ objects: this.bones, data });\n        this.animations.push(animation);\n        return animation;\n    }\n\n    update() {\n        // Calculate combined animation weight\n        let total = 0;\n        this.animations.forEach((animation) => (total += animation.weight));\n\n        this.animations.forEach((animation, i) => {\n            // force first animation to set in order to reset frame\n            animation.update(total, i === 0);\n        });\n    }\n\n    draw({ camera } = {}) {\n        // Update world matrices manually, as not part of scene graph\n        this.root.updateMatrixWorld(true);\n\n        // Update bone texture\n        this.bones.forEach((bone, i) => {\n            // Find difference between current and bind pose\n            tempMat4.multiply(bone.worldMatrix, bone.bindInverse);\n            this.boneMatrices.set(tempMat4, i * 16);\n        });\n        if (this.boneTexture) this.boneTexture.needsUpdate = true;\n\n        super.draw({ camera });\n    }\n}\n", "import { Geometry } from '../core/Geometry.js';\nimport { Program } from '../core/Program.js';\nimport { Mesh } from '../core/Mesh.js';\nimport { Vec2 } from '../math/Vec2.js';\nimport { Vec3 } from '../math/Vec3.js';\nimport { Color } from '../math/Color.js';\n\nconst tmp = /* @__PURE__ */ new Vec3();\n\nexport class Polyline {\n    constructor(\n        gl,\n        {\n            points, // Array of Vec3s\n            vertex = defaultVertex,\n            fragment = defaultFragment,\n            uniforms = {},\n            attributes = {}, // For passing in custom attribs\n        }\n    ) {\n        this.gl = gl;\n        this.points = points;\n        this.count = points.length;\n\n        // Create buffers\n        this.position = new Float32Array(this.count * 3 * 2);\n        this.prev = new Float32Array(this.count * 3 * 2);\n        this.next = new Float32Array(this.count * 3 * 2);\n        const side = new Float32Array(this.count * 1 * 2);\n        const uv = new Float32Array(this.count * 2 * 2);\n        const index = new Uint16Array((this.count - 1) * 3 * 2);\n\n        // Set static buffers\n        for (let i = 0; i < this.count; i++) {\n            side.set([-1, 1], i * 2);\n            const v = i / (this.count - 1);\n            uv.set([0, v, 1, v], i * 4);\n\n            if (i === this.count - 1) continue;\n            const ind = i * 2;\n            index.set([ind + 0, ind + 1, ind + 2], (ind + 0) * 3);\n            index.set([ind + 2, ind + 1, ind + 3], (ind + 1) * 3);\n        }\n\n        const geometry = (this.geometry = new Geometry(\n            gl,\n            Object.assign(attributes, {\n                position: { size: 3, data: this.position },\n                prev: { size: 3, data: this.prev },\n                next: { size: 3, data: this.next },\n                side: { size: 1, data: side },\n                uv: { size: 2, data: uv },\n                index: { size: 1, data: index },\n            })\n        ));\n\n        // Populate dynamic buffers\n        this.updateGeometry();\n\n        if (!uniforms.uResolution) this.resolution = uniforms.uResolution = { value: new Vec2() };\n        if (!uniforms.uDPR) this.dpr = uniforms.uDPR = { value: 1 };\n        if (!uniforms.uThickness) this.thickness = uniforms.uThickness = { value: 1 };\n        if (!uniforms.uColor) this.color = uniforms.uColor = { value: new Color('#000') };\n        if (!uniforms.uMiter) this.miter = uniforms.uMiter = { value: 1 };\n\n        // Set size uniforms' values\n        this.resize();\n\n        const program = (this.program = new Program(gl, {\n            vertex,\n            fragment,\n            uniforms,\n        }));\n\n        this.mesh = new Mesh(gl, { geometry, program });\n    }\n\n    updateGeometry() {\n        this.points.forEach((p, i) => {\n            p.toArray(this.position, i * 3 * 2);\n            p.toArray(this.position, i * 3 * 2 + 3);\n\n            if (!i) {\n                // If first point, calculate prev using the distance to 2nd point\n                tmp.copy(p)\n                    .sub(this.points[i + 1])\n                    .add(p);\n                tmp.toArray(this.prev, i * 3 * 2);\n                tmp.toArray(this.prev, i * 3 * 2 + 3);\n            } else {\n                p.toArray(this.next, (i - 1) * 3 * 2);\n                p.toArray(this.next, (i - 1) * 3 * 2 + 3);\n            }\n\n            if (i === this.points.length - 1) {\n                // If last point, calculate next using distance to 2nd last point\n                tmp.copy(p)\n                    .sub(this.points[i - 1])\n                    .add(p);\n                tmp.toArray(this.next, i * 3 * 2);\n                tmp.toArray(this.next, i * 3 * 2 + 3);\n            } else {\n                p.toArray(this.prev, (i + 1) * 3 * 2);\n                p.toArray(this.prev, (i + 1) * 3 * 2 + 3);\n            }\n        });\n\n        this.geometry.attributes.position.needsUpdate = true;\n        this.geometry.attributes.prev.needsUpdate = true;\n        this.geometry.attributes.next.needsUpdate = true;\n    }\n\n    // Only need to call if not handling resolution uniforms manually\n    resize() {\n        // Update automatic uniforms if not overridden\n        if (this.resolution) this.resolution.value.set(this.gl.canvas.width, this.gl.canvas.height);\n        if (this.dpr) this.dpr.value = this.gl.renderer.dpr;\n    }\n}\n\nconst defaultVertex = /* glsl */ `\n    precision highp float;\n\n    attribute vec3 position;\n    attribute vec3 next;\n    attribute vec3 prev;\n    attribute vec2 uv;\n    attribute float side;\n\n    uniform mat4 modelViewMatrix;\n    uniform mat4 projectionMatrix;\n    uniform vec2 uResolution;\n    uniform float uDPR;\n    uniform float uThickness;\n    uniform float uMiter;\n\n    varying vec2 vUv;\n\n    vec4 getPosition() {\n        mat4 mvp = projectionMatrix * modelViewMatrix;\n        vec4 current = mvp * vec4(position, 1);\n        vec4 nextPos = mvp * vec4(next, 1);\n        vec4 prevPos = mvp * vec4(prev, 1);\n\n        vec2 aspect = vec2(uResolution.x / uResolution.y, 1);    \n        vec2 currentScreen = current.xy / current.w * aspect;\n        vec2 nextScreen = nextPos.xy / nextPos.w * aspect;\n        vec2 prevScreen = prevPos.xy / prevPos.w * aspect;\n    \n        vec2 dir1 = normalize(currentScreen - prevScreen);\n        vec2 dir2 = normalize(nextScreen - currentScreen);\n        vec2 dir = normalize(dir1 + dir2);\n    \n        vec2 normal = vec2(-dir.y, dir.x);\n        normal /= mix(1.0, max(0.3, dot(normal, vec2(-dir1.y, dir1.x))), uMiter);\n        normal /= aspect;\n\n        float pixelWidthRatio = 1.0 / (uResolution.y / uDPR);\n        float pixelWidth = current.w * pixelWidthRatio;\n        normal *= pixelWidth * uThickness;\n        current.xy -= normal * side;\n    \n        return current;\n    }\n\n    void main() {\n        vUv = uv;\n        gl_Position = getPosition();\n    }\n`;\n\nconst defaultFragment = /* glsl */ `\n    precision highp float;\n\n    uniform vec3 uColor;\n    \n    varying vec2 vUv;\n\n    void main() {\n        gl_FragColor.rgb = uColor;\n        gl_FragColor.a = 1.0;\n    }\n`;\n", "import { Vec3 } from '../math/Vec3.js';\nimport { Quat } from '../math/Quat.js';\n\nconst tmpVec3A = /* @__PURE__ */ new Vec3();\nconst tmpVec3B = /* @__PURE__ */ new Vec3();\nconst tmpVec3C = /* @__PURE__ */ new Vec3();\nconst tmpVec3D = /* @__PURE__ */ new Vec3();\n\nconst tmpQuatA = /* @__PURE__ */ new Quat();\nconst tmpQuatB = /* @__PURE__ */ new Quat();\nconst tmpQuatC = /* @__PURE__ */ new Quat();\nconst tmpQuatD = /* @__PURE__ */ new Quat();\n\nexport class GLTFAnimation {\n    constructor(data, weight = 1) {\n        this.data = data;\n        this.elapsed = 0;\n        this.weight = weight;\n\n        // Set to false to not apply modulo to elapsed against duration\n        this.loop = true;\n\n        // Find starting time as exports from blender (perhaps others too) don't always start from 0\n        this.startTime = data.reduce((a, { times }) => Math.min(a, times[0]), Infinity);\n        // Get largest final time in all channels to calculate duration\n        this.endTime = data.reduce((a, { times }) => Math.max(a, times[times.length - 1]), 0);\n        this.duration = this.endTime - this.startTime;\n    }\n\n    update(totalWeight = 1, isSet) {\n        const weight = isSet ? 1 : this.weight / totalWeight;\n        const elapsed = !this.duration\n            ? 0\n            : (this.loop ? this.elapsed % this.duration : Math.min(this.elapsed, this.duration - 0.001)) + this.startTime;\n\n        this.data.forEach(({ node, transform, interpolation, times, values }) => {\n            if (!this.duration) {\n                let val = tmpVec3A;\n                let size = 3;\n                if (transform === 'quaternion') {\n                    val = tmpQuatA;\n                    size = 4;\n                }\n                val.fromArray(values, 0);\n                if (size === 4) node[transform].slerp(val, weight);\n                else node[transform].lerp(val, weight);\n                return;\n            }\n\n            // Get index of two time values elapsed is between\n            const prevIndex =\n                Math.max(\n                    1,\n                    times.findIndex((t) => t > elapsed)\n                ) - 1;\n            const nextIndex = prevIndex + 1;\n\n            // Get linear blend/alpha between the two\n            let alpha = (elapsed - times[prevIndex]) / (times[nextIndex] - times[prevIndex]);\n            if (interpolation === 'STEP') alpha = 0;\n\n            let prevVal = tmpVec3A;\n            let prevTan = tmpVec3B;\n            let nextTan = tmpVec3C;\n            let nextVal = tmpVec3D;\n            let size = 3;\n\n            if (transform === 'quaternion') {\n                prevVal = tmpQuatA;\n                prevTan = tmpQuatB;\n                nextTan = tmpQuatC;\n                nextVal = tmpQuatD;\n                size = 4;\n            }\n\n            if (interpolation === 'CUBICSPLINE') {\n                // Get the prev and next values from the indices\n                prevVal.fromArray(values, prevIndex * size * 3 + size * 1);\n                prevTan.fromArray(values, prevIndex * size * 3 + size * 2);\n                nextTan.fromArray(values, nextIndex * size * 3 + size * 0);\n                nextVal.fromArray(values, nextIndex * size * 3 + size * 1);\n\n                // interpolate for final value\n                prevVal = this.cubicSplineInterpolate(alpha, prevVal, prevTan, nextTan, nextVal);\n                if (size === 4) prevVal.normalize();\n            } else {\n                // Get the prev and next values from the indices\n                prevVal.fromArray(values, prevIndex * size);\n                nextVal.fromArray(values, nextIndex * size);\n\n                // interpolate for final value\n                if (size === 4) prevVal.slerp(nextVal, alpha);\n                else prevVal.lerp(nextVal, alpha);\n            }\n\n            // interpolate between multiple possible animations\n            if (size === 4) node[transform].slerp(prevVal, weight);\n            else node[transform].lerp(prevVal, weight);\n        });\n    }\n\n    cubicSplineInterpolate(t, prevVal, prevTan, nextTan, nextVal) {\n        const t2 = t * t;\n        const t3 = t2 * t;\n\n        const s2 = 3 * t2 - 2 * t3;\n        const s3 = t3 - t2;\n        const s0 = 1 - s2;\n        const s1 = s3 - t2 + t;\n\n        for (let i = 0; i < prevVal.length; i++) {\n            prevVal[i] = s0 * prevVal[i] + s1 * (1 - t) * prevTan[i] + s2 * nextVal[i] + s3 * t * nextTan[i];\n        }\n\n        return prevVal;\n    }\n}\n", "import { Mesh } from '../core/Mesh.js';\nimport { Mat4 } from '../math/Mat4.js';\nimport { Texture } from '../core/Texture.js';\n\nconst tempMat4 = /* @__PURE__ */ new Mat4();\nconst identity = /* @__PURE__ */ new Mat4();\n\nexport class GLTFSkin extends Mesh {\n    constructor(gl, { skeleton, geometry, program, mode = gl.TRIANGLES } = {}) {\n        super(gl, { geometry, program, mode });\n        this.skeleton = skeleton;\n        this.program = program;\n        this.createBoneTexture();\n    }\n\n    createBoneTexture() {\n        if (!this.skeleton.joints.length) return;\n        const size = Math.max(4, Math.pow(2, Math.ceil(Math.log(Math.sqrt(this.skeleton.joints.length * 4)) / Math.LN2)));\n        this.boneMatrices = new Float32Array(size * size * 4);\n        this.boneTextureSize = size;\n        this.boneTexture = new Texture(this.gl, {\n            image: this.boneMatrices,\n            generateMipmaps: false,\n            type: this.gl.FLOAT,\n            internalFormat: this.gl.renderer.isWebgl2 ? this.gl.RGBA32F : this.gl.RGBA,\n            minFilter: this.gl.NEAREST,\n            magFilter: this.gl.NEAREST,\n            flipY: false,\n            width: size,\n        });\n    }\n\n    updateUniforms() {\n        // Update bone texture\n        this.skeleton.joints.forEach((bone, i) => {\n            // Find difference between current and bind pose\n            tempMat4.multiply(bone.worldMatrix, bone.bindInverse);\n            this.boneMatrices.set(tempMat4, i * 16);\n        });\n        this.boneTexture.needsUpdate = true;\n        // Reset for programs shared between multiple skins\n        this.program.uniforms.boneTexture.value = this.boneTexture;\n        this.program.uniforms.boneTextureSize.value = this.boneTextureSize;\n    }\n\n    draw({ camera } = {}) {\n        if (!this.program.uniforms.boneTexture) {\n            Object.assign(this.program.uniforms, {\n                boneTexture: { value: this.boneTexture },\n                boneTextureSize: { value: this.boneTextureSize },\n            });\n        }\n\n        this.updateUniforms();\n\n        // Switch the world matrix with identity to ignore any transforms\n        // on the mesh itself - only use skeleton's transforms\n        const _worldMatrix = this.worldMatrix;\n        this.worldMatrix = identity;\n\n        super.draw({ camera });\n\n        // Switch back to leave identity untouched\n        this.worldMatrix = _worldMatrix;\n    }\n}\n", "import { Mesh } from '../../core/Mesh.js';\nimport { Program } from '../../core/Program.js';\nimport { Geometry } from '../../core/Geometry.js';\nimport { Vec3 } from '../../math/Vec3.js';\nimport { Mat3 } from '../../math/Mat3.js';\n\nconst vA = /* @__PURE__ */ new Vec3();\nconst vB = /* @__PURE__ */ new Vec3();\nconst vC = /* @__PURE__ */ new Vec3();\nconst vCenter = /* @__PURE__ */ new Vec3();\nconst vNormal = /* @__PURE__ */ new Vec3();\n\nexport class FaceNormalsHelper extends Mesh {\n    constructor(object, { size = 0.1, color = new Vec3(0.15, 0.86, 0.86), ...meshProps } = {}) {\n        const gl = object.gl;\n\n        const positionData = object.geometry.attributes.position.data;\n        const sizeData = new Float32Array([0, size]);\n\n        const indexAttr = object.geometry.attributes.index;\n        const getIndex = indexAttr ? (i) => indexAttr.data[i] : (i) => i;\n        const numVertices = indexAttr ? indexAttr.data.length : Math.floor(positionData.length / 3);\n\n        const nNormals = Math.floor(numVertices / 3);\n        const positionsArray = new Float32Array(nNormals * 2 * 3);\n        const normalsArray = new Float32Array(nNormals * 2 * 3);\n        const sizeArray = new Float32Array(nNormals * 2);\n\n        for (let i = 0; i < numVertices; i += 3) {\n            vA.fromArray(positionData, getIndex(i + 0) * 3);\n            vB.fromArray(positionData, getIndex(i + 1) * 3);\n            vC.fromArray(positionData, getIndex(i + 2) * 3);\n\n            vCenter\n                .add(vA, vB)\n                .add(vC)\n                .multiply(1 / 3);\n\n            vA.sub(vA, vB);\n            vC.sub(vC, vB);\n            vNormal.cross(vC, vA).normalize();\n\n            // duplicate position and normal for line start and end point\n            const i2 = i * 2;\n            positionsArray.set(vCenter, i2);\n            positionsArray.set(vCenter, i2 + 3);\n\n            normalsArray.set(vNormal, i2);\n            normalsArray.set(vNormal, i2 + 3);\n            sizeArray.set(sizeData, (i / 3) * 2);\n        }\n\n        const geometry = new Geometry(gl, {\n            position: { size: 3, data: positionsArray },\n            normal: { size: 3, data: normalsArray },\n            size: { size: 1, data: sizeArray },\n        });\n\n        const program = new Program(gl, {\n            vertex,\n            fragment,\n            uniforms: {\n                color: { value: color },\n                worldNormalMatrix: { value: new Mat3() },\n                objectWorldMatrix: { value: object.worldMatrix },\n            },\n        });\n\n        super(gl, { ...meshProps, mode: gl.LINES, geometry, program });\n\n        this.object = object;\n    }\n\n    draw(arg) {\n        this.program.uniforms.worldNormalMatrix.value.getNormalMatrix(this.object.worldMatrix);\n        super.draw(arg);\n    }\n}\n\nconst vertex = /* glsl */ `\nattribute vec3 position;\nattribute vec3 normal;\nattribute float size;\n\nuniform mat4 viewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 objectWorldMatrix;\nuniform mat3 worldNormalMatrix;\n\nvoid main() {\n    vec3 n = normalize(worldNormalMatrix * normal) * size;\n    vec3 p = (objectWorldMatrix * vec4(position, 1.0)).xyz;\n    gl_Position = projectionMatrix * viewMatrix * vec4(p + n, 1.0);\n}\n`;\n\nconst fragment = /* glsl */ `\nprecision highp float;\nuniform vec3 color;\n\nvoid main() {    \n    gl_FragColor = vec4(color, 1.0);\n}\n`;\n", "\"use client\"\nimport { Renderer, Triangle, Program, Color, Mesh } from 'ogl';\nimport React, { useRef, useEffect } from 'react';\n\nvar styles = {\"gradient-canvas\":\"styles-module_gradient-canvas__J1P0U\"};\n\nvar vert = \"\\nattribute vec2 uv;\\nattribute vec2 position;\\n\\nvarying vec2 vUv;\\n\\nvoid main() {\\n    vUv = uv;\\n    gl_Position = vec4(position, 0, 1);\\n}\";\n\nvar frag = \"\\nprecision highp float;\\n\\nuniform float uTime;\\nuniform vec3 uColor;\\n\\nvarying vec2 vUv;\\n\\nvoid main() {\\n    gl_FragColor.rgb = 0.5 + 0.3 * cos(vUv.xyx + uTime) + uColor;\\n    gl_FragColor.a = 1.0;\\n}\";\n\nfunction Lumiflex(props) {\n    const ctnDom = useRef(null);\n    useEffect(() => {\n        if (!ctnDom.current) {\n            return;\n        }\n        const ctn = ctnDom.current;\n        const renderer = new Renderer();\n        const gl = renderer.gl;\n        gl.clearColor(1, 1, 1, 1);\n        function resize() {\n            if (ctn == null) {\n                return;\n            }\n            const scale = 1;\n            // camera.perspective({\n            //   aspect: gl.canvas.width / gl.canvas.height,\n            // });\n            renderer.setSize(ctn.offsetWidth * scale, ctn.offsetHeight * scale);\n        }\n        window.addEventListener(\"resize\", resize, false);\n        resize();\n        // Rather than using a plane (two triangles) to cover the viewport here is a\n        // triangle that includes -1 to 1 range for 'position', and 0 to 1 range for 'uv'.\n        // Excess will be out of the viewport.\n        //         position                uv\n        //      (-1, 3)                  (0, 2)\n        //         |\\                      |\\\n        //         |__\\(1, 1)              |__\\(1, 1)\n        //         |__|_\\                  |__|_\\\n        //   (-1, -1)   (3, -1)        (0, 0)   (2, 0)\n        const geometry = new Triangle(gl);\n        const program = new Program(gl, {\n            vertex: vert,\n            fragment: frag,\n            uniforms: {\n                uTime: { value: 0 },\n                uColor: { value: new Color(0.3, 0.2, 0.5) },\n            },\n        });\n        const mesh = new Mesh(gl, { geometry, program });\n        let animateId;\n        animateId = requestAnimationFrame(update);\n        function update(t) {\n            animateId = requestAnimationFrame(update);\n            program.uniforms.uTime.value = t * 0.001;\n            // Don't need a camera if camera uniforms aren't required\n            renderer.render({ scene: mesh });\n        }\n        ctn.appendChild(gl.canvas);\n        return () => {\n            cancelAnimationFrame(animateId);\n            window.removeEventListener(\"resize\", resize);\n            ctn.removeChild(gl.canvas);\n            gl.getExtension(\"WEBGL_lose_context\")?.loseContext();\n        };\n    }, []);\n    return (React.createElement(\"div\", { ref: ctnDom, className: styles.gradientCanvas, style: {\n            width: \"100%\",\n            height: \"100%\",\n        }, ...props }));\n}\n\nexport { Lumiflex };\n", "\"use client\"\nimport React, { useRef, useEffect } from 'react';\n\n/*\n *   Stripe WebGl Gradient Animation\n *   All Credits to Stripe.com\n *   ScrollObserver functionality to disable animation when not scrolled into view has been disabled and\n *   commented out for now.\n *   https://kevinhufnagl.com\n *   From: https://gist.github.com/oaluna/3cc459a57259583464ee305f6153ba46\n */\n\n//Converting colors to proper format\nfunction normalizeColor(hexCode) {\n  return [\n    ((hexCode >> 16) & 255) / 255,\n    ((hexCode >> 8) & 255) / 255,\n    (255 & hexCode) / 255,\n  ];\n}\n[\"SCREEN\", \"LINEAR_LIGHT\"].reduce(\n  (hexCode, t, n) =>\n    Object.assign(hexCode, {\n      [t]: n,\n    }),\n  {}\n);\n\n//Essential functionality of WebGl\n//t = width\n//n = height\nclass MiniGl {\n  constructor(canvas, width, height, debug = false) {\n    const _miniGl = this,\n      debug_output =\n        -1 !== document.location.search.toLowerCase().indexOf(\"debug=webgl\");\n    (_miniGl.canvas = canvas),\n      (_miniGl.gl = _miniGl.canvas.getContext(\"webgl\", {\n        antialias: true,\n      })),\n      (_miniGl.meshes = []);\n    const context = _miniGl.gl;\n    width && height && this.setSize(width, height),\n      _miniGl.lastDebugMsg,\n      (_miniGl.debug =\n        debug && debug_output\n          ? function (e) {\n              const t = new Date();\n              t - _miniGl.lastDebugMsg > 1e3 && console.log(\"---\"),\n                console.log(\n                  t.toLocaleTimeString() +\n                    Array(Math.max(0, 32 - e.length)).join(\" \") +\n                    e +\n                    \": \",\n                  ...Array.from(arguments).slice(1)\n                ),\n                (_miniGl.lastDebugMsg = t);\n            }\n          : () => {}),\n      Object.defineProperties(_miniGl, {\n        Material: {\n          enumerable: false,\n          value: class {\n            constructor(vertexShaders, fragments, uniforms = {}) {\n              const material = this;\n              function getShaderByType(type, source) {\n                const shader = context.createShader(type);\n                return (\n                  context.shaderSource(shader, source),\n                  context.compileShader(shader),\n                  context.getShaderParameter(shader, context.COMPILE_STATUS) ||\n                    console.error(context.getShaderInfoLog(shader)),\n                  _miniGl.debug(\"Material.compileShaderSource\", {\n                    source: source,\n                  }),\n                  shader\n                );\n              }\n              function getUniformVariableDeclarations(uniforms, type) {\n                return Object.entries(uniforms)\n                  .map(([uniform, value]) =>\n                    value.getDeclaration(uniform, type)\n                  )\n                  .join(\"\\n\");\n              }\n              (material.uniforms = uniforms), (material.uniformInstances = []);\n\n              const prefix =\n                \"\\n              precision highp float;\\n            \";\n              (material.vertexSource = `\\n              ${prefix}\\n              attribute vec4 position;\\n              attribute vec2 uv;\\n              attribute vec2 uvNorm;\\n              ${getUniformVariableDeclarations(\n                _miniGl.commonUniforms,\n                \"vertex\"\n              )}\\n              ${getUniformVariableDeclarations(\n                uniforms,\n                \"vertex\"\n              )}\\n              ${vertexShaders}\\n            `),\n                (material.Source = `\\n              ${prefix}\\n              ${getUniformVariableDeclarations(\n                  _miniGl.commonUniforms,\n                  \"fragment\"\n                )}\\n              ${getUniformVariableDeclarations(\n                  uniforms,\n                  \"fragment\"\n                )}\\n              ${fragments}\\n            `),\n                (material.vertexShader = getShaderByType(\n                  context.VERTEX_SHADER,\n                  material.vertexSource\n                )),\n                (material.fragmentShader = getShaderByType(\n                  context.FRAGMENT_SHADER,\n                  material.Source\n                )),\n                (material.program = context.createProgram()),\n                context.attachShader(material.program, material.vertexShader),\n                context.attachShader(material.program, material.fragmentShader),\n                context.linkProgram(material.program),\n                context.getProgramParameter(\n                  material.program,\n                  context.LINK_STATUS\n                ) || console.error(context.getProgramInfoLog(material.program)),\n                context.useProgram(material.program),\n                material.attachUniforms(void 0, _miniGl.commonUniforms),\n                material.attachUniforms(void 0, material.uniforms);\n            }\n            //t = uniform\n            attachUniforms(name, uniforms) {\n              //n  = material\n              const material = this;\n              void 0 === name\n                ? Object.entries(uniforms).forEach(([name, uniform]) => {\n                    material.attachUniforms(name, uniform);\n                  })\n                : \"array\" == uniforms.type\n                ? uniforms.value.forEach((uniform, i) =>\n                    material.attachUniforms(`${name}[${i}]`, uniform)\n                  )\n                : \"struct\" == uniforms.type\n                ? Object.entries(uniforms.value).forEach(([uniform, i]) =>\n                    material.attachUniforms(`${name}.${uniform}`, i)\n                  )\n                : (_miniGl.debug(\"Material.attachUniforms\", {\n                    name: name,\n                    uniform: uniforms,\n                  }),\n                  material.uniformInstances.push({\n                    uniform: uniforms,\n                    location: context.getUniformLocation(\n                      material.program,\n                      name\n                    ),\n                  }));\n            }\n          },\n        },\n        Uniform: {\n          enumerable: !1,\n          value: class {\n            constructor(e) {\n              (this.type = \"float\"), Object.assign(this, e);\n              (this.typeFn =\n                {\n                  float: \"1f\",\n                  int: \"1i\",\n                  vec2: \"2fv\",\n                  vec3: \"3fv\",\n                  vec4: \"4fv\",\n                  mat4: \"Matrix4fv\",\n                }[this.type] || \"1f\"),\n                this.update();\n            }\n            update(value) {\n              void 0 !== this.value &&\n                context[`uniform${this.typeFn}`](\n                  value,\n                  0 === this.typeFn.indexOf(\"Matrix\")\n                    ? this.transpose\n                    : this.value,\n                  0 === this.typeFn.indexOf(\"Matrix\") ? this.value : null\n                );\n            }\n            //e - name\n            //t - type\n            //n - length\n            getDeclaration(name, type, length) {\n              const uniform = this;\n              if (uniform.excludeFrom !== type) {\n                if (\"array\" === uniform.type)\n                  return (\n                    uniform.value[0].getDeclaration(\n                      name,\n                      type,\n                      uniform.value.length\n                    ) + `\\nconst int ${name}_length = ${uniform.value.length};`\n                  );\n                if (\"struct\" === uniform.type) {\n                  let name_no_prefix = name.replace(\"u_\", \"\");\n                  return (\n                    (name_no_prefix =\n                      name_no_prefix.charAt(0).toUpperCase() +\n                      name_no_prefix.slice(1)),\n                    `uniform struct ${name_no_prefix} \n                                {\\n` +\n                      Object.entries(uniform.value)\n                        .map(([name, uniform]) =>\n                          uniform\n                            .getDeclaration(name, type)\n                            .replace(/^uniform/, \"\")\n                        )\n                        .join(\"\") +\n                      `\\n} ${name}${length > 0 ? `[${length}]` : \"\"};`\n                  );\n                }\n                return `uniform ${uniform.type} ${name}${\n                  length > 0 ? `[${length}]` : \"\"\n                };`;\n              }\n            }\n          },\n        },\n        PlaneGeometry: {\n          enumerable: !1,\n          value: class {\n            constructor(width, height, n, i, orientation) {\n              context.createBuffer(),\n                (this.attributes = {\n                  position: new _miniGl.Attribute({\n                    target: context.ARRAY_BUFFER,\n                    size: 3,\n                  }),\n                  uv: new _miniGl.Attribute({\n                    target: context.ARRAY_BUFFER,\n                    size: 2,\n                  }),\n                  uvNorm: new _miniGl.Attribute({\n                    target: context.ARRAY_BUFFER,\n                    size: 2,\n                  }),\n                  index: new _miniGl.Attribute({\n                    target: context.ELEMENT_ARRAY_BUFFER,\n                    size: 3,\n                    type: context.UNSIGNED_SHORT,\n                  }),\n                }),\n                this.setTopology(n, i),\n                this.setSize(width, height, orientation);\n            }\n            setTopology(e = 1, t = 1) {\n              const n = this;\n              (n.xSegCount = e),\n                (n.ySegCount = t),\n                (n.vertexCount = (n.xSegCount + 1) * (n.ySegCount + 1)),\n                (n.quadCount = n.xSegCount * n.ySegCount * 2),\n                (n.attributes.uv.values = new Float32Array(2 * n.vertexCount)),\n                (n.attributes.uvNorm.values = new Float32Array(\n                  2 * n.vertexCount\n                )),\n                (n.attributes.index.values = new Uint16Array(3 * n.quadCount));\n              for (let e = 0; e <= n.ySegCount; e++)\n                for (let t = 0; t <= n.xSegCount; t++) {\n                  const i = e * (n.xSegCount + 1) + t;\n                  if (\n                    ((n.attributes.uv.values[2 * i] = t / n.xSegCount),\n                    (n.attributes.uv.values[2 * i + 1] = 1 - e / n.ySegCount),\n                    (n.attributes.uvNorm.values[2 * i] =\n                      (t / n.xSegCount) * 2 - 1),\n                    (n.attributes.uvNorm.values[2 * i + 1] =\n                      1 - (e / n.ySegCount) * 2),\n                    t < n.xSegCount && e < n.ySegCount)\n                  ) {\n                    const s = e * n.xSegCount + t;\n                    (n.attributes.index.values[6 * s] = i),\n                      (n.attributes.index.values[6 * s + 1] =\n                        i + 1 + n.xSegCount),\n                      (n.attributes.index.values[6 * s + 2] = i + 1),\n                      (n.attributes.index.values[6 * s + 3] = i + 1),\n                      (n.attributes.index.values[6 * s + 4] =\n                        i + 1 + n.xSegCount),\n                      (n.attributes.index.values[6 * s + 5] =\n                        i + 2 + n.xSegCount);\n                  }\n                }\n              n.attributes.uv.update(),\n                n.attributes.uvNorm.update(),\n                n.attributes.index.update(),\n                _miniGl.debug(\"Geometry.setTopology\", {\n                  uv: n.attributes.uv,\n                  uvNorm: n.attributes.uvNorm,\n                  index: n.attributes.index,\n                });\n            }\n            setSize(width = 1, height = 1, orientation = \"xz\") {\n              const geometry = this;\n              (geometry.width = width),\n                (geometry.height = height),\n                (geometry.orientation = orientation),\n                (geometry.attributes.position.values &&\n                  geometry.attributes.position.values.length ===\n                    3 * geometry.vertexCount) ||\n                  (geometry.attributes.position.values = new Float32Array(\n                    3 * geometry.vertexCount\n                  ));\n              const o = width / -2,\n                r = height / -2,\n                segment_width = width / geometry.xSegCount,\n                segment_height = height / geometry.ySegCount;\n              for (let yIndex = 0; yIndex <= geometry.ySegCount; yIndex++) {\n                const t = r + yIndex * segment_height;\n                for (let xIndex = 0; xIndex <= geometry.xSegCount; xIndex++) {\n                  const r = o + xIndex * segment_width,\n                    l = yIndex * (geometry.xSegCount + 1) + xIndex;\n                  (geometry.attributes.position.values[\n                    3 * l + \"xyz\".indexOf(orientation[0])\n                  ] = r),\n                    (geometry.attributes.position.values[\n                      3 * l + \"xyz\".indexOf(orientation[1])\n                    ] = -t);\n                }\n              }\n              geometry.attributes.position.update(),\n                _miniGl.debug(\"Geometry.setSize\", {\n                  position: geometry.attributes.position,\n                });\n            }\n          },\n        },\n        Mesh: {\n          enumerable: !1,\n          value: class {\n            constructor(geometry, material) {\n              const mesh = this;\n              (mesh.geometry = geometry),\n                (mesh.material = material),\n                (mesh.wireframe = !1),\n                (mesh.attributeInstances = []),\n                Object.entries(mesh.geometry.attributes).forEach(\n                  ([e, attribute]) => {\n                    mesh.attributeInstances.push({\n                      attribute: attribute,\n                      location: attribute.attach(e, mesh.material.program),\n                    });\n                  }\n                ),\n                _miniGl.meshes.push(mesh),\n                _miniGl.debug(\"Mesh.constructor\", {\n                  mesh: mesh,\n                });\n            }\n            draw() {\n              context.useProgram(this.material.program),\n                this.material.uniformInstances.forEach(\n                  ({ uniform: e, location: t }) => e.update(t)\n                ),\n                this.attributeInstances.forEach(\n                  ({ attribute: e, location: t }) => e.use(t)\n                ),\n                context.drawElements(\n                  this.wireframe ? context.LINES : context.TRIANGLES,\n                  this.geometry.attributes.index.values.length,\n                  context.UNSIGNED_SHORT,\n                  0\n                );\n            }\n            remove() {\n              _miniGl.meshes = _miniGl.meshes.filter((e) => e != this);\n            }\n          },\n        },\n        Attribute: {\n          enumerable: !1,\n          value: class {\n            constructor(e) {\n              (this.type = context.FLOAT),\n                (this.normalized = !1),\n                (this.buffer = context.createBuffer()),\n                Object.assign(this, e),\n                this.update();\n            }\n            update() {\n              void 0 !== this.values &&\n                (context.bindBuffer(this.target, this.buffer),\n                context.bufferData(\n                  this.target,\n                  this.values,\n                  context.STATIC_DRAW\n                ));\n            }\n            attach(e, t) {\n              const n = context.getAttribLocation(t, e);\n              return (\n                this.target === context.ARRAY_BUFFER &&\n                  (context.enableVertexAttribArray(n),\n                  context.vertexAttribPointer(\n                    n,\n                    this.size,\n                    this.type,\n                    this.normalized,\n                    0,\n                    0\n                  )),\n                n\n              );\n            }\n            use(e) {\n              context.bindBuffer(this.target, this.buffer),\n                this.target === context.ARRAY_BUFFER &&\n                  (context.enableVertexAttribArray(e),\n                  context.vertexAttribPointer(\n                    e,\n                    this.size,\n                    this.type,\n                    this.normalized,\n                    0,\n                    0\n                  ));\n            }\n          },\n        },\n      });\n    const a = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\n    _miniGl.commonUniforms = {\n      projectionMatrix: new _miniGl.Uniform({\n        type: \"mat4\",\n        value: a,\n      }),\n      modelViewMatrix: new _miniGl.Uniform({\n        type: \"mat4\",\n        value: a,\n      }),\n      resolution: new _miniGl.Uniform({\n        type: \"vec2\",\n        value: [1, 1],\n      }),\n      aspectRatio: new _miniGl.Uniform({\n        type: \"float\",\n        value: 1,\n      }),\n    };\n  }\n  setSize(e = 640, t = 480) {\n    (this.width = e),\n      (this.height = t),\n      (this.canvas.width = e),\n      (this.canvas.height = t),\n      this.gl.viewport(0, 0, e, t),\n      (this.commonUniforms.resolution.value = [e, t]),\n      (this.commonUniforms.aspectRatio.value = e / t),\n      this.debug(\"MiniGL.setSize\", {\n        width: e,\n        height: t,\n      });\n  }\n  //left, right, top, bottom, near, far\n  setOrthographicCamera(e = 0, t = 0, n = 0, i = -2e3, s = 2e3) {\n    (this.commonUniforms.projectionMatrix.value = [\n      2 / this.width,\n      0,\n      0,\n      0,\n      0,\n      2 / this.height,\n      0,\n      0,\n      0,\n      0,\n      2 / (i - s),\n      0,\n      e,\n      t,\n      n,\n      1,\n    ]),\n      this.debug(\n        \"setOrthographicCamera\",\n        this.commonUniforms.projectionMatrix.value\n      );\n  }\n  render() {\n    this.gl.clearColor(0, 0, 0, 0),\n      this.gl.clearDepth(1),\n      this.meshes.forEach((e) => e.draw());\n  }\n}\n\n//Sets initial properties\nfunction e(object, propertyName, val) {\n  return (\n    propertyName in object\n      ? Object.defineProperty(object, propertyName, {\n          value: val,\n          enumerable: !0,\n          configurable: !0,\n          writable: !0,\n        })\n      : (object[propertyName] = val),\n    object\n  );\n}\n\n//Gradient object\nclass Gradient {\n  constructor() {\n    e(this, \"el\", void 0),\n      e(this, \"gradientColors\", void 0),\n      e(this, \"cssVarRetries\", 0),\n      e(this, \"maxCssVarRetries\", 200),\n      e(this, \"angle\", 0),\n      e(this, \"isLoadedClass\", !1),\n      e(this, \"isScrolling\", !1),\n      /*e(this, \"isStatic\", o.disableAmbientAnimations()),*/ e(\n        this,\n        \"scrollingTimeout\",\n        void 0\n      ),\n      e(this, \"scrollingRefreshDelay\", 200),\n      e(this, \"isIntersecting\", !1),\n      e(this, \"shaderFiles\", void 0),\n      e(this, \"vertexShader\", void 0),\n      e(this, \"sectionColors\", void 0),\n      e(this, \"conf\", void 0),\n      e(this, \"uniforms\", void 0),\n      e(this, \"t\", 1253106),\n      e(this, \"last\", 0),\n      e(this, \"width\", void 0),\n      e(this, \"minWidth\", 1111),\n      e(this, \"height\", 600),\n      e(this, \"xSegCount\", void 0),\n      e(this, \"ySegCount\", void 0),\n      e(this, \"mesh\", void 0),\n      e(this, \"material\", void 0),\n      e(this, \"geometry\", void 0),\n      e(this, \"minigl\", void 0),\n      e(this, \"scrollObserver\", void 0),\n      e(this, \"amp\", 320),\n      e(this, \"seed\", 5),\n      e(this, \"freqX\", 14e-5),\n      e(this, \"freqY\", 29e-5),\n      e(this, \"freqDelta\", 1e-5),\n      e(this, \"activeColors\", [1, 1, 1, 1]),\n      e(this, \"isMetaKey\", !1),\n      e(this, \"isGradientLegendVisible\", !1),\n      e(this, \"isMouseDown\", !1),\n      e(this, \"handleScroll\", () => {\n        clearTimeout(this.scrollingTimeout),\n          (this.scrollingTimeout = setTimeout(\n            this.handleScrollEnd,\n            this.scrollingRefreshDelay\n          )),\n          this.isGradientLegendVisible && this.hideGradientLegend(),\n          this.conf.playing && ((this.isScrolling = !0), this.pause());\n      }),\n      e(this, \"handleScrollEnd\", () => {\n        (this.isScrolling = !1), this.isIntersecting && this.play();\n      }),\n      e(this, \"resize\", () => {\n        (this.width = window.innerWidth),\n          this.minigl.setSize(this.width, this.height),\n          this.minigl.setOrthographicCamera(),\n          (this.xSegCount = Math.ceil(this.width * this.conf.density[0])),\n          (this.ySegCount = Math.ceil(this.height * this.conf.density[1])),\n          this.mesh.geometry.setTopology(this.xSegCount, this.ySegCount),\n          this.mesh.geometry.setSize(this.width, this.height),\n          (this.mesh.material.uniforms.u_shadow_power.value =\n            this.width < 600 ? 5 : 6);\n      }),\n      // e(this, \"handleMouseDown\", (e) => {\n      //   this.isGradientLegendVisible &&\n      //     ((this.isMetaKey = e.metaKey),\n      //     (this.isMouseDown = !0),\n      //     !1 === this.conf.playing && requestAnimationFrame(this.animate));\n      // }),\n      // e(this, \"handleMouseUp\", () => {\n      //   this.isMouseDown = !1;\n      // }),\n      e(this, \"animate\", (e) => {\n        if (!this.shouldSkipFrame(e) || this.isMouseDown) {\n          if (\n            ((this.t += Math.min(e - this.last, 1e3 / 15)),\n            (this.last = e),\n            this.isMouseDown)\n          ) {\n            let e = 160;\n            this.isMetaKey && (e = -160), (this.t += e);\n          }\n          (this.mesh.material.uniforms.u_time.value = this.t),\n            this.minigl.render();\n        }\n        if (0 !== this.last && this.isStatic)\n          return this.minigl.render(), void this.disconnect();\n        /*this.isIntersecting && */ (this.conf.playing || this.isMouseDown) &&\n          requestAnimationFrame(this.animate);\n      }),\n      e(this, \"addIsLoadedClass\", () => {\n        /*this.isIntersecting && */ !this.isLoadedClass &&\n          ((this.isLoadedClass = !0), this.el.classList.add(\"isLoaded\"));\n        // setTimeout(() => {\n        //   this.el.parentElement.classList.add(\"isLoaded\");\n        // }, 3e3)\n      }),\n      e(this, \"pause\", () => {\n        this.conf.playing = false;\n      }),\n      e(this, \"play\", () => {\n        requestAnimationFrame(this.animate), (this.conf.playing = true);\n      }),\n      e(this, \"initGradient\", (options) => {\n        // this.el = document.querySelector(selector);\n        const { el, gradientColors = [] } = options || {};\n        this.el = el || document.createElement(\"canvas\");\n        this.gradientColors = gradientColors;\n        this.connect();\n        return this;\n      });\n  }\n  async connect() {\n    (this.shaderFiles = {\n      vertex:\n        \"varying vec3 v_color;\\n\\nvoid main() {\\n  float time = u_time * u_global.noiseSpeed;\\n\\n  vec2 noiseCoord = resolution * uvNorm * u_global.noiseFreq;\\n\\n  vec2 st = 1. - uvNorm.xy;\\n\\n  //\\n  // Tilting the plane\\n  //\\n\\n  // Front-to-back tilt\\n  float tilt = resolution.y / 2.0 * uvNorm.y;\\n\\n  // Left-to-right angle\\n  float incline = resolution.x * uvNorm.x / 2.0 * u_vertDeform.incline;\\n\\n  // Up-down shift to offset incline\\n  float offset = resolution.x / 2.0 * u_vertDeform.incline * mix(u_vertDeform.offsetBottom, u_vertDeform.offsetTop, uv.y);\\n\\n  //\\n  // Vertex noise\\n  //\\n\\n  float noise = snoise(vec3(\\n    noiseCoord.x * u_vertDeform.noiseFreq.x + time * u_vertDeform.noiseFlow,\\n    noiseCoord.y * u_vertDeform.noiseFreq.y,\\n    time * u_vertDeform.noiseSpeed + u_vertDeform.noiseSeed\\n  )) * u_vertDeform.noiseAmp;\\n\\n  // Fade noise to zero at edges\\n  noise *= 1.0 - pow(abs(uvNorm.y), 2.0);\\n\\n  // Clamp to 0\\n  noise = max(0.0, noise);\\n\\n  vec3 pos = vec3(\\n    position.x,\\n    position.y + tilt + incline + noise - offset,\\n    position.z\\n  );\\n\\n  //\\n  // Vertex color, to be passed to fragment shader\\n  //\\n\\n  if (u_active_colors[0] == 1.) {\\n    v_color = u_baseColor;\\n  }\\n\\n  for (int i = 0; i < u_waveLayers_length; i++) {\\n    if (u_active_colors[i + 1] == 1.) {\\n      WaveLayers layer = u_waveLayers[i];\\n\\n      float noise = smoothstep(\\n        layer.noiseFloor,\\n        layer.noiseCeil,\\n        snoise(vec3(\\n          noiseCoord.x * layer.noiseFreq.x + time * layer.noiseFlow,\\n          noiseCoord.y * layer.noiseFreq.y,\\n          time * layer.noiseSpeed + layer.noiseSeed\\n        )) / 2.0 + 0.5\\n      );\\n\\n      v_color = blendNormal(v_color, layer.color, pow(noise, 4.));\\n    }\\n  }\\n\\n  //\\n  // Finish\\n  //\\n\\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);\\n}\",\n      noise:\n        \"//\\n// Description : Array and textureless GLSL 2D/3D/4D simplex\\n//               noise functions.\\n//      Author : Ian McEwan, Ashima Arts.\\n//  Maintainer : stegu\\n//     Lastmod : 20110822 (ijm)\\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\\n//               Distributed under the MIT License. See LICENSE file.\\n//               https://github.com/ashima/webgl-noise\\n//               https://github.com/stegu/webgl-noise\\n//\\n\\nvec3 mod289(vec3 x) {\\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\\n}\\n\\nvec4 mod289(vec4 x) {\\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\\n}\\n\\nvec4 permute(vec4 x) {\\n    return mod289(((x*34.0)+1.0)*x);\\n}\\n\\nvec4 taylorInvSqrt(vec4 r)\\n{\\n  return 1.79284291400159 - 0.85373472095314 * r;\\n}\\n\\nfloat snoise(vec3 v)\\n{\\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\\n\\n// First corner\\n  vec3 i  = floor(v + dot(v, C.yyy) );\\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\\n\\n// Other corners\\n  vec3 g = step(x0.yzx, x0.xyz);\\n  vec3 l = 1.0 - g;\\n  vec3 i1 = min( g.xyz, l.zxy );\\n  vec3 i2 = max( g.xyz, l.zxy );\\n\\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\\n  vec3 x1 = x0 - i1 + C.xxx;\\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\\n\\n// Permutations\\n  i = mod289(i);\\n  vec4 p = permute( permute( permute(\\n            i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\\n          + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\\n          + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\\n\\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\\n  float n_ = 0.142857142857; // 1.0/7.0\\n  vec3  ns = n_ * D.wyz - D.xzx;\\n\\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\\n\\n  vec4 x_ = floor(j * ns.z);\\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\\n\\n  vec4 x = x_ *ns.x + ns.yyyy;\\n  vec4 y = y_ *ns.x + ns.yyyy;\\n  vec4 h = 1.0 - abs(x) - abs(y);\\n\\n  vec4 b0 = vec4( x.xy, y.xy );\\n  vec4 b1 = vec4( x.zw, y.zw );\\n\\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\\n  vec4 s0 = floor(b0)*2.0 + 1.0;\\n  vec4 s1 = floor(b1)*2.0 + 1.0;\\n  vec4 sh = -step(h, vec4(0.0));\\n\\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\\n\\n  vec3 p0 = vec3(a0.xy,h.x);\\n  vec3 p1 = vec3(a0.zw,h.y);\\n  vec3 p2 = vec3(a1.xy,h.z);\\n  vec3 p3 = vec3(a1.zw,h.w);\\n\\n//Normalise gradients\\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\\n  p0 *= norm.x;\\n  p1 *= norm.y;\\n  p2 *= norm.z;\\n  p3 *= norm.w;\\n\\n// Mix final noise value\\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\\n  m = m * m;\\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\\n                                dot(p2,x2), dot(p3,x3) ) );\\n}\",\n      blend:\n        \"//\\n// https://github.com/jamieowen/glsl-blend\\n//\\n\\n// Normal\\n\\nvec3 blendNormal(vec3 base, vec3 blend) {\\n\\treturn blend;\\n}\\n\\nvec3 blendNormal(vec3 base, vec3 blend, float opacity) {\\n\\treturn (blendNormal(base, blend) * opacity + base * (1.0 - opacity));\\n}\\n\\n// Screen\\n\\nfloat blendScreen(float base, float blend) {\\n\\treturn 1.0-((1.0-base)*(1.0-blend));\\n}\\n\\nvec3 blendScreen(vec3 base, vec3 blend) {\\n\\treturn vec3(blendScreen(base.r,blend.r),blendScreen(base.g,blend.g),blendScreen(base.b,blend.b));\\n}\\n\\nvec3 blendScreen(vec3 base, vec3 blend, float opacity) {\\n\\treturn (blendScreen(base, blend) * opacity + base * (1.0 - opacity));\\n}\\n\\n// Multiply\\n\\nvec3 blendMultiply(vec3 base, vec3 blend) {\\n\\treturn base*blend;\\n}\\n\\nvec3 blendMultiply(vec3 base, vec3 blend, float opacity) {\\n\\treturn (blendMultiply(base, blend) * opacity + base * (1.0 - opacity));\\n}\\n\\n// Overlay\\n\\nfloat blendOverlay(float base, float blend) {\\n\\treturn base<0.5?(2.0*base*blend):(1.0-2.0*(1.0-base)*(1.0-blend));\\n}\\n\\nvec3 blendOverlay(vec3 base, vec3 blend) {\\n\\treturn vec3(blendOverlay(base.r,blend.r),blendOverlay(base.g,blend.g),blendOverlay(base.b,blend.b));\\n}\\n\\nvec3 blendOverlay(vec3 base, vec3 blend, float opacity) {\\n\\treturn (blendOverlay(base, blend) * opacity + base * (1.0 - opacity));\\n}\\n\\n// Hard light\\n\\nvec3 blendHardLight(vec3 base, vec3 blend) {\\n\\treturn blendOverlay(blend,base);\\n}\\n\\nvec3 blendHardLight(vec3 base, vec3 blend, float opacity) {\\n\\treturn (blendHardLight(base, blend) * opacity + base * (1.0 - opacity));\\n}\\n\\n// Soft light\\n\\nfloat blendSoftLight(float base, float blend) {\\n\\treturn (blend<0.5)?(2.0*base*blend+base*base*(1.0-2.0*blend)):(sqrt(base)*(2.0*blend-1.0)+2.0*base*(1.0-blend));\\n}\\n\\nvec3 blendSoftLight(vec3 base, vec3 blend) {\\n\\treturn vec3(blendSoftLight(base.r,blend.r),blendSoftLight(base.g,blend.g),blendSoftLight(base.b,blend.b));\\n}\\n\\nvec3 blendSoftLight(vec3 base, vec3 blend, float opacity) {\\n\\treturn (blendSoftLight(base, blend) * opacity + base * (1.0 - opacity));\\n}\\n\\n// Color dodge\\n\\nfloat blendColorDodge(float base, float blend) {\\n\\treturn (blend==1.0)?blend:min(base/(1.0-blend),1.0);\\n}\\n\\nvec3 blendColorDodge(vec3 base, vec3 blend) {\\n\\treturn vec3(blendColorDodge(base.r,blend.r),blendColorDodge(base.g,blend.g),blendColorDodge(base.b,blend.b));\\n}\\n\\nvec3 blendColorDodge(vec3 base, vec3 blend, float opacity) {\\n\\treturn (blendColorDodge(base, blend) * opacity + base * (1.0 - opacity));\\n}\\n\\n// Color burn\\n\\nfloat blendColorBurn(float base, float blend) {\\n\\treturn (blend==0.0)?blend:max((1.0-((1.0-base)/blend)),0.0);\\n}\\n\\nvec3 blendColorBurn(vec3 base, vec3 blend) {\\n\\treturn vec3(blendColorBurn(base.r,blend.r),blendColorBurn(base.g,blend.g),blendColorBurn(base.b,blend.b));\\n}\\n\\nvec3 blendColorBurn(vec3 base, vec3 blend, float opacity) {\\n\\treturn (blendColorBurn(base, blend) * opacity + base * (1.0 - opacity));\\n}\\n\\n// Vivid Light\\n\\nfloat blendVividLight(float base, float blend) {\\n\\treturn (blend<0.5)?blendColorBurn(base,(2.0*blend)):blendColorDodge(base,(2.0*(blend-0.5)));\\n}\\n\\nvec3 blendVividLight(vec3 base, vec3 blend) {\\n\\treturn vec3(blendVividLight(base.r,blend.r),blendVividLight(base.g,blend.g),blendVividLight(base.b,blend.b));\\n}\\n\\nvec3 blendVividLight(vec3 base, vec3 blend, float opacity) {\\n\\treturn (blendVividLight(base, blend) * opacity + base * (1.0 - opacity));\\n}\\n\\n// Lighten\\n\\nfloat blendLighten(float base, float blend) {\\n\\treturn max(blend,base);\\n}\\n\\nvec3 blendLighten(vec3 base, vec3 blend) {\\n\\treturn vec3(blendLighten(base.r,blend.r),blendLighten(base.g,blend.g),blendLighten(base.b,blend.b));\\n}\\n\\nvec3 blendLighten(vec3 base, vec3 blend, float opacity) {\\n\\treturn (blendLighten(base, blend) * opacity + base * (1.0 - opacity));\\n}\\n\\n// Linear burn\\n\\nfloat blendLinearBurn(float base, float blend) {\\n\\t// Note : Same implementation as BlendSubtractf\\n\\treturn max(base+blend-1.0,0.0);\\n}\\n\\nvec3 blendLinearBurn(vec3 base, vec3 blend) {\\n\\t// Note : Same implementation as BlendSubtract\\n\\treturn max(base+blend-vec3(1.0),vec3(0.0));\\n}\\n\\nvec3 blendLinearBurn(vec3 base, vec3 blend, float opacity) {\\n\\treturn (blendLinearBurn(base, blend) * opacity + base * (1.0 - opacity));\\n}\\n\\n// Linear dodge\\n\\nfloat blendLinearDodge(float base, float blend) {\\n\\t// Note : Same implementation as BlendAddf\\n\\treturn min(base+blend,1.0);\\n}\\n\\nvec3 blendLinearDodge(vec3 base, vec3 blend) {\\n\\t// Note : Same implementation as BlendAdd\\n\\treturn min(base+blend,vec3(1.0));\\n}\\n\\nvec3 blendLinearDodge(vec3 base, vec3 blend, float opacity) {\\n\\treturn (blendLinearDodge(base, blend) * opacity + base * (1.0 - opacity));\\n}\\n\\n// Linear light\\n\\nfloat blendLinearLight(float base, float blend) {\\n\\treturn blend<0.5?blendLinearBurn(base,(2.0*blend)):blendLinearDodge(base,(2.0*(blend-0.5)));\\n}\\n\\nvec3 blendLinearLight(vec3 base, vec3 blend) {\\n\\treturn vec3(blendLinearLight(base.r,blend.r),blendLinearLight(base.g,blend.g),blendLinearLight(base.b,blend.b));\\n}\\n\\nvec3 blendLinearLight(vec3 base, vec3 blend, float opacity) {\\n\\treturn (blendLinearLight(base, blend) * opacity + base * (1.0 - opacity));\\n}\",\n      fragment:\n        \"varying vec3 v_color;\\n\\nvoid main() {\\n  vec3 color = v_color;\\n  if (u_darken_top == 1.0) {\\n    vec2 st = gl_FragCoord.xy/resolution.xy;\\n    color.g -= pow(st.y + sin(-12.0) * st.x, u_shadow_power) * 0.4;\\n  }\\n  gl_FragColor = vec4(color, 1.0);\\n}\",\n    }),\n      (this.conf = {\n        presetName: \"\",\n        wireframe: false,\n        density: [0.06, 0.16],\n        zoom: 1,\n        rotation: 0,\n        playing: true,\n      }),\n      ((this.minigl = new MiniGl(this.el, null, null, !0)),\n      (this.init(), this.addIsLoadedClass()));\n    /*\n        this.scrollObserver = await s.create(.1, !1),\n        this.scrollObserver.observe(this.el),\n        this.scrollObserver.onSeparate(() => {\n            window.removeEventListener(\"scroll\", this.handleScroll), window.removeEventListener(\"mousedown\", this.handleMouseDown), window.removeEventListener(\"mouseup\", this.handleMouseUp), window.removeEventListener(\"keydown\", this.handleKeyDown), this.isIntersecting = !1, this.conf.playing && this.pause()\n        }), \n        this.scrollObserver.onIntersect(() => {\n            window.addEventListener(\"scroll\", this.handleScroll), window.addEventListener(\"mousedown\", this.handleMouseDown), window.addEventListener(\"mouseup\", this.handleMouseUp), window.addEventListener(\"keydown\", this.handleKeyDown), this.isIntersecting = !0, this.addIsLoadedClass(), this.play()\n        })*/\n  }\n  disconnect() {\n    this.scrollObserver &&\n      (window.removeEventListener(\"scroll\", this.handleScroll),\n      window.removeEventListener(\"mousedown\", this.handleMouseDown),\n      window.removeEventListener(\"mouseup\", this.handleMouseUp),\n      window.removeEventListener(\"keydown\", this.handleKeyDown),\n      this.scrollObserver.disconnect()),\n      window.removeEventListener(\"resize\", this.resize);\n  }\n  initMaterial() {\n    this.uniforms = {\n      u_time: new this.minigl.Uniform({\n        value: 0,\n      }),\n      u_shadow_power: new this.minigl.Uniform({\n        value: 5,\n      }),\n      u_darken_top: new this.minigl.Uniform({\n        value: \"\" === this.el.dataset.jsDarkenTop ? 1 : 0,\n      }),\n      u_active_colors: new this.minigl.Uniform({\n        value: this.activeColors,\n        type: \"vec4\",\n      }),\n      u_global: new this.minigl.Uniform({\n        value: {\n          noiseFreq: new this.minigl.Uniform({\n            value: [this.freqX, this.freqY],\n            type: \"vec2\",\n          }),\n          noiseSpeed: new this.minigl.Uniform({\n            value: 5e-6,\n          }),\n        },\n        type: \"struct\",\n      }),\n      u_vertDeform: new this.minigl.Uniform({\n        value: {\n          incline: new this.minigl.Uniform({\n            value: Math.sin(this.angle) / Math.cos(this.angle),\n          }),\n          offsetTop: new this.minigl.Uniform({\n            value: -0.5,\n          }),\n          offsetBottom: new this.minigl.Uniform({\n            value: -0.5,\n          }),\n          noiseFreq: new this.minigl.Uniform({\n            value: [3, 4],\n            type: \"vec2\",\n          }),\n          noiseAmp: new this.minigl.Uniform({\n            value: this.amp,\n          }),\n          noiseSpeed: new this.minigl.Uniform({\n            value: 10,\n          }),\n          noiseFlow: new this.minigl.Uniform({\n            value: 3,\n          }),\n          noiseSeed: new this.minigl.Uniform({\n            value: this.seed,\n          }),\n        },\n        type: \"struct\",\n        excludeFrom: \"fragment\",\n      }),\n      u_baseColor: new this.minigl.Uniform({\n        value: this.sectionColors[0],\n        type: \"vec3\",\n        excludeFrom: \"fragment\",\n      }),\n      u_waveLayers: new this.minigl.Uniform({\n        value: [],\n        excludeFrom: \"fragment\",\n        type: \"array\",\n      }),\n    };\n    for (let e = 1; e < this.sectionColors.length; e += 1)\n      this.uniforms.u_waveLayers.value.push(\n        new this.minigl.Uniform({\n          value: {\n            color: new this.minigl.Uniform({\n              value: this.sectionColors[e],\n              type: \"vec3\",\n            }),\n            noiseFreq: new this.minigl.Uniform({\n              value: [\n                2 + e / this.sectionColors.length,\n                3 + e / this.sectionColors.length,\n              ],\n              type: \"vec2\",\n            }),\n            noiseSpeed: new this.minigl.Uniform({\n              value: 11 + 0.3 * e,\n            }),\n            noiseFlow: new this.minigl.Uniform({\n              value: 6.5 + 0.3 * e,\n            }),\n            noiseSeed: new this.minigl.Uniform({\n              value: this.seed + 10 * e,\n            }),\n            noiseFloor: new this.minigl.Uniform({\n              value: 0.1,\n            }),\n            noiseCeil: new this.minigl.Uniform({\n              value: 0.63 + 0.07 * e,\n            }),\n          },\n          type: \"struct\",\n        })\n      );\n    return (\n      (this.vertexShader = [\n        this.shaderFiles.noise,\n        this.shaderFiles.blend,\n        this.shaderFiles.vertex,\n      ].join(\"\\n\\n\")),\n      new this.minigl.Material(\n        this.vertexShader,\n        this.shaderFiles.fragment,\n        this.uniforms\n      )\n    );\n  }\n  initMesh() {\n    (this.material = this.initMaterial()),\n      (this.geometry = new this.minigl.PlaneGeometry()),\n      (this.mesh = new this.minigl.Mesh(this.geometry, this.material));\n  }\n  shouldSkipFrame(e) {\n    return (\n      !!window.document.hidden ||\n      !this.conf.playing ||\n      parseInt(e, 10) % 2 == 0 ||\n      void 0\n    );\n  }\n  updateFrequency(e) {\n    (this.freqX += e), (this.freqY += e);\n  }\n  toggleColor(index) {\n    this.activeColors[index] = 0 === this.activeColors[index] ? 1 : 0;\n  }\n  showGradientLegend() {\n    this.width > this.minWidth &&\n      ((this.isGradientLegendVisible = !0),\n      document.body.classList.add(\"isGradientLegendVisible\"));\n  }\n  hideGradientLegend() {\n    (this.isGradientLegendVisible = !1),\n      document.body.classList.remove(\"isGradientLegendVisible\");\n  }\n  init() {\n    this.initGradientColors(),\n      this.initMesh(),\n      this.resize(),\n      requestAnimationFrame(this.animate),\n      window.addEventListener(\"resize\", this.resize);\n  }\n  /*\n   * Initializes the four section colors by retrieving them from css variables.\n   */\n  initGradientColors() {\n    this.sectionColors = this.gradientColors\n      .map((hex) => {\n        //Check if shorthand hex value was used and double the length so the conversion in normalizeColor will work.\n        if (4 === hex.length) {\n          const hexTemp = hex\n            .substr(1)\n            .split(\"\")\n            .map((hexTemp) => hexTemp + hexTemp)\n            .join(\"\");\n          hex = `#${hexTemp}`;\n        }\n        return hex && `0x${hex.substr(1)}`;\n      })\n      .filter(Boolean)\n      .map(normalizeColor);\n  }\n}\n\nfunction Zenitho() {\n    const ctnDom = useRef(null);\n    useEffect(() => {\n        if (!ctnDom.current) {\n            return;\n        }\n        const ctn = ctnDom.current;\n        const gradient = new Gradient();\n        gradient.initGradient({\n            gradientColors: [\"#ef008f\", \"#6ec3f4\", \"#7038ff\", \"#ffba27\"],\n        });\n        ctn.appendChild(gradient.el);\n        return () => {\n            gradient.disconnect();\n            ctn.removeChild(gradient.el);\n            gradient.minigl.gl.getExtension(\"WEBGL_lose_context\")?.loseContext();\n        };\n    }, []);\n    return (React.createElement(\"div\", { ref: ctnDom, style: {\n            width: \"100%\",\n            height: \"100%\",\n        } }));\n}\n\nexport { Zenitho };\n", "\"use client\"\nimport { Renderer, Triangle, Program, Color, Mesh } from 'ogl';\nimport React, { useRef, useEffect } from 'react';\n\nvar styles = {\"gradient-canvas\":\"styles-module_gradient-canvas__cHoa1\"};\n\nvar vert = \"\\nattribute vec2 uv;\\nattribute vec2 position;\\n\\nvarying vec2 vUv;\\n\\nvoid main() {\\n    vUv = uv;\\n    gl_Position = vec4(position, 0, 1);\\n}\";\n\nvar frag = \"precision highp float;\\n\\nuniform float uTime;\\nuniform vec3 uColor;\\nuniform vec3 uResolution;\\n\\nvarying vec2 vUv;\\n\\nvoid main() {\\n\\n    float mr = min(uResolution.x, uResolution.y);\\n    vec2 uv = (vUv.xy * 2.0 - 1.0) * uResolution.xy / mr;\\n\\n    float d = -uTime * 0.5;\\n    float a = 0.0;\\n    for (float i = 0.0; i < 8.0; ++i) {\\n        a += cos(i - d - a * uv.x);\\n        d += sin(uv.y * i + a);\\n    }\\n    d += uTime * 0.5;\\n    vec3 col = vec3(cos(uv * vec2(d, a)) * 0.6 + 0.4, cos(a + d) * 0.5 + 0.5);\\n    col = cos(col * cos(vec3(d, a, 2.5)) * 0.5 + 0.5);\\n    gl_FragColor = vec4(col,1.0);\\n\\n}\";\n\nfunction Novatrix(props) {\n    const ctnDom = useRef(null);\n    useEffect(() => {\n        if (!ctnDom.current) {\n            return;\n        }\n        const ctn = ctnDom.current;\n        const renderer = new Renderer();\n        const gl = renderer.gl;\n        gl.clearColor(1, 1, 1, 1);\n        function resize() {\n            const scale = 1;\n            // camera.perspective({\n            //   aspect: gl.canvas.width / gl.canvas.height,\n            // });\n            renderer.setSize(ctn.offsetWidth * scale, ctn.offsetHeight * scale);\n        }\n        window.addEventListener(\"resize\", resize, false);\n        resize();\n        const geometry = new Triangle(gl);\n        const program = new Program(gl, {\n            vertex: vert,\n            fragment: frag,\n            uniforms: {\n                uTime: { value: 0 },\n                uColor: { value: new Color(0.3, 0.2, 0.5) },\n                uResolution: {\n                    value: new Color(gl.canvas.width, gl.canvas.height, gl.canvas.width / gl.canvas.height),\n                },\n            },\n        });\n        const mesh = new Mesh(gl, { geometry, program });\n        let animateId;\n        animateId = requestAnimationFrame(update);\n        function update(t) {\n            animateId = requestAnimationFrame(update);\n            program.uniforms.uTime.value = t * 0.001;\n            // Don't need a camera if camera uniforms aren't required\n            renderer.render({ scene: mesh });\n        }\n        ctn.appendChild(gl.canvas);\n        return () => {\n            cancelAnimationFrame(animateId);\n            window.removeEventListener(\"resize\", resize);\n            ctn.removeChild(gl.canvas);\n            gl.getExtension(\"WEBGL_lose_context\")?.loseContext();\n        };\n    }, []);\n    return (React.createElement(\"div\", { ref: ctnDom, className: styles.gradientCanvas, style: {\n            width: \"100%\",\n            height: \"100%\",\n        }, ...props }));\n}\n\nexport { Novatrix };\n", "\"use client\"\nimport { Renderer, Triangle, Program, Color, Mesh } from 'ogl';\nimport React, { useRef, useEffect } from 'react';\n\nvar styles = {\"gradient-canvas\":\"styles-module_gradient-canvas__JTefP\"};\n\nvar vert = \"\\nattribute vec2 uv;\\nattribute vec2 position;\\n\\nvarying vec2 vUv;\\n\\nvoid main() {\\n    vUv = uv;\\n    gl_Position = vec4(position, 0, 1);\\n}\";\n\nvar frag = \"\\nprecision highp float;\\n\\nuniform float uTime;\\nuniform vec3 uColor;\\nuniform vec3 uResolution;\\n\\nvarying vec2 vUv;\\n\\n\\nconst float PI = 3.14159265359;\\n\\nconst float barWidth = 0.002;\\nconst float slideValY = 0.5;\\nconst float slideValX = 0.5;\\nconst int ITERATIONS = 4;\\n\\n\\n// *** Change these to suit your range of random numbers..\\n\\nconst float HASHSCALE1 = .1031;\\nconst vec3 HASHSCALE3 = vec3(.1031, .1030, .0973);\\nconst vec4 HASHSCALE4 = vec4(.1031, .1030, .0973, .1099);\\n\\n\\n\\n//----------------------------------------------------------------------------------------\\n//  1 out, 1 in...\\nfloat hash11(float p)\\n{\\n    vec3 p3 = fract(vec3(p) * HASHSCALE1);\\n    p3 += dot(p3, p3.yzx + 19.19);\\n    return fract((p3.x + p3.y) * p3.z);\\n}\\n\\n//----------------------------------------------------------------------------------------\\n//  1 out, 2 in...\\nfloat hash12(vec2 p)\\n{\\n    vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\\n    p3 += dot(p3, p3.yzx + 19.19);\\n    return fract((p3.x + p3.y) * p3.z);\\n}\\n\\n//----------------------------------------------------------------------------------------\\n//  1 out, 3 in...\\nfloat hash13(vec3 p3)\\n{\\n    p3  = fract(p3 * HASHSCALE1);\\n    p3 += dot(p3, p3.yzx + 19.19);\\n    return fract((p3.x + p3.y) * p3.z);\\n}\\n\\n//----------------------------------------------------------------------------------------\\n//  2 out, 1 in...\\nvec2 hash21(float p)\\n{\\n    vec3 p3 = fract(vec3(p) * HASHSCALE3);\\n    p3 += dot(p3, p3.yzx + 19.19);\\n    return fract((p3.xx+p3.yz)*p3.zy);\\n\\n}\\n\\n//----------------------------------------------------------------------------------------\\n///  2 out, 2 in...\\nvec2 hash22(vec2 p)\\n{\\n    vec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\\n    p3 += dot(p3, p3.yzx+19.19);\\n    return fract((p3.xx+p3.yz)*p3.zy);\\n\\n}\\n\\n//----------------------------------------------------------------------------------------\\n///  2 out, 3 in...\\nvec2 hash23(vec3 p3)\\n{\\n    p3 = fract(p3 * HASHSCALE3);\\n    p3 += dot(p3, p3.yzx+19.19);\\n    return fract((p3.xx+p3.yz)*p3.zy);\\n}\\n\\n//----------------------------------------------------------------------------------------\\n//  3 out, 1 in...\\nvec3 hash31(float p)\\n{\\n    vec3 p3 = fract(vec3(p) * HASHSCALE3);\\n    p3 += dot(p3, p3.yzx+19.19);\\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\\n}\\n\\n\\n//----------------------------------------------------------------------------------------\\n///  3 out, 2 in...\\nvec3 hash32(vec2 p)\\n{\\n    vec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\\n    p3 += dot(p3, p3.yxz+19.19);\\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\\n}\\n\\n//----------------------------------------------------------------------------------------\\n///  3 out, 3 in...\\nvec3 hash33(vec3 p3)\\n{\\n    p3 = fract(p3 * HASHSCALE3);\\n    p3 += dot(p3, p3.yxz+19.19);\\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\\n\\n}\\n\\n//----------------------------------------------------------------------------------------\\n// 4 out, 1 in...\\nvec4 hash41(float p)\\n{\\n    vec4 p4 = fract(vec4(p) * HASHSCALE4);\\n    p4 += dot(p4, p4.wzxy+19.19);\\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\\n\\n}\\n\\n//----------------------------------------------------------------------------------------\\n// 4 out, 2 in...\\nvec4 hash42(vec2 p)\\n{\\n    vec4 p4 = fract(vec4(p.xyxy) * HASHSCALE4);\\n    p4 += dot(p4, p4.wzxy+19.19);\\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\\n\\n}\\n\\n//----------------------------------------------------------------------------------------\\n// 4 out, 3 in...\\nvec4 hash43(vec3 p)\\n{\\n    vec4 p4 = fract(vec4(p.xyzx)  * HASHSCALE4);\\n    p4 += dot(p4, p4.wzxy+19.19);\\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\\n}\\n\\n//----------------------------------------------------------------------------------------\\n// 4 out, 4 in...\\nvec4 hash44(vec4 p4)\\n{\\n    p4 = fract(p4  * HASHSCALE4);\\n    p4 += dot(p4, p4.wzxy+19.19);\\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\\n}\\n\\n\\nconst float arrow_density = 4.5;\\nconst float arrow_length = .45;\\n\\nconst int iterationTime1 = 20;\\nconst int iterationTime2 = 20;\\nconst int vector_field_mode = 0;\\nconst float scale = 6.;\\n\\nconst float velocity_x = 0.1;\\nconst float velocity_y = 0.2;\\n\\nconst float mode_2_speed = 2.5;\\nconst float mode_1_detail = 200.;\\nconst float mode_1_twist = 50.;\\n\\nconst bool isArraw = true;\\n\\nconst vec3 luma = vec3(0.2126, 0.7152, 0.0722);\\n\\n\\nfloat f(in vec2 p)\\n{\\n    return sin(p.x+sin(p.y+uTime*velocity_x)) * sin(p.y*p.x*0.1+uTime*velocity_y);\\n}\\n\\n\\nstruct Field {\\n    vec2 vel;\\n    vec2 pos;\\n};\\n\\n//---------------Field to visualize defined here-----------------\\n\\nField field(in vec2 p,in int mode)\\n{\\n    Field field;\\n    if(mode == 0){\\n        vec2 ep = vec2(0.05,0.);\\n        vec2 rz= vec2(0);\\n        //# centered grid sampling\\n        for( int i=0; i<iterationTime1; i++ )\\n        {\\n            float t0 = f(p);\\n            float t1 = f(p + ep.xy);\\n            float t2 = f(p + ep.yx);\\n            vec2 g = vec2((t1-t0), (t2-t0))/ep.xx;\\n            vec2 t = vec2(-g.y,g.x);\\n\\n            //# need update 'p' for next iteration,but give it some change.\\n            p += (mode_1_twist*0.01)*t + g*(1./mode_1_detail);\\n            p.x = p.x + sin( uTime*mode_2_speed/10.)/10.;\\n            p.y = p.y + cos(uTime*mode_2_speed/10.)/10.;\\n            rz= g;\\n        }\\n        field.vel = rz;\\n        return field;\\n    }\\n\\n    if(mode == 1){\\n        vec2 ep = vec2(0.05,0.);\\n        vec2 rz= vec2(0);\\n        //# centered grid sampling\\n        for( int i=0; i<iterationTime1; i++ )\\n        {\\n            float t0 = f(p);\\n            float t1 = f(p + ep.xy);\\n            float t2 = f(p + ep.yx);\\n            vec2 g = vec2((t1-t0), (t2-t0))/ep.xx;\\n            vec2 t = vec2(-g.y,g.x);\\n\\n            //# need update 'p' for next iteration,but give it some change.\\n            p += (mode_1_twist*0.01)*t + g*(1./mode_1_detail);\\n            p.x = p.x + sin( uTime*mode_2_speed/10.)/10.;\\n            p.y = p.y + cos(uTime*mode_2_speed/10.)/10.;\\n            rz= g;\\n        }\\n\\n        field.vel = rz;\\n        // add curved effect into curved mesh\\n        for(int i=1; i<iterationTime2; i++){\\n            //# try comment these 2 lines,will give more edge effect\\n            p.x+=0.3/float(i)*sin(float(i)*3.*p.y+uTime*mode_2_speed) + 0.5;\\n            p.y+=0.3/float(i)*cos(float(i)*3.*p.x + uTime*mode_2_speed) + 0.5;\\n        }\\n        field.pos = p;\\n        return field;\\n    }\\n\\n    return field;\\n}\\n//---------------------------------------------------------------\\n\\nfloat segm(in vec2 p, in vec2 a, in vec2 b) //from iq\\n{\\n    vec2 pa = p - a;\\n    vec2 ba = b - a;\\n    float h = clamp(dot(pa,ba)/dot(ba,ba), 0., 1.);\\n    return length(pa - ba*h)*20.*arrow_density;\\n}\\n\\nfloat fieldviz(in vec2 p,in int mode)\\n{\\n    vec2 ip = floor(p*arrow_density)/arrow_density + .5/arrow_density;\\n    vec2 t = field(ip,mode).vel;\\n    float m = min(0.1,pow(length(t),0.5)*(arrow_length/arrow_density));\\n    vec2 b = normalize(t)*m;\\n    float rz = segm(p, ip, ip+b);\\n    vec2 prp = (vec2(-b.y,b.x));\\n    rz = min(rz,segm(p, ip+b, ip+b*0.65+prp*0.3));\\n    return clamp(min(rz,segm(p, ip+b, ip+b*0.65-prp*0.3)),0.,1.);\\n}\\n\\n\\nvec3 getRGB(in Field fld,in int mode){\\n\\n    if(mode == 0){\\n        vec2 p = fld.vel;\\n        vec3 origCol = vec3(p * 0.5 + 0.5, 1.5);\\n        return origCol;\\n    }\\n\\n    if(mode == 1){\\n        vec2 p = fld.pos;\\n        float r=cos(p.x+p.y+1.)*.5+.5;\\n        float g=sin(p.x+p.y+1.)*.5+.5;\\n        float b=(sin(p.x+p.y)+cos(p.x+p.y))*.3+.5;\\n        vec3 col = sin(vec3(-.3,0.1,0.5)+p.x-p.y)*0.65+0.35;\\n        return vec3(r,g,b);\\n    }\\n\\n}\\n\\nvoid main() {\\n\\n\\n    vec2 p = vUv.xy - 0.5;\\n    p.x *= uResolution.x / uResolution.y;\\n    p *= scale;\\n\\n    vec2 uv = vUv.xy;\\n    vec3 col;\\n    float fviz;\\n\\n    int vector_mode = 0;\\n    Field fld = field(p,vector_mode);\\n    col = getRGB(fld,vector_mode) * 0.85;\\n    gl_FragColor = vec4(col,1.0);\\n\\n\\n}\";\n\nfunction Velustro(props) {\n    const ctnDom = useRef(null);\n    useEffect(() => {\n        if (!ctnDom.current) {\n            return;\n        }\n        const ctn = ctnDom.current;\n        const renderer = new Renderer();\n        const gl = renderer.gl;\n        gl.clearColor(1, 1, 1, 1);\n        function resize() {\n            const scale = 1;\n            // camera.perspective({\n            //   aspect: gl.canvas.width / gl.canvas.height,\n            // });\n            renderer.setSize(ctn.offsetWidth * scale, ctn.offsetHeight * scale);\n        }\n        window.addEventListener(\"resize\", resize, false);\n        resize();\n        // Rather than using a plane (two triangles) to cover the viewport here is a\n        // triangle that includes -1 to 1 range for 'position', and 0 to 1 range for 'uv'.\n        // Excess will be out of the viewport.\n        //         position                uv\n        //      (-1, 3)                  (0, 2)\n        //         |\\                      |\\\n        //         |__\\(1, 1)              |__\\(1, 1)\n        //         |__|_\\                  |__|_\\\n        //   (-1, -1)   (3, -1)        (0, 0)   (2, 0)\n        const geometry = new Triangle(gl);\n        const program = new Program(gl, {\n            vertex: vert,\n            fragment: frag,\n            uniforms: {\n                uTime: { value: 0 },\n                uColor: { value: new Color(0.3, 0.2, 0.5) },\n                uResolution: {\n                    value: new Color(gl.canvas.width, gl.canvas.height, gl.canvas.width / gl.canvas.height),\n                },\n            },\n        });\n        const mesh = new Mesh(gl, { geometry, program });\n        let animateId;\n        animateId = requestAnimationFrame(update);\n        function update(t) {\n            animateId = requestAnimationFrame(update);\n            program.uniforms.uTime.value = t * 0.001;\n            // Don't need a camera if camera uniforms aren't required\n            renderer.render({ scene: mesh });\n        }\n        ctn.appendChild(gl.canvas);\n        return () => {\n            cancelAnimationFrame(animateId);\n            window.removeEventListener(\"resize\", resize);\n            ctn.removeChild(gl.canvas);\n            gl.getExtension(\"WEBGL_lose_context\")?.loseContext();\n        };\n    }, []);\n    return (React.createElement(\"div\", { ref: ctnDom, className: styles.gradientCanvas, style: {\n            width: \"100%\",\n            height: \"100%\",\n        }, ...props }));\n}\n\nexport { Velustro };\n", "\"use client\"\nimport { Renderer, Triangle, Program, Color, Mesh } from 'ogl';\nimport React, { useRef, useEffect } from 'react';\n\nvar styles = {\"gradient-canvas\":\"styles-module_gradient-canvas__WCAHc\"};\n\nvar vert = \"\\nattribute vec2 uv;\\nattribute vec2 position;\\n\\nvarying vec2 vUv;\\n\\nvoid main() {\\n    vUv = uv;\\n    gl_Position = vec4(position, 0, 1);\\n}\";\n\nvar frag = \"precision highp float;\\n\\nuniform float uTime;\\nuniform vec3 uColor;\\nuniform vec3 uResolution;\\n\\nvarying vec2 vUv;\\n\\n\\n/*\\n\\n\\n\\tTriangle Grid Contouring\\n\\t------------------------\\n\\n\\tUsing a 2D simplex grid to construct the isolines of a 2D field function, namely\\n    gradient noise. I'm not entirely sure what to call the process. Since it's the\\n\\ttriangular version of the marching squares algorithm, you'd think it'd be called\\n\\t\\\"marching triangles,\\\" but that term is used to describe grid point cloud related\\n    triangulation. Therefore, \\\"triangle grid contouring\\\" will do. :)\\n\\n\\tI've been coding up some Wang tile related patterns on square grids lately, which got\\n\\tme thinking about attempting the same on a triangle grid. Whilst doing that, I got\\n\\tsidetracked and wondered what contour lines created with the triangular equivalent of\\n\\ta marching squares algorithm would look like, and here we are. :)\\n\\n    I put this together for novelty purposes, but I'd imagine there'd be some practical\\n\\taspects associated with it; Vector contour point lists would be an obvious one, and\\n\\tto a lesser extent, triangulated height maps. However, rendering smooth curves would\\n\\tbe one of the main benefits. Only one unique linear interpolant is rendered through\\n\\teach triangle, which means that Bezier point information via neighboring triangles\\n\\twith shared edges would be easy to obtain.... I might demonstrate that at a later\\n\\tdate, but for now, a novel proof of concept will do.\\n\\n\\n*/\\n\\n// If you were rendering from a vertex shader, or just pushing out a triangle list\\n// in general, then you'd need to triangulate the triangles that have been split into\\n// quads. The process is almost trivial with just one contour, and slightly more\\n// involved with two, but not too difficult. Anyway, here's a visual representation.\\n// Aesthetically, I kind of like it, but it's a little busy, so is off by default.\\n//#define TRIANGULATE_CONTOURS\\n\\n// Filling the cells with a concentric triangle pattern. I couldn't decide whether\\n// to include it, or not, so it's here as an option.\\n\\n// Render green grass on the terrain. Uncommented leaves dry terrain.\\n\\n// Standard 2D rotation formula.\\nmat2 rot2(float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\\n\\n\\n// Standard vec2 to float hash - Based on IQ's original.\\nfloat hash21(vec2 p){ return fract(sin(dot(p, vec2(141.13, 289.97)))*43758.5453); }\\n\\n\\n// vec2 to vec2 hash.\\nvec2 hash22(vec2 p) {\\n\\n    // Faster, but doesn't disperse things quite as nicely. However, when framerate\\n    // is an issue, and it often is, this is a good one to use. Basically, it's a tweaked\\n    // amalgamation I put together, based on a couple of other random algorithms I've\\n    // seen around... so use it with caution, because I make a tonne of mistakes. :)\\n    float n = sin(dot(p, vec2(41, 289)));\\n    //return fract(vec2(262144, 32768)*n)*2. - 1.;\\n\\n    // Animated.\\n    p = fract(vec2(262144, 32768)*n);\\n    return sin(p*6.2831853 + uTime);\\n\\n}\\n\\n\\n// Based on IQ's gradient noise formula.\\nfloat n2D3G(vec2 p ){\\n\\n    vec2 i = floor(p); p -= i;\\n\\n    vec4 v;\\n    v.x = dot(hash22(i), p);\\n    v.y = dot(hash22(i + vec2(1, 0)), p - vec2(1, 0));\\n    v.z = dot(hash22(i + vec2(0, 1)), p - vec2(0, 1));\\n    v.w = dot(hash22(i + 1.), p - 1.);\\n\\n    p = p*p*p*(p*(p*6. - 15.) + 10.);\\n\\n    return mix(mix(v.x, v.y, p.x), mix(v.z, v.w, p.x), p.y);\\n    //return v.x + p.x*(v.y - v.x) + p.y*(v.z - v.x) + p.x*p.y*(v.x - v.y - v.z + v.w);\\n}\\n\\n\\n// The isofunction. Just a single noise function, but it can be more elaborate.\\nfloat isoFunction(vec2 p){ return n2D3G(p/4. + .07); }\\n\\n\\n// Unsigned distance to the segment joining \\\"a\\\" and \\\"b\\\".\\nfloat distLine(vec2 a, vec2 b){\\n\\n\\n    b = a - b;\\n    float h = clamp(dot(a, b)/dot(b, b), 0., 1.);\\n    return length(a - b*h);\\n}\\n\\n\\n// Based on IQ's signed distance to the segment joining \\\"a\\\" and \\\"b\\\".\\nfloat distEdge(vec2 a, vec2 b){\\n\\n    //if(abs(dot(a, a) - dot(b, b))>1e-5)\\n\\n\\n\\n    return dot((a + b)*.5, normalize((b - a).yx*vec2(-1, 1)) );\\n    //else return 1e5;\\n\\n}\\n\\n\\n\\n// Interpolating along the edge connecting vertices v1 and v2 with respect to the isovalue.\\nvec2 inter(vec2 p1, vec2 p2, float v1, float v2, float isovalue){\\n\\n    // The interpolated point will fall somewhere between the vertex points p1 and p2.\\n    // Obviously if the isovalue is closer to p1, then the interpolated point will be\\n    // closer to p1, and vice versa.\\n    //\\n    // If you're wondering about the weird numerical hacks on the end, it's a fudge keep the\\n    // lines away from the triangle edges. Because this is a per grid cell implementation,\\n    // there's neighboring cell overlap to deal with, which basically means rendering more\\n    // cells. Typically, that's not particularly difficult to deal with, but can be slower.\\n    // Either way, I wanted to keep things simple... and I'm lazy. Hence, the fugde. :)\\n    return mix(p1, p2, (isovalue - v1)/(v2 - v1)*.75 + .25/2.);\\n\\n    // The mix bit -- without the numberical hacks -- is equivalent to:\\n    //return p1 + (isovalue - v1)/(v2 - v1)*(p2 - p1);\\n\\n    // This is probably more correct, but we seem to be getting away with the line above.\\n    //float inter = v1 == v2 ? .5 : (isovalue - v1) /(v2 - v1);\\n    //return mix(p1, p2, inter);\\n}\\n\\n// Isoline function.\\nint isoLine(vec3 n3, vec2 ip0, vec2 ip1, vec2 ip2, float isovalue, float i,\\ninout vec2 p0, inout vec2 p1){\\n\\n\\n    // Points where the lines cut the edges.\\n    p0 = vec2(1e5), p1 = vec2(1e5);\\n\\n    // Marching triangles.. Is that a thing? Either way, it's similar to marching\\n    // squares, but with triangles. In other words, obtain the underlying function\\n    // value at all three vertices of the triangle cell, compare them to the\\n    // isovalue (over or under), then render a line between the corresponding edges.\\n    //\\n    // The line cuts each edge in accordance with the isovalues at each edge, which\\n    // means interpolating between the two.\\n\\n    // Bitwise accumulation to produce a unique index number upon which to make\\n    // decisions. It's a pretty standard technique.\\n    //\\n    // Minumum threshold value... It's an ID, of sorts.\\n    int iTh = 0;\\n    //\\n    // If the first vertex is over the isovalue threshold, add four, etc.\\n    if(n3.x>isovalue) iTh += 4;\\n    if(n3.y>isovalue) iTh += 2;\\n    if(n3.z>isovalue) iTh += 1;\\n\\n\\n    // A value of 1 or 6 means constructing a line between the\\n    // second and third edges, and so forth.\\n    if(iTh == 1 || iTh == 6){ // 12-20\\n\\n        p0 = inter(ip1, ip2, n3.y, n3.z, isovalue); // Edge two.\\n        p1 = inter(ip2, ip0, n3.z, n3.x, isovalue); // Edge three.\\n\\n    }\\n    else if(iTh == 2 || iTh == 5){ // 01-12\\n\\n        p0 = inter(ip0, ip1, n3.x, n3.y, isovalue); // Edge one.\\n        p1 = inter(ip1, ip2, n3.y, n3.z, isovalue); // Edge two.\\n\\n    }\\n    else if(iTh == 3 || iTh == 4){ // 01-20\\n\\n        p0 = inter(ip0, ip1, n3.x, n3.y, isovalue); // Edge one.\\n        p1 = inter(ip2, ip0, n3.z, n3.x, isovalue); // Edge three.\\n\\n    }\\n\\n\\n    // For the last three cases, we're after the other side of\\n    // the line, and this is a quick way to do that. Uncomment\\n    // to see why it's necessary.\\n    if(iTh>=4 && iTh<=6){ vec2 tmp = p0; p0 = p1; p1 = tmp; }\\n\\n    // Just to make things more confusing, it's necessary to flip coordinates on\\n    // alternate triangles, due to the simplex grid triangle configuration. This\\n    // line basically represents an hour of my life that I won't get back. :D\\n    if(i == 0.){ vec2 tmp = p0; p0 = p1; p1 = tmp; }\\n\\n\\n    // Return the ID, which will be used for rendering purposes.\\n    return iTh;\\n\\n\\n}\\n\\n/*\\nvec3 softLight(vec3 s, vec3 d){\\n\\n    vec3 a = d - (1. - 2.*s)*d*(1. - d), b = d + (2.*s - 1.)*d*((16.*d - 12.)*d + 3.),\\n         c = d + (2.*s - 1.)*(sqrt(d) - d);\\n\\n    return vec3(s.x<.5? a.x : d.x<.25? b.x : c.x, s.y<.5? a.y : d.y<.25? b.y : c.y,\\n    \\t\\t\\ts.z<.5? a.z : d.z<.25? b.z : c.z);\\n\\n}\\n*/\\n\\nvec3 simplexContour(vec2 p){\\n\\n\\n\\n    // Scaling constant.\\n    const float gSc = 8.;\\n    p *= gSc;\\n\\n\\n    // Keeping a copy of the orginal position.\\n    vec2 oP = p;\\n\\n    // Wobbling the coordinates, just a touch, in order to give a subtle hand drawn appearance.\\n    p += vec2(n2D3G(p*3.5), n2D3G(p*3.5 + 7.3))*.015;\\n\\n\\n\\n    // SIMPLEX GRID SETUP\\n\\n    vec2 s = floor(p + (p.x + p.y)*.36602540378); // Skew the current point.\\n\\n    p -= s - (s.x + s.y)*.211324865; // Use it to attain the vector to the base vertex (from p).\\n\\n    // Determine which triangle we're in. Much easier to visualize than the 3D version.\\n    float i = p.x < p.y? 1. : 0.; // Apparently, faster than: i = step(p.y, p.x);\\n    vec2 ioffs = vec2(1. - i, i);\\n\\n    // Vectors to the other two triangle vertices.\\n    vec2 ip0 = vec2(0), ip1 = ioffs - .2113248654, ip2 = vec2(.577350269);\\n\\n\\n    // Centralize everything, so that vec2(0) is in the center of the triangle.\\n    vec2 ctr = (ip0 + ip1 + ip2)/3.; // Centroid.\\n    //\\n    ip0 -= ctr; ip1 -= ctr; ip2 -= ctr; p -= ctr;\\n\\n\\n\\n    // Take a function value (noise, in this case) at each of the vertices of the\\n    // individual triangle cell. Each will be compared the isovalue.\\n    vec3 n3;\\n    n3.x = isoFunction(s);\\n    n3.y = isoFunction(s + ioffs);\\n    n3.z = isoFunction(s + 1.);\\n\\n\\n    // Various distance field values.\\n    float d = 1e5, d2 = 1e5, d3 = 1e5, d4 = 1e5, d5 = 1e5;\\n\\n\\n    // The first contour, which separates the terrain (grass or barren) from the beach.\\n    float isovalue = 0.;\\n\\n    // The contour edge points that the line will run between. Each are passed into the\\n    // function below and calculated.\\n    vec2 p0, p1;\\n\\n    // The isoline. The edge values (p0 and p1) are calculated, and the ID is returned.\\n    int iTh = isoLine(n3, ip0, ip1, ip2, isovalue, i, p0, p1);\\n\\n    // The minimum distance from the pixel to the line running through the triangle edge\\n    // points.\\n    d = min(d, distEdge(p - p0, p - p1));\\n\\n\\n\\n    //if(iTh == 0) d = 1e5;\\n\\n    // Totally internal, which means a terrain (grass) hit.\\n    if(iTh == 7){ // 12-20\\n\\n        // Triangle.\\n        //d = min(min(distEdge(p - ip0, p - ip1), distEdge(p - ip1, p - ip2)),\\n        //distEdge(p - ip0, p - ip2));\\n\\n        // Easier just to set the distance to a hit.\\n        d = 0.;\\n    }\\n\\n\\n\\n    // Contour lines.\\n    d3 = min(d3, distLine((p - p0), (p - p1)));\\n    // Contour points.\\n    d4 = min(d4, min(length(p - p0), length(p - p1)));\\n\\n\\n\\n\\n\\n    // Displaying the 2D simplex grid. Basically, we're rendering lines between\\n    // each of the three triangular cell vertices to show the outline of the\\n    // cell edges.\\n    float tri = min(min(distLine(p - ip0, p - ip1), distLine(p - ip1, p - ip2)),\\n    distLine(p - ip2, p - ip0));\\n\\n    // Adding the triangle grid to the d5 distance field value.\\n    d5 = min(d5, tri);\\n\\n\\n    // Dots in the centers of the triangles, for whatever reason. :) Take them out, if\\n    // you prefer a cleaner look.\\n    d5 = min(d5, length(p) - .02);\\n\\n\\n    // The second contour: This one demarcates the beach from the sea.\\n    isovalue = -.15;\\n\\n    // The isoline. The edge values (p0 and p1) are calculated, and the ID is returned.\\n    int iTh2 = isoLine(n3, ip0, ip1, ip2, isovalue, i, p0, p1);\\n\\n    // The minimum distance from the pixel to the line running through the triangle edge\\n    // points.\\n    d2 = min(d2, distEdge(p - p0, p - p1));\\n\\n    // Make a copy.\\n    float oldD2 = d2;\\n\\n    if(iTh2 == 7) d2 = 0.;\\n    if(iTh == 7) d2 = 1e5;\\n    d2 = max(d2, -d);\\n\\n\\n    // Contour lines - 2nd (beach) contour.\\n    d3 = min(d3, distLine((p - p0), (p - p1)));\\n    // Contour points - 2nd (beach) contour.\\n    d4 = min(d4, min(length(p - p0), length(p - p1)));\\n\\n    d4 -= .075;\\n    d3 -= .0125;\\n\\n\\n    // The screen coordinates have been scaled up, so the distance values need to be\\n    // scaled down.\\n    d /= gSc;\\n    d2 /= gSc;\\n    d3 /= gSc;\\n    d4 /= gSc;\\n    d5 /= gSc;\\n\\n\\n\\n    // Rendering - Coloring.\\n\\n    // Initial color.\\n    vec3 col = vec3(1, .85, .6);\\n\\n    // Smoothing factor.\\n    float sf = .004;\\n\\n    // Water.\\n    if(d>0. && d2>0.) col = vec3(.3, .3, .3)*.45;\\n    // Water edging.\\n    if(d>0.) col = mix(col, vec3(.2, .2, .2)*.3, (1. - smoothstep(0., sf, d2 - .012)));\\n\\n    // Beach.\\n    col = mix(col, vec3(0.5, 0.5, 0.5),  (1. - smoothstep(0., sf, d2)));\\n    // Beach edging.\\n    col = mix(col, vec3(0.3, 0.3, 0.3)*.6, (1. - smoothstep(0., sf, d - .012)));\\n\\n    col = mix(col, vec3(0.1, 0.1, 0.1)*.95, (1. - smoothstep(0., sf, d)));\\n\\n\\n\\n\\n    // Abstract shading, based on the individual noise height values for each triangle.\\n    if(d2>0.) col *= (abs(dot(n3, vec3(1)))*1.25 + 1.25)/2.;\\n    else col *= max(2. - (dot(n3, vec3(1)) + 1.45)/1.25, 0.);\\n\\n    // More abstract shading.\\n    //if(iTh!=0) col *= float(iTh)/7.*.5 + .6;\\n    //else col *= float(3.)/7.*.5 + .75;\\n\\n\\n    float pat = abs(fract(tri*12.5 + .4) - .5)*2.;\\n    col *= pat*.425 + .75;\\n\\n\\n\\n\\n    // Triangle grid overlay.\\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, d5))*.95);\\n\\n\\n\\n    // Lines.\\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, d3)));\\n\\n\\n    // Dots.\\n    col = mix(col, vec3(0), (1. - smoothstep(0., sf, d4)));\\n    col = mix(col, vec3(1), (1. - smoothstep(0., sf, d4 + .005)));\\n\\n\\n\\n    // Rough pencil color overlay... The calculations are rough... Very rough, in fact,\\n    // since I'm only using a small overlayed portion of it. Flockaroo does a much, much\\n    // better pencil sketch algorithm here:\\n    //\\n    // When Voxels Wed Pixels - Flockaroo\\n    // https://www.shadertoy.com/view/MsKfRw\\n    //\\n    // Anyway, the idea is very simple: Render a layer of noise, stretched out along one\\n    // of the directions, then mix a similar, but rotated, layer on top. Whilst doing this,\\n    // compare each layer to it's underlying grey scale value, and take the difference...\\n    // I probably could have described it better, but hopefully, the code will make it\\n    // more clear. :)\\n    //\\n    // Tweaked to suit the brush stroke size.\\n    vec2 q = oP*1.5;\\n    // I always forget this bit. Without it, the grey scale value will be above one,\\n    // resulting in the extra bright spots not having any hatching over the top.\\n    col = min(col, 1.);\\n    // Underlying grey scale pixel value -- Tweaked for contrast and brightness.\\n    float gr = sqrt(dot(col, vec3(.299, .587, .114)))*1.25;\\n    // Stretched fBm noise layer.\\n    float ns = (n2D3G(q*4.*vec2(1./3., 3))*.64 + n2D3G(q*8.*vec2(1./3., 3))*.34)*.5 + .5;\\n    // Compare it to the underlying grey scale value.\\n    ns = gr - ns;\\n    //\\n    // Repeat the process with a rotated layer.\\n    q *= rot2(3.14159/3.);\\n    float ns2 = (n2D3G(q*4.*vec2(1./3., 3))*.64 + n2D3G(q*8.*vec2(1./3., 3))*.34)*.5 + .5;\\n    ns2 = gr - ns2;\\n    //\\n    // Mix the two layers in some way to suit your needs. Flockaroo applied common sense,\\n    // and used a smooth threshold, which works better than the dumb things I was trying. :)\\n    ns = smoothstep(0., 1., min(ns, ns2)); // Rough pencil sketch layer.\\n    //\\n    // Mix in a small portion of the pencil sketch layer with the clean colored one.\\n    col = mix(col, col*(ns + .35), .4);\\n    // Has more of a colored pencil feel.\\n    //col *= vec3(.8)*ns + .5;\\n    // Using Photoshop mixes, like screen, overlay, etc, gives more visual options. Here's\\n    // an example, but there's plenty more. Be sure to uncomment the \\\"softLight\\\" function.\\n    //col = softLight(col, vec3(ns)*.75);\\n    // Uncomment this to see the pencil sketch layer only.\\n    //col = vec3(ns);\\n\\n\\n    /*\\n    // Just some line overlays.\\n    vec2 pt = p;\\n    float offs = -.5;\\n    if(i<.5) offs += 2.;//pt.xy = -pt.xy;\\n    pt = rot2(6.2831/3.)*pt;\\n    float pat2 = clamp(cos(pt.x*6.2831*14. - offs)*2. + 1.5, 0., 1.);\\n    col *= pat2*.4 + .8;\\n    */\\n\\n\\n    // Cheap paper grain.\\n    //oP = floor(oP/gSc*1024.);\\n    //vec3 rn3 = vec3(hash21(oP), hash21(oP + 2.37), hash21(oP + 4.83));\\n    //col *= .9 + .1*rn3.xyz  + .1*rn3.xxx;\\n\\n\\n    // Return the simplex weave value.\\n    return col;\\n\\n\\n}\\n\\nvoid main() {\\n\\n\\n    // Screen coordinates. I've put a cap on the fullscreen resolution to stop\\n    // the pattern looking too blurred out.\\n    vec2 uv = (vUv.xy - .5)*uResolution.xy/max(min(650., uResolution.y), 250.);\\n\\n    // Position with some scrolling, and screen rotation to level the pattern.\\n    vec2 p = rot2(3.14159/12.)*uv + vec2(.8660254, .5)*uTime/16.;\\n\\n    // The simplex grid contour map... or whatever you wish to call it. :)\\n    vec3 col = simplexContour(p);\\n\\n    // Subtle vignette.\\n    uv = vUv.xy;\\n    col *= pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , .0625) + .1;\\n    // Colored variation.\\n    //col = mix(col.zyx/2., col, pow(16.*uv.x*uv.y*(1. - uv.x)*(1. - uv.y) , .125));\\n\\n\\n    // Rough gamma correction.\\n    gl_FragColor = vec4(sqrt(max(col, 0.)), 1);\\n\\n\\n}\";\n\nfunction Opulento(props) {\n    const ctnDom = useRef(null);\n    useEffect(() => {\n        if (!ctnDom.current) {\n            return;\n        }\n        const ctn = ctnDom.current;\n        const renderer = new Renderer();\n        const gl = renderer.gl;\n        gl.clearColor(1, 1, 1, 1);\n        function resize() {\n            const scale = 1;\n            // camera.perspective({\n            //   aspect: gl.canvas.width / gl.canvas.height,\n            // });\n            renderer.setSize(ctn.offsetWidth * scale, ctn.offsetHeight * scale);\n        }\n        window.addEventListener(\"resize\", resize, false);\n        resize();\n        const geometry = new Triangle(gl);\n        const program = new Program(gl, {\n            vertex: vert,\n            fragment: frag,\n            uniforms: {\n                uTime: { value: 0 },\n                uColor: { value: new Color(0.3, 0.2, 0.5) },\n                uResolution: {\n                    value: new Color(gl.canvas.width, gl.canvas.height, gl.canvas.width / gl.canvas.height),\n                },\n            },\n        });\n        const mesh = new Mesh(gl, { geometry, program });\n        let animateId;\n        animateId = requestAnimationFrame(update);\n        function update(t) {\n            animateId = requestAnimationFrame(update);\n            program.uniforms.uTime.value = t * 0.001;\n            // Don't need a camera if camera uniforms aren't required\n            renderer.render({ scene: mesh });\n        }\n        ctn.appendChild(gl.canvas);\n        return () => {\n            cancelAnimationFrame(animateId);\n            window.removeEventListener(\"resize\", resize);\n            ctn.removeChild(gl.canvas);\n            gl.getExtension(\"WEBGL_lose_context\")?.loseContext();\n        };\n    }, []);\n    return (React.createElement(\"div\", { ref: ctnDom, className: styles.gradientCanvas, style: {\n            width: \"100%\",\n            height: \"100%\",\n        }, ...props }));\n}\n\nexport { Opulento };\n", "\"use client\"\nimport { Renderer, Triangle, Program, Color, Mesh } from 'ogl';\nimport React, { useRef, useEffect } from 'react';\n\nvar styles = {\"gradient-canvas\":\"styles-module_gradient-canvas__DEvy8\"};\n\nvar vert = \"\\nattribute vec2 uv;\\nattribute vec2 position;\\n\\nvarying vec2 vUv;\\n\\nvoid main() {\\n    vUv = uv;\\n    gl_Position = vec4(position, 0, 1);\\n}\";\n\nvar frag = \"precision highp float;\\n\\nuniform float uTime;\\nuniform vec3 uColor;\\nuniform vec3 uResolution;\\n\\nvarying vec2 vUv;\\n\\nfloat colormap_red(float x) {\\n    if (x < 0.0) {\\n        return 54.0 / 255.0;\\n    } else if (x < 20049.0 / 82979.0) {\\n        return (829.79 * x + 54.51) / 255.0;\\n    } else {\\n        return 1.0;\\n    }\\n}\\n\\nfloat colormap_green(float x) {\\n    if (x < 20049.0 / 82979.0) {\\n        return 0.0;\\n    } else if (x < 327013.0 / 810990.0) {\\n        return (8546482679670.0 / 10875673217.0 * x - 2064961390770.0 / 10875673217.0) / 255.0;\\n    } else if (x <= 1.0) {\\n        return (103806720.0 / 483977.0 * x + 19607415.0 / 483977.0) / 255.0;\\n    } else {\\n        return 1.0;\\n    }\\n}\\n\\nfloat colormap_blue(float x) {\\n    if (x < 0.0) {\\n        return 54.0 / 255.0;\\n    } else if (x < 7249.0 / 82979.0) {\\n        return (829.79 * x + 54.51) / 255.0;\\n    } else if (x < 20049.0 / 82979.0) {\\n        return 127.0 / 255.0;\\n    } else if (x < 327013.0 / 810990.0) {\\n        return (792.02249341361393720147485376583 * x - 64.364790735602331034989206222672) / 255.0;\\n    } else {\\n        return 1.0;\\n    }\\n}\\n\\nvec4 colormap(float x) {\\n    return vec4(colormap_red(x), colormap_green(x), colormap_blue(x), 1.0);\\n}\\n\\n// https://iquilezles.org/articles/warp\\n/*float noise( in vec2 x )\\n{\\n    vec2 p = floor(x);\\n    vec2 f = fract(x);\\n    f = f*f*(3.0-2.0*f);\\n    float a = textureLod(iChannel0,(p+vec2(0.5,0.5))/256.0,0.0).x;\\n\\tfloat b = textureLod(iChannel0,(p+vec2(1.5,0.5))/256.0,0.0).x;\\n\\tfloat c = textureLod(iChannel0,(p+vec2(0.5,1.5))/256.0,0.0).x;\\n\\tfloat d = textureLod(iChannel0,(p+vec2(1.5,1.5))/256.0,0.0).x;\\n    return mix(mix( a, b,f.x), mix( c, d,f.x),f.y);\\n}*/\\n\\n\\nfloat rand(vec2 n) {\\n    return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\\n}\\n\\nfloat noise(vec2 p){\\n    vec2 ip = floor(p);\\n    vec2 u = fract(p);\\n    u = u*u*(3.0-2.0*u);\\n\\n    float res = mix(\\n    mix(rand(ip),rand(ip+vec2(1.0,0.0)),u.x),\\n    mix(rand(ip+vec2(0.0,1.0)),rand(ip+vec2(1.0,1.0)),u.x),u.y);\\n    return res*res;\\n}\\n\\nconst mat2 mtx = mat2( 0.80,  0.60, -0.60,  0.80 );\\n\\nfloat fbm( vec2 p )\\n{\\n    float f = 0.0;\\n    float time = uTime * .25;\\n\\n    f += 0.500000*noise( p + time  ); p = mtx*p*2.02;\\n    f += 0.031250*noise( p ); p = mtx*p*2.01;\\n    f += 0.250000*noise( p ); p = mtx*p*2.03;\\n    f += 0.125000*noise( p ); p = mtx*p*2.01;\\n    f += 0.062500*noise( p ); p = mtx*p*2.04;\\n    f += 0.015625*noise( p + sin(time) );\\n\\n    return f/0.96875;\\n}\\n\\nfloat pattern( vec2 p )\\n{\\n    return fbm( p + fbm( p + fbm( p ) ) );\\n}\\n\\nvoid main() {\\n\\n\\n    vec2 uv = vUv.xy*uResolution.xy/uResolution.x;\\n    float shade = pattern(uv);\\n    gl_FragColor = vec4(colormap(shade).rgb, shade);\\n\\n\\n}\";\n\nfunction Tranquiluxe(props) {\n    const ctnDom = useRef(null);\n    useEffect(() => {\n        if (!ctnDom.current) {\n            return;\n        }\n        const ctn = ctnDom.current;\n        const renderer = new Renderer();\n        const gl = renderer.gl;\n        gl.clearColor(1, 1, 1, 1);\n        function resize() {\n            const scale = 1;\n            // camera.perspective({\n            //   aspect: gl.canvas.width / gl.canvas.height,\n            // });\n            renderer.setSize(ctn.offsetWidth * scale, ctn.offsetHeight * scale);\n        }\n        window.addEventListener(\"resize\", resize, false);\n        resize();\n        const geometry = new Triangle(gl);\n        const program = new Program(gl, {\n            vertex: vert,\n            fragment: frag,\n            uniforms: {\n                uTime: { value: 0 },\n                uColor: { value: new Color(0.3, 0.2, 0.5) },\n                uResolution: {\n                    value: new Color(gl.canvas.width, gl.canvas.height, gl.canvas.width / gl.canvas.height),\n                },\n            },\n        });\n        const mesh = new Mesh(gl, { geometry, program });\n        let animateId;\n        animateId = requestAnimationFrame(update);\n        function update(t) {\n            animateId = requestAnimationFrame(update);\n            program.uniforms.uTime.value = t * 0.001;\n            // Don't need a camera if camera uniforms aren't required\n            renderer.render({ scene: mesh });\n        }\n        ctn.appendChild(gl.canvas);\n        return () => {\n            cancelAnimationFrame(animateId);\n            window.removeEventListener(\"resize\", resize);\n            ctn.removeChild(gl.canvas);\n            gl.getExtension(\"WEBGL_lose_context\")?.loseContext();\n        };\n    }, []);\n    return (React.createElement(\"div\", { ref: ctnDom, className: styles.gradientCanvas, style: {\n            width: \"100%\",\n            height: \"100%\",\n        }, ...props }));\n}\n\nexport { Tranquiluxe };\n", "\"use client\"\nexport { Button } from './components/button/index.js';\nexport { Input } from './components/input/index.js';\nexport { Lumiflex } from './components/lumiflex/index.js';\nexport { Zenitho } from './components/zenitho/index.js';\nexport { Novatrix } from './components/novatrix/index.js';\nexport { Velustro } from './components/velustro/index.js';\nexport { Opulento } from './components/opulento/index.js';\nexport { Tranquiluxe } from './components/tranquiluxe/index.js';\nimport 'react';\nimport 'ogl';\n"],
  "mappings": "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;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA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",
  "names": ["React", "import_react", "styles", "React", "scale", "ID", "vertex", "length", "tempVec3", "ID", "copy", "set", "normalize", "dot", "multiply", "dot", "copy", "set", "dot", "normalize", "set", "copy", "normalize", "multiply", "dot", "copy", "set", "identity", "invert", "multiply", "scale", "add", "subtract", "set", "scale", "add", "subtract", "multiply", "identity", "copy", "invert", "invert", "fromQuat", "copy", "set", "identity", "invert", "multiply", "translate", "rotate", "scale", "set", "translate", "rotate", "scale", "multiply", "identity", "copy", "fromQuat", "invert", "ID", "copy", "set", "add", "subtract", "multiply", "divide", "scale", "distance", "squaredDistance", "length", "squaredLength", "negate", "inverse", "normalize", "dot", "cross", "lerp", "smoothLerp", "transformMat3", "transformMat4", "exactEquals", "set", "copy", "add", "subtract", "multiply", "scale", "divide", "inverse", "length", "distance", "squaredDistance", "squaredLength", "negate", "cross", "normalize", "dot", "exactEquals", "transformMat3", "transformMat4", "lerp", "smoothLerp", "tempVec3", "tempVec2a", "tempVec2b", "tempVec3a", "tempVec3b", "tempMat4", "tempVec3", "tempVec3", "tempVec3", "tempVec3", "tempMat4", "tempMat4", "tempMat4", "identity", "import_react", "styles", "scale", "React", "import_react", "e", "uniforms", "name", "length", "uniform", "width", "height", "t", "r", "hexTemp", "React", "import_react", "styles", "vert", "frag", "scale", "React", "import_react", "styles", "vert", "frag", "scale", "React", "import_react", "styles", "vert", "frag", "scale", "React", "import_react", "styles", "vert", "frag", "scale", "React", "import_react"]
}
